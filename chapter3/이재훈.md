# 가비지 컬렉터와 메모리 할당 전략

- 어떤 메모리를 회수해야 하나?
- 언제 회수해야 할까?
- 어떻게 회수해야 할까?

> 우리가 GC와 메모리 할당을 이해해야 하는 이유는 다양한 메모리 오버플로우와 누수 문제를 해결해야하는 상황이나 더 높은 동시성을 달성하는데 가비지 컬렉션이 방해되는
> 상황이 온다면, 적절히 모니터링하고, 조율할 수 있어야 하기 때문이다.

## 참조 카운팅 알고리즘

1. 객체를 가리키는 참조 카운터를 추가한다. 참조하는 곳이 하나 늘어날 때마다 카운터 값이 1씩 늘어난다.
2. 참조하는 곳이 하나 사라질 때마다 카운터 값이 1씩 감소시킨다.
3. 카운터 값이 0이 된 객체는 더는 사용할 수 없다.

자바 가상 머신에서는 참조 카운팅을 쓰지 않는다. 모든 상황에서 문제없이 동작하게
하려면 계산할게 상당히 늘어나기 때문이다.

```java
package main.gc;
/**
 * VM Args: -Xlog:gc*
 *
 * */
public class ReferenceCountingGC {
    private Object instance = null;
    private static final int _1MB = 1024 * 1024;
    // 메모리를 많이 차지하여 GC 로그에서 회수 여부를 명확히 알아볼 수 있게 한다.
    private byte[] bigSize = new byte[2 * _1MB];

    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        // 내부 필드로 서로를 참조
        objA.instance = objB;
        objB.instance = objA;
        // 참조 해제
        objA = null;
        objB = null;

        // 이 라인에서 GC를 수행한다면 objA와 objB가 회수될까 ?
        System.gc();
    }

    public static void main(String[] args) {
        testGC();
    }
}
```

```
[0.023s][info][gc,init] CardTable entry size: 512
[0.024s][info][gc     ] Using G1 <- 기본적으로 G1 컬렉터가 쓰임
[0.028s][info][gc,init] Version: 21.0.5+11-LTS (release)
[0.028s][info][gc,init] CPUs: 12 total, 12 available
[0.028s][info][gc,init] Memory: 32541M
[0.028s][info][gc,init] Large Page Support: Disabled
[0.028s][info][gc,init] NUMA Support: Disabled
[0.028s][info][gc,init] Compressed Oops: Enabled (Zero based)
[0.028s][info][gc,init] Heap Region Size: 4M
[0.028s][info][gc,init] Heap Min Capacity: 8M
[0.028s][info][gc,init] Heap Initial Capacity: 512M
[0.028s][info][gc,init] Heap Max Capacity: 8136M
[0.028s][info][gc,init] Pre-touch: Disabled
[0.028s][info][gc,init] Parallel Workers: 10
[0.028s][info][gc,init] Concurrent Workers: 3
[0.028s][info][gc,init] Concurrent Refinement Workers: 10
[0.028s][info][gc,init] Periodic GC: Disabled
[0.047s][info][gc,metaspace] CDS archive(s) mapped at: [0x000001d255000000-0x000001d255c80000-0x000001d255c80000), size 13107200, SharedBaseAddress: 0x000001d255000000, ArchiveRelocationMode: 1.
[0.047s][info][gc,metaspace] Compressed class space mapped at: 0x000001d256000000-0x000001d296000000, reserved size: 1073741824
[0.047s][info][gc,metaspace] Narrow klass base: 0x000001d255000000, Narrow klass shift: 0, Narrow klass range: 0x100000000
[0.167s][info][gc,start    ] GC(0) Pause Full (System.gc())
[0.167s][info][gc,task     ] GC(0) Using 3 workers of 10 for full compaction
[0.168s][info][gc,phases,start] GC(0) Phase 1: Mark live objects
[0.169s][info][gc,phases      ] GC(0) Phase 1: Mark live objects 1.470ms
[0.169s][info][gc,phases,start] GC(0) Phase 2: Prepare compaction
[0.170s][info][gc,phases      ] GC(0) Phase 2: Prepare compaction 0.644ms
[0.170s][info][gc,phases,start] GC(0) Phase 3: Adjust pointers
[0.171s][info][gc,phases      ] GC(0) Phase 3: Adjust pointers 1.310ms
[0.171s][info][gc,phases,start] GC(0) Phase 4: Compact heap
[0.172s][info][gc,phases      ] GC(0) Phase 4: Compact heap 0.783ms
[0.172s][info][gc,phases,start] GC(0) Phase 5: Reset Metadata
[0.172s][info][gc,phases      ] GC(0) Phase 5: Reset Metadata 0.172ms
[0.174s][info][gc,heap        ] GC(0) Eden regions: 1->0(1)
[0.174s][info][gc,heap        ] GC(0) Survivor regions: 0->0(0)
[0.174s][info][gc,heap        ] GC(0) Old regions: 0->1
[0.174s][info][gc,heap        ] GC(0) Humongous regions: 2->0
[0.174s][info][gc,metaspace   ] GC(0) Metaspace: 492K(640K)->492K(640K) NonClass: 460K(512K)->460K(512K) Class: 32K(128K)->32K(128K)
[0.174s][info][gc             ] GC(0) Pause Full (System.gc()) 12M->0M(16M) 7.247ms // 참조 카운터 쓰지 않음 ?
[0.174s][info][gc,cpu         ] GC(0) User=0.02s Sys=0.03s Real=0.01s
[0.176s][info][gc,heap,exit   ] Heap
[0.176s][info][gc,heap,exit   ]  garbage-first heap   total 16384K, used 2386K [0x0000000603800000, 0x0000000800000000)
[0.176s][info][gc,heap,exit   ]   region size 4096K, 1 young (4096K), 0 survivors (0K)
[0.176s][info][gc,heap,exit   ]  Metaspace       used 502K, committed 640K, reserved 1114112K
[0.176s][info][gc,heap,exit   ]   class space    used 33K, committed 128K, reserved 1048576K
```

## 도달 가능성 분석 알고리즘

자바, C#등 모두 객체 생사 판단에 도달 가능성 분석 알고리즘을 사용한다. 이 알고리즘의 기본 아이디어는 GC 루트라고 하는 루트 객체들을 시작 노드 집합으로 쓰는 것이다. 시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색해 들어간다. GC 루트로 부터 도달 불가능한 객체는 더 이상 사용할 수 없는게 확실해 진다. 그럼 해당 객체를 회수한다.

### GC 루트로 사용할 수 있는 객체

- 가상 머신 스택(스택 프레임의 지역 변수 테이블)에서 참조하는 객체 : 현재 실행 중인 메서드에서 쓰는 매개변수, 지역 변수, 임시 변수 등
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체 : 자바 클래스의 참조 타입 정적 변수
- 메서드 영역에서 상수로 참조되는 객체 : 문자열 테이블 안의 참조
- 네이티브 메서드 스택에서 JNI가 참조하는 객체
- 자바 가상 머신 내부에서 쓰이는 참조 : 기본 데이터 타입에 해당하는 Class 객체, 일부 상주 예외 클래스, 시스텤 클래스 로더
- 동기화 락(synchronized 키워드)으로 잠겨 있는 모든 객체
- 자바 가상 머신 내부 상황을 반영하는 JMXBean: JVMTI에 등록된 콜백, 로컬 코드 캐시 등

## 참조 - 강도

JDK 1.2부터 참조 개념이 확장되어 참조를 네가지로 구분하기 시작했다.

### 강한 참조

- 가장 전통적인 정의의 참조.
- Object obj = new Object() 처럼 프로그램에서 참조를 할당하는 것
- 강한 참조 관계가 남아있는 객체는 가비지 컬렉터가 절대 회수하지 않는다.

### 부드러운 참조

- 유용하지만 필수는 아닌 객체를 표현
- 부드러운 참조만 남은 객체라면 메모리 오버플로가 나기 직전에 두번째 회수를 위한 회수 목록에 추가된다.
- 두번째 회수에도 메모리가 부족하다면 그 때 매모리 오버플로 예외를 던진다.

### 약한 참조

- 부드러운 참조와 비슷하지만 연결 강도가 더 약하다. 약한 참조 뿐인 객체는 다음번 가비지 컬렉션까지만 살아 있다. 가비지 컬렉터가 동작하기 시작하면 메모리가 넉넉하더라도 약하게 참조된 객체는 모두 회수된다.

### 유령 참조

- 참조 중에서 가장 약하다.
- 객체 수명에 아무런 영향을 주지 않는다.
- 유령 참조를 거는 유일한 목적은 대상 객체가 회수 될 때 알림을 받기 위해서이다.

> 도달 가능성 분석 알고리즘이 '도달 불가능'으로 판단한 객체라고 해서 반드시 죽어야 하는 건 아니다. 확실한 사망 선고를 내리려면 두번의 marking 과정을 거쳐야 한다.

### finalize()

- finalize() 메서드는 GC가 객체를 메모리에서 제거하기 전에 호출되는 메서드이다.

### finalize()의 동작 방식

1. 객체가 더 이상 참조되지 않으면 GC 대상이 됨
2. GC가 실행되면 GC 직전에 finalize() 메서드가 한번 호출됨.
3. finalize() 실행 후에도 객체가 다시 참조되면 GC가 객체를 제거하지 않음.
4. 그렇지 않으면 객체는 최종적으로 삭제됨

> 주의 : finalize()가 호출된다고 해서 즉시 GC가 실행된다는 보장은 없음, GC의 실행 타이밍은 JVM이 관리

## 메서드 영역 회수하기

- 메서드 영역은 가비지 컬렉션 대상이 아닐까 ?
- JDK 11에 처음 탑재된 시험 버전의 ZGC 컬렉터는 클래스 언로딩을 지원하지 않았다.(JDK12부터 지원)
- 메서드 영역 GC은 비용 효율이 대체로 좋지 않음.
- 자바 힙은 GC로 메모리 공간의 70 ~ 99%를 회수한다. 반면 메서드 영역은 회수 조건이 까다로워 효율이 떨어진다.
- 메서드 영역의 GC는 크게 사용되지 않는 '상수', '클래스'를 회수한다.
- 다 쓴 '상수'를 회수하는 방법도 자바 힙에서 객체를 회수하는 방법과 매우 비슷하다.

### 다 쓴 상수 회수 과정

상수풀에 리터럴 회수 예제

1. 상수 풀 안에 "java" 상수를 참조하는 문자열 객체가 전혀 없다.
2. 가상 머신에서 이 리터럴을 사용하는 코드가 한 곳도 없다.
3. 회수가 시작되면 GC는 해당 상수를 상수풀에서 회수한다.

### 더 이상 쓰이지 않는 클래스 회수 조건

- 이 클래스는 인스턴스가 모두 회수, 즉, 자바 힙에는 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않음.
- 이 클래스를 읽어들인 클래스 로더가 회수. 이 조건은 OSGi나 JSP 리로딩 처럼 세심하게 설계된
  대안 클래스 로더 없이는 충족하기 어렵다.
- 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션 기능으로 이 클래스를 사용하는 곳도 전혀 없다.

> 자바 가상 머신은 이 세가지 조건에 부합하는 클래스를 회수하도록 허용한다. but, 반드시 회수하지 않는다.

## 가비지 컬렉션 알고리즘

- 참조 카운팅 GC : 직접 가비지 컬렉션
- 추적 GC : 간접 가비지 컬렉션

## 세대 단위 컬렉션 이론

현재 사용 가상 머신들이 채택한 가비지 컬렉터는 대부분 세대 단위 컬렉션 이론에 기초해 설계되었다.
기본적으로 다음 두가지 가정이 뿌리를 이룬다.

1. 약한 세대 가설 : 대다수 객체는 일찍 죽는다.
2. 강한 세대 가설 : 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.

자바 힙을 몇 개의 영역으로 나누고 객체들을 나이에 따라 각기 다른 영역에 할당한다. 여기서 나이란,
GC에서 살아남은 횟수를 말한다.
확실히 적은 비용으로 대량의 메모리를 확보시킬 수 있다. 한번 살아남은 객체들은 통계적으로 잘 죽지 않으니,
다른 영역에 모아두고, 가상 머신이 그 영역을 회수하는 빈도를 줄인다.
이렇게 하면 가비지 컬렉션에 드는 전체 시간도 줄고 메모리 공간도 효율적으로 이용 가능하다.
GC는 하나 또는 몇 개의 영역만 선택하여 회수할 수 있는데, 이를 기준으로 마이너 GC, 메이저 GC, 전체 GC
라고 부르곤 한다. 객체들의 생존 특성에 따라 마크-스윕(mark-sweep : 표시 후 쓸기), 마크-카피(mark-copy: 표시 후 복사), 마크-컴팩트(mark-compact: 표시 후 모으기) 등의 가비지 컬렉션 알고리즘을 구분해 적용한다.

세대 단위 컬렉션 이론을 가상 머신에 적용한 설계자들은 자바 힙을 최소 두개 영역으로 나눈다. 바로 신세대와 구세대이다. 신세대에서 GC 때마다 다수의 객체가 죽고 살아남은 소수만 구세대로 승격된다.

3. 세대 간 참조 가설 : 세대 간 참조 개수는 같은 세대 안에서의 참조보다 훨씬 적다.상호 참조 관계의 두 객체는
   삶과 죽음을 함꼐하는 경향이 있다. ex) 구세대 객체가 신세대 객체를 참조하고 있다면 신세대 객체도 구세대로 승격될 것이다. 세대 간 참조는 자연스럽게 사라진다.

### 세대 단위 컬렉션에서의 다양한 GC 방식

- 부분 GC : 자바 힙의 일부만 회수하는 가비지 컬렉션을 말함
  - 마이너 GC(신세대 GC) : 신세대만 대상으로 하는 가비지 컬렉션
  - 메이저 GC : 구세대만 대상으로 하는 가비지 컬렉션
  - 혼합 GC : 신세대 전체와 구세대 일부를 대상으로 하는 가비지 컬렉션 - G1 컬렉터만 이렇게 동작
- 전체 GC : 자바 힙 전체와 메서드 영역까지 모두를 대상으로 하는 가비지 컬렉션

## 마크-스윕 알고리즘

## 마크-카피 알고리즘

## 마크-컴팩트 알고리즘

## 핫스팟 알고리즘 상세 구현

### 루트 노드 열거

루트 노드 열거란 도달 가능성 분석 알고리즘에서 GC 루트 집합으로 부터 참조 체인을 찾는 작업을 말한다.
GC 루트로 고정할 수 있는 노드는 주로 전역 참조(상수와 클래스 정적 속성 등)과 실행 콘텍스트(스택 프레임의 지역변수 테이블)에 존재한다.

지금까지 모든 컬렉터는 루트 노드 열거 단계에서 일시 정지 했어야 한다. stop the world 문제를 필 수 없다는 이야기다. 다행히도 사용자 스레드와 동시에 실행할 수 있다. 하지만 루트 노드 열거만큼은 반드시 일관성이 보장된 스냅숏 상태에서 수행해야 한다. 이것이 가비지 컬렉션 시 모든 사용자 스레드가 일시 정지해야 하는 이유이다. 심지어 일시 정지 기간을 제어할 수 있거나 거의 정지 하지 않는 CMS, G1, ZGC 같은 컬렉터들도 루트 노드를 열거할 때 만큼은 일시정지를 피할 수 없다.

현재 주류 자바 가상 머신들은 '정확한 가비지 컬렉션'을 사용. 그래서 사용자가 스레드를 정지한 후 실행 콘텍스트와 전역 참조의 위치를 빠짐없이 확인할 필요가 없다.

핫스팟은 OopMap이라는 데이터 구조를 이용해 문제를 해결.

1. 클래스 로딩이 완료되면 객체에 포함된 각 데이터의 타입을 확인.
2. 그리고 JIT 컴파일 과정에서 스택의 어느 위치와 어느 레지스터의 데이터가 참조인지 기록
3. 이런 식으로 컬렉터는 메서드 영역과 다른 GC 루트들로 부터 시작하여 추적해 보지 않고도 스캔 과정에서 이 정보를 직접 얻어낸다.

### 안전 지점

- 핫스팟은 OopMap을 활용해 GC 루트들을 빠르고 정확하게 열거
- 참조 관계나 OopMap의 내용을 변경할 수 있는 명령어가 많다.
- 이런 명령어 모두에 OopMap에 넣으면 메모리를 더 많이 사용해야 한다.
- 실제로 가비지 컬렉션에 드는 공간 비용을 감당하기 어려울 만큼 커진다.
- 그래서 핫스팟은 모든 명령어에 각각에 OopMap을 생성하지 않는다.
- 그 대신 안전 지점(Safe point)이라고 하는 특정한 위치에만 기록한다.
- GC는 사용자 프로그램이 안전 지점에 도달할 때까지는 절대 멈춰 세우지 않는다.
- 안전 지점을 너무 적게 설정해서 컬렉터를 너무 오래 기다리게 하거나, 너무 많이 설정해서 런타임 메모리 부하가 지나치게 커지지 않도록 주의해야 한다.

### 안전 지점 고려해야할 문제

- GC가 시작되면 JNI 호출을 실행중인 스레드 외에 모든 스레드가 가장 가까운 안전 지점까지 실행하고 멈추게 해야 한다.

### 선제적 멈춤 방식

- 스레드의 코드가 가비지 컬렉터를 신경 쓰지 않는다.
- GC가 실행되면 시스템이 모든 사용자 스레드를 인터럽트.
- 사용자 스레드가 중단된 위치가 안전 지점이 아니라면 스레드 재개, 인터럽트, 재개 반복
- 해당 방법을 사용하는 가상 머신은 거의 없다.

### 자발적 멈춤 방식

- GC가 스레드 수행에 직접 관여하지 않음.
- 간단히 플래그 비트를 설정하고, 실행 중에 플래그를 적극적으로 폴링.
- 그러다가 플래그 값이 true면 가장 가까운 안전 지점에서 스스로 멈춘다.
- 객체 생성 등 자바 힙 메모리를 소비하는 장소에도 폴링 플래그가 추가된다.
- 메모리가 부족해 새로운 객체를 할당하지 못하는 일을 예방하기 위해 적절한 시점에 GC를 수행하기 위함이다.
- 폴링은 코드에서 자주 일어나므로 매우 효율적이어야 한다.
- 핫스팟은 메모리 보호 트랩이라는 방법을 써서 폴링을 어셉블리어 명령어 하나만으로 수행할 수 있도록 단순화 했다.
- test 명령어가 핫스팟이 생성한 폴링 명령어이다.

## 안전 지역
