# GC와 메모리 할당을 왜 이해해야 하는가?
메모리 할당과 GC 기술이 상당히 성숙했음에도 불구하고, 그 동작 방식을 이해하고 있다면 실무에서 겪을 수 있는 문제를 해결하는 데 도움이 될 수 있다.
- GC의 Stop-the-World 지연 시간을 단축
- 메모리 누수 해결
- 메모리가 부족한 상황에서 WeakReference를 사용한 캐시 삭제

# 객체 생존 판단 알고리즘
메모리 회수 대상인지 여부를 판단하는 알고리즘 (실제 회수 동작은 별개)

## 참조 카운팅 알고리즘
1. 객체를 가리키는 참조 카운터(reference counter)를 추가
2. 참조하는 곳이 하나 늘어날 때마다 카운터 값을 1씩 증가
3. 참조하는 곳이 하나 사라질 때마다 카운터 값을 1씩 감소
4. 카운터 값이 0이 된 객체는 더 이상 사용되지 않는다고 판단

그러나 JVM에서는 참조 카운팅을 쓰지 않는다. 예컨대 순환 참조 문제는 참조 카운팅 만으로는 풀기 어렵다.

```java
ReferenceCountingGC objA = new ReferenceCountingGC();
ReferenceCountingGC objB = new ReferenceCountingGC();

objA.instance = objB;
objB.instance = objA;

objA = null;
objB = null;

System.gc();
```
참조 카운팅으로는 위 케이스의 메모리를 회수할 수 없으나, 위 코드는 실제로 메모리가 회수된다. 즉, JVM은 객체 생존 판단에 참조 카운팅을 사용하지 않는다.

## 도달 가능성 분석(rechability analysis) 알고리즘
GC 루트 객체들로부터 출발해서, 참조하는 다른 객체들을 탐색하여 참조 체인(reference chain)을 만든다. 그리고 참조 체인에 포함되지 않는 객체, 즉 GC 루트로부터 도달할 수 없는 객체는 더 이상 사용할 수 없는 객체이므로 회수 대상이 된다.

### GC 루트로 이용할 수 있는 객체
- 가상 머신 스택에서 참조하는 객체 : 현재 실행중인 메서드에서 쓰는 매개변수, 지역 변수, 임시 변수 등
- 메서드 영역에서 클래스가 static 필드로 참조하는 객체 : 자바 클래스의 참조 타입 static 변수
- 메서드 영역에서 상수로 참조되는 객체 : 문자열 테이블(string pool?) 안의 참조
- 네이티브 메서드 스택에서 JNI가 참조하는 객체
- JVM 내부에서 쓰이는 참조 : 기본 데이터 타입에 해당하는 Class 객체, NPE 등의 일부 상주 예외 객체, 시스템 클래스 로더
- 동기화 락(synchronized)으로 잠겨있는 객체
- JVM 내부 상황을 반영하는 JMXBean : JVMTI에 등록된 콜백, 로컬 코드 캐시 등
- 그 밖에 GC 종류나 현재 회수 중인 메모리 영역에 따라 다른 객체들도 임시로 추가 가능

## 참조의 4가지 종류
- 강한 참조 (strong reference) : 프로그램 코드에서 참조. GC가 절대 회수하지 않는다.
- 부드러운 참조 (soft reference) : 유용하지만 필수는 아닌 객체. 메모리 오버플로우 직전에 두 번째 회수를 위한 회수 목록에 추가되고, 두 번째 회수 후에도 메모리가 부족하면 메모리 오버플로우 예외를 던진다.
- 약한 참조 (weak reference) : 부드러운 참조보다 연결 강도가 더 약한 경우. 다음번 GC까지만 살아있고, GC가 시작되면 모두 회수된다.
- 유령 참조 (phantom reference) : 가장 약한 참조. 객체 수명에 아무 영향을 주지 않으며, 유령 참조를 통해서 객체 인스턴스를 가져올 수도 없다. 객체가 회수될 때 알림을 받기 위한 용도로 쓰인다.

## 생존 판단 과정
1. GC 루트와 연결된 참조 체인을 찾지 못한 객체에는 '1차 마킹(initial marking)'를 한다.
2. finalize()를 실행해야 하는 객체인지를 판단한다.
3. finalize()를 실행해야 하는 객체라면, F-Queue 대기열에 추가한다.
4. JVM은 우선순위가 낮은 finalizer 스레드를 생성해서, F-Queue에 담긴 객체들의 finalize()를 실행한다.
5. 이 때, 부활시키고자 하는 객체는 참조 체인 상의 아무 객체와 연결을 해준다.
6. finalize() 메서드를 호출한 객체들이 새로운 참조를 생성했는지 확인하고, 부활한 객체(새로운 참조를 생성한 객체)에 '2차 마킹(remarking)'을 한다.
7. 마킹되지 않은 객체들을 최종적으로 가비지로 판단한다.

그러나 finalize()를 사용한 부활은 사용하지 않는 것이 권장된다. 실행하는 비용도 높고, 불확실성도 크며, 어느 객체부터 호출되는지도 보장되지 않아서, finzalize()는 JDK 9부터 deprecated 되었다. finalize()로 할 수 있는 일은 try-finally 등의 방법으로 더 잘 처리할 수 있다.



# 가비지 컬렉션 알고리즘

## 세대 단위 컬렉션 이론
현재 상용 JVM들이 사용하는 GC는 대부분 세대 단위 컬렉션 이론에 기초해 만들어졌다. 
1. 약한 세대 가설(weak generational hypothesis) : 대다수 객체는 일찍 죽는다.
2. 강한 세대 가설(strong generational hypothesis) : GC 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.

이 2가지 가정을 기반으로, 자바 힙을 여러 영역으로 나누고, 객체들을 나이에 따라 다른 영역에 할당한다. 영역 안의 객체 대부분이 곧바로 죽을 운명이라면 (약한 세대 가설), 객체들을 한 곳에 모아놓고 (곧 회수될 다수의 객체에 일일이 표시하는 대신) 살아남는 소수의 객체를 관리하는 것이 유리하다. 또한 한번 살아남은 객체는 다시 잘 죽지 않으니, 다른 영역에 따로 모아두고 이 영역은 회수 빈도를 줄인다.

신세대(young generation)에서는 다수의 객체가 죽고, 살아남은 소수의 객체는 구세대(old generation)로 승격된다. 단, 신세대에서만 GC를 하고 싶더라도, 신세대에 속하지만 구세대에서 참조 중인 객체도 파악하기 위해서는 구세대 객체까지 모두 탐색해야 한다. 그러나 구세대의 모든 객체를 탐색하는 것은 성능적으로 부담스러우므로, 3번째 경험 법칙이 추가된다.

3. 세대간 참조 가설 (intergenerational reference hypothesis) : 세대간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.

이 가설에 따르면 세대간 참조의 개수는 아주 적기 때문에, 구세대 전체를 훑는 것은 비효율적이다. 그 대신, 신세대에 기억 집합이라는 전역 데이터 구조를 두고, 구세대를 몇 개의 조각으로 나누어서, 그 중 어느 조각에 세대간 참조가 있는지를 기록해서 관리한다. 그리고 마이너 GC를 수행할 때, 세대간 참조를 포함하는 조각 안의 객체들만 GC 루트에 추가하면, 구세대 전체를 탐색하는 낭비를 줄일 수 있다.

## 마크-스윕 알고리즘
다른 GC 알고리즘의 기본 뼈대가 되는 알고리즘이다. 회수할 객체들에 모두 표시(mark)하고, 표시된 객체들을 쓸어 담는(sweep) 2단계로 수행된다.
이 방식에는 2가지 단점이 있다.
1. 실행 효율이 일정하지 않다. 자바 힙이 대량의 객체로 차있고, 그 대부분이 회수 대상이라면, 표시와 회수 작업 모두 비용이 크다.
2. 메모리 파편화가 심하다. GC가 쓸고 지나간 자리에는 불연속적인 메모리 파편이 만들어진다. 파편화가 심하면 큰 객체를 만들 때 충분한 크기의 연속된 메모리를 찾기 어려워지고, 그 결과 또다른 GC를 유발한다.

## 마크-카피 알고리즘
메모리를 같은 크기의 두 블록으로 나눠서, 한번에 한 블록만 사용한다. 한쪽 블록이 꽉 차면 살아남은 객체들만 다른 블록에 복사하고, 기존 블록을 한번에 청소한다.
이 알고리즘은 대다수 객체가 생존하는 경우 메모리 복사가 오래 걸린다는 단점이 있다. 반대로 대다수가 회수된다면 생존한 소수의 개체만 복사하면 된다. 그리고 복사하는 과정에서 객체들이 메모리에 차곡차곡 쌓이기 때문에 파편화 문제를 해결할 수 있다.
그러나 가용 메모리를 절반으로 줄이기 때문에, 메모리 낭비가 심하다는 단점이 있다. 오늘날 상용 JVM 대부분은 신세대에 이 알고리즘을 활용한다.

## 아펠 스타일 컬렉션
시리얼, 파뉴 같은 핫스팟 가상 머신의 신세대에 적용된 전략이다.
신세대를 하나의 큰 에덴 공간(80%)과 두개의 작은 생존자 공간(각 10%)으로 나눈다 그리고 메모리를 할당할 때는 생존자 공간 중 하나와 에덴만 사용한다. GC가 시작되면, 에덴과 생존자 공간에서 살아남은 객체들을 나머지 생존자 공간으로 복사한 후, 에덴과 기존 생존자 공간을 비운다.
낮은 확률이지만 객체가 10% 넘게 살아남는 경우를 대비하기 위해, 메모리 할당 보증 메커니즘을 사용한다. 마이너 GC에서 살아남은 객체를 생존자 공간에 다 넣을 수 없는 경우, 다른 메모리 영역(보통 구세대)을 사용한다.

## 마크-컴팩트 알고리즘
마크-카피 알고리즘은 객체 생존율이 높을수록 복사할 양이 많아지므로 효율이 나쁘다. 따라서 구세대에는 적합하지 않다.
표시 단계는 마크-스윕과 마찬가지로 진행하고, 컴팩트 단계에서 생존한 모든 객체를 메모리 영역의 한쪽 끝으로 모은(compact) 다음, 나머지 공간을 한꺼번에 비운다.


# 클래식 가비지 컬렉터

JDK 7 업데이트 4 ~ JDK 11 공식 릴리즈까지, 오라클JDK의 핫스팟 가상 머신에 포함된 GC들이 여기에 해당한다.

## 시리얼 컬렉터
가장 기초적이고 오래된 컬렉터로, 단일 스레드로 동작한다. 따라서 회수가 완료될 때까지 stop-the-world가 발생한다.

## 파뉴 컬렉터
시리얼 컬렉터를 병렬화한 버전이다. 스레드 회수 단계에서 멀티 스레드를 이용한다는 점이 유일한 차이점이다. JDK 7 전까지는, CMS 컬렉터와 조합할 수 있는 (시리얼 컬렉터를 제외한) 유일한 컬렉터였기 때문에, 신세대용 컬렉터로 인기가 높았다.

## CMS 컬렉터
GC 스레드와 사용자 스레드가 동시에 실행되는, 동시성을 지원하는 최초의 가비지 컬렉터다. JDK 5에서 구세대에 CMS를 사용하려면, 신세대용은 파뉴와 시리얼 중 하나를 선택할 수밖에 없었다.

