# 3. 가비지 컬렉터와 메모리 할당 전략 part 2

## 5. 클래식 가비지 컬렉터

‘클래식’은 컬렉터들의 범위를 말하며, 고성능-저지연 컬렉터들과 구분하기 위해 클래식이란 수식어를 씀.

![part2-1.png](/image/part2-1.png)

### 5.1 시리얼(Serial) 컬렉터

가장 기초적이고 오래된 컬렉터, JDK 1.3.1 전까진 유일한 선택지였음. **단일 스레드**로 동작하며 가비지 컬렉션을 단순히 하나의 GC 스레드가 모두 처리한다는 의미만 있진 않고, 중요한건 ‘회수가 완료될 때까지 다른 스레드가 멈춰야 한다’는 점이다.

![part2-2.png](/image/part2-2.png)

### 5.2 파뉴(ParNew) 컬렉터

여러 스레드를 활용하여 시리얼 컬렉터를 병렬화함, 스레드 회수에 멀티스레드를 이용한다점 외엔 시리얼 컬렉터와 동일하다. 단일 코어 프로세서에선 시리얼 컬렉터보다 성능이 낮다.

![part2-3.png](/image/part2-3.png)

CMS + 파뉴 조합으로 같이 사용했던적도 있지만, G1이 나오면서 대체 됨.

### 5.3 패러럴 스캐빈지(Parallel scavenge) 컬렉터

PS 컬렉터로 불리며, 마크-카피 알고리즘에 기초하며 여러 스레드를 이용해 병렬로 회수하는 등, 많은 면에서 파뉴 컬렉터와 닮았지만 다른 특징은 처리량(프로세서가 사용자 코드를 실행하는데 사용한 시간과 프로세서가 소비하는 총 시간의 비율)을 제어하는 게 목표다.

![part2-4.png](/image/part2-4.png)

### 5.4 시리얼 올드(Serial old) 컬렉터

시리얼 컬렉터의 구세대용 버전으로 단일 스레드이며 마크-컴팩트 알고리즘을 쓴다.

![part2-5.png](/image/part2-5.png)

### 5.5 패러렐 올드(Parallel old) 컬렉터

PS 컬렉터의 구세대용 버전으로 멀티스레드를 이용한 병렬 회수를 지원하며 마크-컴팩트 알고리즘을 기초로 구현했다.

![part2-6.png](/image/part2-6.png)

### 5.6 CMS 컬렉터

표시와 쓸기 단계 모두를 사용자 스레드와 동시에 수행함. 목적은 가비지 컬렉션에 따른 일시 정지 시간을 최소로 줄이는 것으로 마크-스윕 알고리즘을 기초로 구현했다.

1. 최초 표시 : GC 루트와 직접 연결된 객체들만 표시해서 아주 빠름
2. 동시 표시 : GC 루트와 직접 연결된 객체들부터 객체 그래프 전체 탐색, 오래 걸리지만 사용자 스레드를 멈추진 않음, 동시 실행
3. 재표시 : 동시 표시 중 사용자 스레드가 참조 관계를 변경한 경우를 수정
4. 동시 쓸기 : 위 세 단계에서 죽었다고 판단한 객체들을 쓸어 담고, 사용자 스레드를 멈추지 않음

중요한 특성은 전체 과정 중 가장 긴 동시 표시와 동시 쓸기에서 사용자 스레드를 멈추지 않는다는 것으로 동시에 수행할 수 있다는 점이다. 하지만 단점도 명백하다.

1. CMS는 프로세서 자원에 아주 민감함. 동시성을 위해 설계된 프로그램은 모두 프로세서에 민감하지만, 동시에 수행할 경우 애플리케이션이 느려지고 전체 처리량이 떨어지는건 어쩔 수 없다. GC도 결국 프로세서의 리소스를 나눠서 쓰는 것이기 때문이다.
2. 부유 쓰레기(floating garbage)를 처리하지 못해 동시 모드 실패를 유발할 가능성이 있다는 것. 만약 동시 모드가 실패하면 전체 GC를해야한다. 동시에 GC와 사용자 스레드가 실행되기 때문에 실행 중일 때 새로운 쓰레기가 자연스레 생기고 당연히 GC 이후에 발생한 쓰레기가 생긴다.
3. 마크-스윕 알고리즘을 사용해서, 회수 후 파편화가 일어나고 심하면 큰 객체를 할당할 때 문제가 발생하게 된다. 연속된 공간을 할당하지 못할 수 있다. 그러면 전체 GC를 수행해야 한다. JDK14에서 제거됨

### 5.7 G1(garbage first) 컬렉터

가비지 우선 컬렉터로 ‘**부분 회수(partial collection)**’라는 설계 아이디어와 리전(region)을 회수 단위로 하는 메모리 레이아웃을 개척했다. JDK8 이후 오라클은 ‘완전한 기능을 갖춘 가비지 컬렉터(fully-featured garbage collector)’라 부른다.

서버용 애플리케이션에 집중한 컬렉터로 CMS를 대체했다. JDK9부터 서버용 기본 컬렉터가 됐다. 하지만 이전 컬렉터들과 핫스팟의 서비시스템(메모리 관리, 실행, 컴파일, 모니터링 등)이 복잡하게 얽혀 있었고, 관심사의 분리(separation of concerns) 설계 원칙이 제대로 지켜지지 못했다는 것으로, JDK10에서 핫스팟 가상 머신에 ‘**통합 가비지 컬렉터 인터페이스**’를 도입하여 가비지 컬렉터의 행위와 구현을 분리했다. 그리고 다른 컬렉터들을 이 인터페이스에 맞게 재구성해서 다른 컬렉터를 제거하거나 새로 추가하기가 쉬워졌다.

CMS의 대체제이자 후계자를 목표로 **정지 시간 예측 모델**(pause prediction model)을 만들고자 했고 목표 시간을 M밀리초로 설정하면 GC 시간이 M밀리초가 넘지 않게 통제하는 것이다. 이 목표를 위해 영역 기반 힙 메모리 레이아웃을 도입했고, 힙 메모리의 어느곳이든 회수 대상에 포함하고 회수 집합(collection set, CSet)이라고 한다. 어느 세대에 속하느냐 → 어느 영역에 쓰레기가 많은지, 회수를 했을 때 이득볼 수 있는 곳으로 GC 기준이 변경됐다. 이게 G1의 혼합 GC 모드다.

영역 기반 힙 메모리 레이아웃이 **정지 시간 예측 모델**이라는 목표를 이루는 열쇠로 G1도 여전히 세대 단위 컬렉션 이론에 기초하고 있지만 다른 컬렉터와 달리 연속된 자바 힙을 동일 크기의 여러 리전으로 나눈다.

그리고 큰 객체를 저장하기 위해 거대 리전(humongous region)이라는 유형도 활용한다.

![part2-7.png](/image/part2-7.png)

G1은 여전히 신/구 세대 개념을 사용하지만 고정되어 있지 않고, 리전별 역할을 동적으로 바꾸고 리전이 이어서 배치될 필요도 없다. **정지 시간 예측 모델**이 가능한 이유는 리전을 최소 회수 단위로 사용하기 때문에 매번 적절한 수의 리전을 계획적으로 회수하는 식으로 자바 힙 전체를 회수하는 상황을 피할 수 있다.

각 리전의 쓰레기 누적 **값**(GC으로 회수할 수 있는 공간의 크기와 회수에 드는 시간의 경험값)을 추적한다. 그리고 일시 정지 시간(`MaxGCPauseMillis`, 기본 200밀리초)이 허용하는 한도 내에서 회수 효과가 가장 큰 리전부터 회수한다. 이게 ‘가비지 우선’ 이라는 이름이 나온 이유다. **메모리 공간을 리전 단위로 분할해 우선순위대로 회수함으로써 제한된 시간 내에 가장 효율적으로 회수**할 수 있는 것이다.

‘힙 메모리를 리전 단위로 나눈다’ 는 전략은 구현하기 쉽지 않았다. 현실적으로 해결해야 했던 주된 문제 몇가지다.

1. 자바 힙을 다수의 독립된 리전으로 나누면 객체들의 리전 간 참조 문제를 해결해야함 → 기억 집합을 도입하여 GC루트부터 힙 전체를 스캔하는 일을 피하는 것이다. 하지만 기억 집합을 G1에 응용하기는 훨씬 복잡하다. 모든 리전이 각자의 기억 집합을 관리하며 기억 집합에는 다른 리전으로부터의 모든 참조 정보를 기록하고 이 참조가 어떤 카드 페이지에 속하는지 표기한다. G1의 기억집합은 기본적으로 **해시테이블** 구조로 **키**는 다른 리전으로부터의 시작 주소이고, **값**은 하나의 집합이다. 값에 저장된 원소들은 카드 테이블의 인덱스 번호다. ‘내가 가리키는 대상’과 ‘나를 가리키는 대상’ 을 모두 기록하는 양방향 카드 테이블 구조가 되다 보니 기본적인 카드 테이블 구조보다 훨씬 복잡하다. 그리고 리전 개수도 훨씬 많기 때문에 세대의 수도 많다. 그래서 메모리 사용량이 더 많다.
2. 동시 표시 단계 동안 GC스레드와 사용자 스레드가 서로 간섭하지 않도록 보장해야 한다. 가장 먼저 해결할 문제는 사용자 스레드가 객체 참조 관계를 수정해도 원래의 객체 그래프 구조를 파괴하지 않도록 보장하는 일이다. 시작 단계 스냅숏 알고리즘을 선택했다. 또 GC는 사용자 스레드가 만드는 새로운 객체를 위한 메모리 할당에도 영향을 준다. 프로그램이 멈추지 않고 계속 수행된다면 새로운 객체가 계속 만들어질 것이고 각 리전을 위해 TAMS라는 두 개의 포인터를 설계했다. 리전의 일부가 동시 회수 프로세스 동안 새로운 객체를 할당받기 위한 공간으로 나뉘고 동시 회수 동안 새로 생성되는 객체의 주소는 반드시 이 두 포인터보다 높은 주소영역에 할당되어야 한다. 암묵적으로 이 주소보다 높이 있는 객체는 표시된 것으로 간주하여 회수 대상에서 제외함.
3. 신뢰할 수 있는 **정지 시간 예측 모델**을 구현해야 함. 이론적 기초는 감소 평균(decaying average)이다. 가비지 컬렉션이 이뤄지는 동안 G1은 리전별 회수 시간, 리전별 기억 집합에서 더럽혀진 카드 개수 등 측정할 수 있는 각 단계의 소요 시간을 기록하고 평균, 표준 편차, 신뢰도 같은 통계를 분석한다.

사용자 스레드가 실행되는 동안 수행하는 작업(기억 집합을 관리하기 위해 쓰기 장벽을 사용하는 동작 등)을 제외하면 G1의 동작은 네 단계로 나뉜다.

1. 최초 표시 : GC 루트가 직접 참조하는 객체들을 표시하고 TAMS 포인터의 값을 수정한다. 시작 단계 스냅숏을 생성한다. 사용자 스레드와 동시에 수행되는 다음 단계에서 새로운 객체들이 가용 리전에 올바르게 할당하기 위한 조치다. 이때 최초 표시 단계에서 사용자 스레드가 정지해야 하는데, 매우 짧고 마이너 GC가 실행되는 틈에 끝나서 추가로 일으키는 일시 정지는 거의 없다.
2. 동시 표시 : GC 루트로부터 시작해 객체들의 도달 가능성을 분석하고, 전체 힙의 객체 그래프를 재귀적으로 스캔하며 회수할 객체를 찾는다. 이 단계는 시간이 걸리지만 사용자 스레드와 동시에 수행된다. 스캔이 끝난 후 시작 단계 스냅숏과 비교해 동시 실행 도중 참조가 변경된 객체들을 다시 스캔한다.
3. 재표시 : 시작 단계 스냅숏 이후 변경된 소수의 객체만 재표시하는 단계로 사용자 스레드를 멈춘다.
4. 복사 및 청소 : 통계 데이터를 기초로 리전들을 회수 가치와 비용에 따라 줄 세운 다음 목표한 일시 정지 시간에 부합하도록 회수 계획을 세움, 회수할 리전들을 적절히 선별하고 리전들 사이에서 살아남은 객체들을 빈 리전에 이주시킴, 생존한 객체를 이동시켜야 하므로 사용자 스레드가 잠시 멈춘다. 하지만 다수의 GC스레드가 병렬로 처리한다.

위 설명과 같이 동시 표시 단계를 제외한 나머지는 사용자 스레드를 멈춰야 한다. 단순 짧은 지연 시간만 추구하는게 아닌, 처리량도 최대한 높이는 것이다.

```
It meets garbage collection pause time goals with a high probability, while achieving high throughput
(높은 처리량을 달성하면서 동시에 높은 확률로 가비지 컬렉션 일시 정지 시간 목표도 충족한다)."
```

애플리케이션이 쓰레기를 버리고 컬렉터는 청소를 한다. 객체가 버려지는 속도를 컬렉터가 따라간다면 모든 것이 완벽하게 동작하는 모델로 이걸 실제로 구현한게 G1이다.

### 5.8 모던 가비지 컬렉터들

모던 자바에서 선택지는 몇 없다.

![part2-8.png](/image/part2-8.png)

## 6. 저지연 가비지 컬렉터

가비지 컬렉터를 측정하는 가장 중요한 지표 세 가지가 모여 ‘불가능의 삼각 정리(impossible trinity)’를 만든다.

- 처리량 throughput
- 지연 시간 latency
- 메모리 사용량 footprint

![part2-9.png](/image/part2-9.png)


셰넌도어와 ZGC는 거의 모든 과정이 동시에 수행된다. 최초 표시와 최종 표시에서만 일시 정지가 짧게 일어나며 이 부분의 시간은 거의 고정적이다. 힙 크기와 객체 수가 늘어난다고 해서 더 길어지지 않는다. 관리 가능한 힙 용량 이내라면 가비지 컬렉션으로 인한 일시 정지는 10밀리초를 넘지 않는다. 그래서 두 컬렉터를 ‘저지연 가비지 컬렉터’라 한다.

### 6.1 셰넌도어 Shenandoah

오라클이 주도 개발하지 않은 첫 핫스팟 GC로 지원 목록에서 빠져 있다. 레드햇이 독립적으로 시작한 프로젝트로 목표는 힙 크기와 상관없이 가비지 컬렉션 시간을 10밀리초 이내로 하는 것으로 표시 단계, 객체 회수 후 마무리까지 사용자 스레드와 동시에 수행한다. G1과 힙 레이아웃이 비슷하며 최초 표시, 동시 표시등 여러 단계의 처리 방식도 비슷하다. G1과의 큰 차이점 세가지다.

1. 동시 모으기 지원 : 여러 스레드를 이용해 모으기 단계를 병렬로 처리하지만 사용자 스레드와 동시에 수행할 순 없다.
2. 세대 단위 컬렉션 미사용 : 신/구 세대 리전을 구별하지 않는다.
3. 연결 행렬 : 메모리와 컴퓨팅 자원을 많이 사용하는 기억 집합 대신 연결 행렬(connection matrix)로 리전 간 참조 관계를 기록한다. 덕분에 관리 비용 감소, 거짓 공유 문제 발생률 감소함.

![part2-10.png](/image/part2-10.png)


### 동작 방식

1. 최초 표시 : 가장 먼저 GC루트에서 직접 참조하는 객체들에 표시, 짧지만 일시 정지
2. **동시 표시** : 객체 그래프를 타고 힙을 탐색, 도달 가능한 객체를 표시, 사용자 스레드와 동시 수행
3. 최종 표시 : 보류 중인 표시를 완료하고 GC루트 집합을 다시 스캔, 회수 가치가 큰 리전들을 추려 회수 집합 생성, 짧지만 일시 정지
4. 동시 청소 : 살아있는 객체가 없는 리전들 청소
5. **동시 이주** : 핵심 차이 → 회수 집합 안에 살아있는 객체들을 다른 리전으로 복사, 사용자 스레드와 동시에 수행하면서 객체의 참조가 바뀌면 포인터를 바꿔줘야 하기때문에 읽기 장벽과 포워딩 포인터를 사용
6. 최초 참조 갱신 : 동시 이주 단계에서 복사한 객체의 참조를 새로운 주소로 수정해야 함(참조 갱신), 짧지만 일시 정지
7. **동시 참조 갱신** : 참조 갱신을 실제로 시작하며 사용자 스레드와 동시 수행, 수행 시간은 메모리에 존재하는 참조의 수에 따름, 동시 표시와 다르게 물리 메모리 주소의 순서대로 참조 타입을 선형 검색하여 수정
8. 최종 참조 갱신 : 힙의 참조를 다 갱신하면 GC 루트 집합의 참조도 갱신한다. 마지막 일시 정지
9. 동시 청소 : 이주와 참조 갱신 뒤 회수 집합의 모든 리전에 살아 남은 객체가 더 없게 된다. 그래서 동시 청소를 다시 수행해 새로운 객체를 할당할 공간을 확보함

![part2-11.png](/image/part2-11.png)


### 동시 이주의 핵심, 포워딩 포인터

포워딩 포인터(간적 포인터)는 객체 이동에서 사용자 스레드와 동시에 수행하기 위해, 기존의 메모리 보호 트랩 방식이 아닌 새로운 해법으로 객체 레이아웃 구조 상단에 참조 필드를 추가하고 동시 이주가 아닌 경우 객체 자신을 가리키게 했다. 객체가 이동할 경우 새로운 객체로 참조 필드를 수정하면 된다.

여기서 사용자 스레드와 GC 스레드가 동시에 쓰려고 하면 동시성 문제가 발생하며 이를 해결하기 위해 `CAS(Compare-And-Swap)` 기법을 써서 동시 이주 중에도 객체 접근에 문제가 없도록 했다.

- `CAS(Compare-And-Swap)` : 현재값과 변경할값을 비교 후 조건이 맞으면 변경하는 방식

## 6.2 ZGC

오라클이 개발한 저지연 가비지 컬렉터로 JDK11에서 실험 버전, 15에서 정식 버전으로 추가됨, 21 버전에서 신세대와 구세대를 구분해 처리하는 세대 구분 ZGC가 추가되었다. 세대 비구분/구분으로 나눠 설명함.

셰넌도어와 목표가 흡사하다. 처리량에 미치는 영향을 최소로 억제하고 힙 크기에 상관없이 가비지 컬렉션으로 인한 정지 시간을 10밀리초 안쪽으로 줄이고자 한다. 하지만 구현 방향이 다름

> ZGC는 세대 구분 없이 리전 기반 메모리 레이아웃을 사용한다. 낮은 지연 시간을 최우선 목표로 하며 동시 마크-컴팩트 알고리즘을 구현하기 위해 읽기 장벽, 컬러 포인터, 메모리 다중 매핑 기술을 이용한 가비지 컬렉터다.
>

### 리전 기반 메모리 레이아웃

셰넌도어와 G1처럼 힙 메모리를 리전들로 나누지만 차이가 있는데, 동적으로 생성/파괴된다. (리전을 Page 혹은 ZPage라고 함) 또한 크기도 동적으로 달라진다.

- 소 small : 2MB 고정, 256KB 미만의 작은 객체를 담음
- 중 medium : 32MB 고정, 256KB 이상 ~ 4MB 미만 객체를 담음
- 대 large : N x 2MB, 크기가 동적으로 변하지만 2MB의 배수임, 4MB 이상의 큰 객체용 공간으로 단 하나의 객체만 담는다. 그래서 실제로는 미디움 리전보다 작은 객체가 담길수도 있다. 최소 크기는 4MB 며, 큰 객체를 복사하는 비용이 비싸기 때문에 재할당을 하지 않는다.

ZGC의 핵심인 병렬 모으기 알고리즘을 보자.

먼저 ZGC를 상징하는 설계는 컬러 포인터(태그 포인터 또는 버전 포인터)다. GC 나 VM 자체에서만 이용하는 추가 데이터를 저장하고 싶을 때 ZGC 이전엔 객체 헤더에 필드를 추가했지만 객체가 이동할 수 있는 환경이라면 문제가 되기 때문에 ZGC의 컬러 포인터는 객체를 가리키는 포인터에 직접 표시했다.

**컬러 포인터**는 **포인터 자체에 소량의 추가 정보를 직접 저장**하는 기술이다.

64비트 시스템은 이론상 최대 16EB의 메모리를 이용할 수 있지만, 현실적인 문제를 고려해야한다. 메모리 주소가 크면 주소 변환에 더 큰 페이지 테이블을 써야하고 더 많이 트랜지스터를 집적해야 한다. 그래서 x84-64 아키텍처는 최대 52비트(4PB)의 주소 버스와 48비트(256TB)의 가상 주소 공간만 사용한다. 따라서 최대 메모리는 256TB 이다. 운영 체제도 64비트 리눅스의 프로세스 가상 주소 공간은 47비트(128TB), 물리 주소 공간은 46비트(64TB)다. 64비트 윈도우 시스템은 최대 물리 주소 공간이 44비트(16TB)로 더 적다.

ZGC의 컬러 포인터 기술은 주소 공간을 44비트까지로 제한하고 상위 4비트를 네 가지 플래그 정보를 저장하는 데 이용한다.

![part2-12.png](/image/part2-12.png)

플래그 비트들 때문에 원래 46비트였던 주소 공간이 더 줄어서 관리할 수 있는 메모리는 16TB를 넘지 못한다. 이처럼 컬러 포인터는 메모리 용량이 제한되고, 32비트 플랫폼에서는 동작하지 않고, 압축 포인터 같은 여러 기술을 지원하지 못하지만 장점이 크다. [JEP333](https://openjdk.org/jeps/333)을 보면 이점 세 가지를 설명한다.

- 한 리전 안의 객체들이 이동하면 그 즉시 해당 리전을 재활용할 수 있어 전체 힙에서 해당 리전으로의 참조들을 전부 수정할 때까지 기다릴 필요가 없다.
- 가비지 컬렉션 과정에서 메모리 장벽의 수를 크게 줄일 수 있는데 메모리 장벽, 쓰기 장벽을 설정하는 이유는 객체 참조를 변경하기 위해서다.
- 컬러 포인터를 객체 표시 및 재배치와 관련해 더 많은 정보를 담을 수 있는 확장 가능한 저장 구조로 쓸 수 있다.

![part2-13.png](/image/part2-13.png)

### ZGC의 동작 방식

크게 네 단계로 나누며, 각 단계는 사용자 스레드와 동시에 실행되지만 단계 사이에 작은 일시 정지 단계가 있다.

![part2-14.png](/image/part2-14.png)

1. 동시 표시 : G1과 셰넌도어 처럼 동시 표시는 객체 그래프를 탐색하며 도달 가능성을 분석하는 단계다. 최초 표시 및 최종 표시와 비슷하게 짧은 일시 정지가 발생하지만 다른건 ZGC의 표시는 객체가 아니라 포인터에서 이뤄진다. 컬러 포인터의 `Marked0`, `Marked1` 플래그가 이 표시 단계에서 갱신된다.
2. 동시 재배치 준비 : 청소해야 할 리전들을 선정해 재배치 집합(relocation set)을 만든다. G1의 회수 집합과는 다르게 리전 안의 생존 객체들을 다른 리전으로 복사한 후 리전 자체를 회수할지 여부만 결정한다. 그리고 앞 단계의 표시 대상이 힙 전체이므로 재배치 집합에 표시되지 않은 리전들도 회수 대상이 될 수 있다.
3. 동시 재배치 : 핵심 단계로 재배치 집합 안의 생존 객체들을 새로운 리전으로 복사한다. 재배치 집합에 속한 각 리전의 포워드 테이블에 옛 객체와 새 객체의 이주 관계를 기록한다. 컬러 포인터 덕분에 ZGC는 객체가 재배치 집합에 속하는지 참조만 보고 알 수 있다. 사용자 스레드가 재배치 집합에 포함된 객체에 동시에 접근하려 들면 미리 설정해둔 메모리 장벽이 끼어들어 즉시 해당 리전의 포워드 테이블에 기록된 정보를 보고 새로운 객체로 포워드 한다. 동시에 참조의 값도 새로운 객체를 가리키게 갱신한다. 이를 ‘**자가 치유**’라고 한다. 또한 컬러 포인터 덕분에 재배치 집합에 속한 생존 객체들의 복사가 모두 끝나는 즉시 해당 리전을 재활용 할 수 있다는게 큰 장점이다.
4. 동시 재매핑 : 힙 전체에서 재배치 집합에 있는 옛 객체들을 향하는 참조 전부를 갱신하는 작업으로, 목적은 셰넌도어의 동시 참조 갱신과 같지만 시급히 처리하지 않아도 되는게, **자가 치유** 덕에 최악의 경우여도 처음 접근에만 한 번의 포워딩과 갱신을 거치면 된다.

### 다른 컬렉터들과의 비교

ZGC는 기억 집합을 사용하지 않음, 세대 구분도 없어서(있는 버전이 21에 추가됨) 카드 테이블도 필요 없다. 쓰기 장벽도 사용하지 않아 부담이 적지만 대신 객체 할당 속도를 제한하는 결과로 이어졌다. 이것의 단점은 애플리케이션의 객체 할당 속도가 너무 빨라서 회수 단계에서 다 표시하기 힘들고 대부분 살아남는 다면 많은 쓰레기가 발생한다. 그러면 동시 회수 주기가 길어지고, 회수되는 양보다 쓰레기가 더 많아진다. 결국 여유 공간이 고갈될 것이다.

하지만 장점으론 NUMA 메모리(멀티 코어 프로세서를 탑재한 컴퓨터의 메모리 아키텍처)를 고려한 메모리 할당으로, NUMA 아키텍처가 적용된 환경에서 ZGC는 객체 생성을 요청한 스레드가 수행중인 프로세서의 지역 메모리에 우선적으로 객체를 할당해 메모리 접근 효율을 높인다.

![part2-15.png](/image/part2-15.png)

![part2-16.png](/image/part2-16.png)

![part2-17.png](/image/part2-17.png)

## 6.3 세대 구분 ZGC

ZGC는 확장하여 신/구 세대를 구분하도록 했다. 구분해서 얻는 이점인 수명이 짧은 객체들을 더 자주 회수할 수 있다는 것, 초기에 구현하지 않은 것은 구현 복잡도 때문이었다. JDK21에 정식 추가 됨

사용하려면 VM 옵션에 `-XX:+UseZGC`, `-XX:+ZGenerational` 설정해야 한다.

세대 구분 ZGC도 컬러 포인터와 읽기 장벽을 그대로 계승하며 세대 간 참조를 효율적으로 추적하기 위해 장벽도 활용한다. 컬러 포인터에는 새로운 메타데이터를 추가하고 쓰기 장벽이 이 데이터를 확인해 현재 값이 써지는 필드가 세대 간 참조를 포함하는 지 알 수 있다. 다른 컬렉터에 비해 효율적이다.

### 다중 매핑 메모리 제거

읽기 장벽의 부하를 줄이기 위해 다중 매핑 메모리 기법을 사용한다. 같은 힙 메모리를 세 개의 독립된 가상 주소로 매핑한다.

### 다양한 장벽 최적화

쓰기 장벽이 도입되고 읽기 장벽의 역할이 바뀌면서 많은 가비지 컬렉터 코드가 컴파일된 애플리케이션 코드에 섞여 실행되게 되었다. 그래서 최적화가 중요하다

### 이중 버퍼를 이용한 기억 집합 관리

다른 컬렉터가 세대 간 포인터 관리에 기억 집합을 이용하여 스레드가 객체 필드에 값을 쓸 때 카드 테이블이라는 거대한 바이트 배열의 한 바이트에 더럽혀졌다고 표시한다. 보통 테이블의 한 바이트는 힙의 512바이트에 대응한다. 그럼 구세대에서 신세대를 가리키는 포인터를 찾으려는 가비지 컬렉터는 512바이트 범위에 모든 객체 필드를 확인해야 한다.

한편 ZGC는 비트맵을 이용해서 객체 필드의 위치를 정확하게 기록하고 비트맵의 비트 하나가 객체 필드 주소 하나를 표현한다. 그리고 구세대 리전 각각이 한 쌍의 기억 집합 비트맵을 가지고 있다. 비트맵 하나는 애플리케이션 스레드들의 쓰기 장벽에서 수정하게 되며, 그 읽기 전용 복사본인 다른 비트맵은 GC 스레드가 참고한다.

### 밀집도 기반 리전 처리

세대 기반 ZGC는 어느 리전부터 회수할지 정할 때 신세대 리전들의 밀집도를 분석하고 선정되지 않는 리전들은 나이를 먹고 생존자 리전이 되거나, 구세대 리전으로 승격된다. 생존자 리전들은 다음 GC때 밀집도가 높아져서 회수 대상이 될 가능성이 높아짐

### 거대 객체 처리

거대한 객체도 신세대로 할당하지만, 구세대로 재배치하는 비용을 걱정할 필요가 없는게, 재배치 없이 리전을 노화시킨다. 객체가 죽는다면 바로 회수되고, 바로 할당할 수 있는 상태가 된다.

## 3.7 적합한 가비지 컬렉터 선택하기

핫스팟 가상 머신은 다양한 가비지 컬렉터를 제공한다.

### 엡실론 컬렉터

JDK11에 추가된 엡실론 컬렉터는 GC를 전혀 하지 않는다. 레드햇이 제안한 가비지 컬렉터용 통합 인터페이스가 유요한지 입증하는 참조 구현이라 볼 수 있고, 성능 테스트나 스트레스 테스트에도 이용된다. 최근 마이크로서비스와 서버리스같은 형태의 단기 소규모 서비스에선 GC 전에 작업이 종료되고, 엡실론은 동작 부하가 적고 메모리 회수를 하지 않기에 적합하다.

### 컬렉터들 간 비교 및 취사선택

컬렉터들을 선택하는 요인 세 가지

- 애플리케이션의 주 목적
- 애플리케이션을 구동하는 서브시스템
- JDK 제공자

오라클은 가비지 컬렉터를 선택하기 위한 안내를 하고 있다.

- 최대 100MB 정도의 작은 데이터만 다루는 애플리케이션 → 시리얼 컬렉터
- 애플리케이션이 단일 프로세서만 사용하고 일시 정지 관련 제약이 없다면 → 시리얼 컬렉터
- 애플리케이션의 성능이 중요하고 지연 시간 관련 제약이 없거나 1초 이상 지연도 허용한다면 → 기본 컬렉터, 패러렐 컬렉터
- 처리량보다 응답 시간이 중요하고 가비지 컬렉터에 따른 일시 정지가 짧아야 한다면 → G1
- 응답 시간이 매우 중요하다면 → 세대구분 ZGC

### 가상 머신과 가비지 컬렉터 로그

가상 머신의 메모리 문제를 다루려면 기본적으로 VM, GC가 기록한 로그를 읽고 분석해야 한다. JDK9 이전엔 로그 설정이 다 달랐지만, 9버전에서 -Xlog 매개 변수로 모든 핫스팟의 기능 로그를 설정할 수 있게 되었다.

`-Xlog[:[selector] [: [output] [: [decorators] [:output-options]]]]`

가장 중요한 매개 변수는 셀렉터(selector)로 태그와 로그 레벨로 구성된다. 태그는 VM의 기능 모듈 이름을 뜻하며, 어떤 기능의 로그를 보고 싶은지 로깅 프레임워크에 알려주는 역할이다. 로그 레벨은 정보의 상세함 정도를 나타내고 Trace, Debug, Info, Warning, Error, Off 가 있고, Log4j와 비슷하다.

## 3.8 실전: 메모리 할당과 회수 전략

가장 근본적인 목표는 객체의 메모리를 자동 할당, 자동 회수다. 그 중 자동 (객체 메모리) 할당이란, 개념적으론 힙에 할당한다는 뜻인데, 전통적인 세대 단위에선 새로 태어난 객체는 보통 신세대에 할당된다. 특수한 경우(객체 크기가 특정 기준값보다 큰 경우)에만 구세대에 할당된다.