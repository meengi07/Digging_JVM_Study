자바는 거의 모든 객체 인스턴스를 힙에 저장한다. 가비지 컬렉터는 어떤 객체가 살아있고, 죽었는지를 판단한 후, 힙을 청소한다.

그럼 어떻게 객체가 살아있는지, 죽어있는지 판단할수 있을까?
대표적으로 참조 카운팅을 사용하여 판단한다고 생각하지만 자바 가상 머신은 참조 카운팅을 쓰지 않는다.

참조 카운팅
1. 객체가 가리키는 참조 카운터(reference counter)를 추가한다. 참조하는 곳이 하나 늘어날 때마다 카운터 값을 1씩 증가시킨다.
2. 참조하는 곳이 하나 사라질 때마다 카운터 값을 1씩 감소시킨다.
3. 카운터 값이 0이 된 객체는 더는 사용할 수 없다.

예를 들어,  순환 참조 문제를 참조 카운팅만으로 해결하기 어렵다. 예를 들어, 순환 참조같은 문제는 서로 참조하고 있기 때문에 참조 카운터는 0이 안되는 문제로 참조 카운팅 알고리즘으로는 둘을 회수하지 못한다. 

- 도달 가능성 분석 알고리즘

자바는 객체 생사 판단에 도달 가능성 분석 알고리즘을 이용한다. 
이 알고리즘의 기본 아이디어는 GC 루트라고 하는 루트 객체들을 시작 노드 집합으로 쓰는 것이다. 시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색해 들어간다. 
탐색 과정에서 만들어지는 경로를 참조 체인이라 한다. 그리고 어떤 객체와 GC 루트 사이를 이어주는 참조 체인이 없다면, 즉 GC 루트로부터 도달 불가능한 객체는 더 이상 사용할 수 없는 게 확실해진다. 
객체들이 서로 이어져 있지만 GC 루트로부터 도달할 길이 없으면 회수 대상이 된다. 

자바에서 GC 루트로 이용할 수 있는 객체는 정해져있다.

- 가상 머신 스택(스택 프레임의 지역 변수 테이블)에서 참조하는 객체
    현재 실행 중인 메서드에서 쓰는 매개 변수, 지역 변수, 임시 변수 등
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체
    자바 클래스의 참조 타입 정적 변수
- 메서드 영역에서 상수로 참조되는 객체 
    문자열 테이블 안의 참조
- 네이티브 메서드 스택에서 JNI(네이티브 메서드)가 참조하는 객체
- 자바 가상 머신 내부에서 쓰이는 참조
    기본 데이터 타입에 해당하는 Class 객체
    NullPointerException, OutOfMemoryError 등의 일부 상주 예외 객체
    시스템 클래스 로더
- 동기화 락(synchronized)으로 잠겨 있는 모든 객체
- 자바 가상 머신 내부 상황을 반영하는 JVMTI에 등록된 콜백, 로컬 코드 캐시 등

객체는 다른 영역에 있는 객체도 참조할 수 있으므로 연관된 영역의 객체들도 GC 루트 집합에 포함시켜야 도달 가능성을 정확하게 분석할 수 있다. 


- 참조
객체의 생사 판단과 '참조'는 분리해서 생각할 수 없다. JDK 1.2부터 참조 개념이 확장되어 참조를 네 가지로 구분한다.

  - 강한 참조(strong reference)
    가장 전통적인 정의의 참조
    Object obj = new Object()처럼 프로그램 코드에서 참조를 할당을 뜻함
    강한 참조 관계가 남아있는 객체는 가비지 컬렉터가 절대 회수하지 않는다.
  - 부드러운 참조(soft reference)
    유용하지만 필수가 아닌 객체
    메모리 오버플로가 나기 직전에 두 번째 회수를 위한 회수 목록에 추가된다.
    두번째 회수 후에도 메모리가 부족하면 그때 메모리 오버플로 예외를 던진다. 
  - 약한 참조(weak reference)
     부드러운 참조보다 연결 강도가 더 약하다.
    다음번 가비지 컬렉션까지만 살아있고, 가비지 컬렉터가 동작하기 시작하면 메모리가 넉넉하더라도 약하게 참조된 객체는 모두 회수된다.
  - 유령 참조(phantom reference)
    객체 수명에 영향을 주지 않는다.
    유령 참조를 통해 객체 인스턴스를 가져오지 못한다.
    유일한 목적은 대상 객체가 회수될 때 알림을 받기 위해서다.

- 살았나 죽었나?
도달 가능성 분석 알고리즘이 '도달 불가능'으로 판단한 객체는 반드시 죽은 객체는 아니고 두 번의 표시 과정을 거쳐야 한다.
도달 가능성 분석으로 GC 루트와 연결된 참조 체인을 찾지 못한 객체에는 첫 번째 표시가 이루어지며 필터링이 진행된다.
필터링 조건은 종료자(finalizer), 즉 'finalize() 메서드를 실해해야 하는 객체인가'이다. finalize()가 필요 없는 개체이거나 가상 머신이 finalize()를 이미 호출한 경우 모두 '실행할 필요 없음'으로 처리한다.

finalize()를 실행해야 하는 객체는 F-큐(F-Queue)라는 대기열에 추가된다. 그럼 가상 머신이 나중에 우선순위가 낮은 종료자 스레드를 생성해 F-큐에 들어있는 객체들의 finalize() 메서드를 실행한다. 가상머신은 이 메서드를 시작만 할 뿐 종료될 때까지 기다리지 않는다. 
만약 객체가 finalize()를 이용하여 참조 체인상의 아무 객체와 연결되면 두 번째 표시 과정에서 '회수 대상' 목록에서 제외된다.
하지만 finalize()은 실행하는 비용도 높고 불확실성도 크므로 가능한 한 사용하지 않는 게 좋다.


- 메서드 영역 회수하기
<자바 가상 머신 명세>에 따르면 가비지 컬렉터가 메서드 영역을 반드시 청소해야 하는 건 아니다. 가비지 컬렉션 한 번으로 자바 힙의 메모리 공간을 70~90% 를 회수하는 반면, 메서드 영역은 회수 조건이 까다로워서 대체로 '비용 효율'이 좋지 않다.

메서드 영역의 가비지 컬렉션은 더 이상 사용되지 않는 '상수'와 '클래스'를 회수한다. 상수가 참조하는 객체가 없고, 가상 머신에서 이 상수를 사용하는 코드가 없다면 회수한다. 하지만 더 이상 쓰이지 않는 '클래스'를 판단할 때는 다음 세 조건을 동시에 만족해야 한다.
이 클래스의 인스턴스가 모두 회수되었다. 즉, 자바 힙에는 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
이 클래스를 읽어 들인 클래스 로더가 회수되었다. 이 조건은 OSGi 나 JSP 리로딩처럼 세심하게 설계된 대안 클래스 로더 없이는 충족하기 어렵다.
이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서 참조하지 않고, 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다.
자바 가상 머신은 세 조건에 부합하는 쓸모없는 클래스들을 회수하도록 허용한다. 
핫스팟 가상 머신은 클래스 회수 여부를 제어할 수 있도록 -Xnoclassgc 매개변수를 제공한다. 또한 -verbose:class, -Xlog:class+load=info, -Xlog:class_unload=info 매개변수로는 클래스가 로딩되고 언로딩 되는 정보를 볼 수 있다.


- 가비지 컬렉션 알고리즘

가비지 컬렉션 알고리즘을 구현하는 데는 수많은 기법이 활용되며 가상 머신 또는 플랫폼에 따라 차이가 많다.
객체의 생사를 판별하는 방식을 기준으로 가비지 컬렉션 알고리즘을 '참조 카운팅 GC (직접 가비지 컬렉션)'와 '추적 GC (간접 가비지 컬렉션)'로 나눌 수 있다. 

- 세대 단위 컬렉션 이론
현재 상용 가상 머신들이 채택한 가비지 컬렉터는 대다수 프로그램에서 관측된 실제 상황들에서 얻은 경험 법칙을 구현한 세대 단위 컬렉션 이론에 기초해 설계되었다.
기본적으로 두 가정이 뿌리를 이룬다.
  약한 세대 가설: 대다수 객체는 일찍 죽는다.
  강한 세대 가설: 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
이 두 가정이 합쳐져 가비지 컬렉터들에 일관된 설계 원칙을 제공한다. 자바 힙을 몇 개의 영역으로 나누고 객체들을 나이에 따라 각기 다른 영역에 할당하는 것이다. 여기서 나이란 가비지 컬렉션에서 살아남은 횟수를 말한다. 영역 안의 객체 대부분이 곧바로 죽을 운명이라면 그 개게들을 한데 몰아넣고 살아남는 소수의 객체를 유지하면, 가비지 컬렉션에 드는 전체 시간도 줄고 메모리 공간도 효율적으로 이용할 수 있다.

자바 힙을 여러 영역으로 나누면 가비지 컬렉터는 한 번에 하나 또는 몇 개의 영역만 선택해 회수할 수 있는데 이를 기준으로 마이너 GC, 메이저 GC, 전체 GC로 부른다.

부분 GC : 자바 힙의 일부만 회수하는 가비지 컬렉션을 말하며 다음과 같이 세분화된다.
마이너 GC(신세대 GC) : 신세대만 대상으로 하는 가비지 컬렉션
메이저 GC(구세대 GC) : 구세대만 대상으로 하는 가비지 컬렉션. 집필 시점 기준으로 오직 CMS 컬렉터만 구세대를 따로 회수한다. 
혼합 GC : 신세대 전체와 구세대 일부를 대상으로 하는 가비지 컬렉션. 집필 시점 기준으로 G1 컬렉터만 이렇게 동작한다.
전체 GC : 자바 힙 전체와 메서드 영역까지 대상으로 하는 가비지 컬렉션

- 마크-스윕 알고리즘
작업을 표시(mark)와 쓸기(sweep) 두 단계로 진행한다. 먼저 회수할 객체들을 모두 표시한 다음, 표시된 객체들을 담는다. 반대로 살릴 객체에 표시되지 않은 객체를 회수한다. 

  - 단점
    실행 효율이 일정하지 않다. 자바 힙에 객체가 많고 대부분이 회수 대상이면 표시하는 일과 회수하는 일이 커진다. 즉 객체가 많아질수록 표시하고 쓸어 담는 작업의 효율이 떨어진다.
    메모리 파편화가 심하다. 가비지 컬렉터가 쓸고 가면 불연속적인 메모리 파편이 만들어진다. 파편화가 너무 심하면 프로그램이 큰 객체를 만들려 할 때 충분한 크기의 연속된 메모리를 찾기가 어려워지고, 그 결과 또 다른 가비지 컬렉션을 유발한다.

- 마크-카피 알고리즘
가용 메모리를 똑같은 크기의 두 볼록으로 나눠 한 번에 한 블록만 사용하고 한쪽 블록이 꽉 차면 살아남은 객체들만 다른 블록에 복사하고 기존 블록을 한번에 청소한다.  오늘날 사용 자바 가상 머신 대부분은 신세대에 이 알고리즘을 활용한다. 
  
  - 장점
    이 알고리즘은 구현하기 쉽고 실행 효율도 좋다. 
  - 단점
    가용 메모리를 절반으로 줄여 낭비가 심하다.

즉, 객체 생존율이 높을수록 복사할게 많아져서 효율이 나빠지고, 공간을 낭비하는 것을 대체하기 위해 하당 보증용 공간을 마련하여 대다수 객체가 살아남는 극단적 상황에 대처해야 한다.


- 아펠 스타일 컬렉션
핫스팟 가상 머신의 신세대 컬렉터는 모두 신세대 메모리의 레이아웃을 이 전략에 부합하게 구성한다.
아펠 스타일 컬렉션 방식은 신세대를 하나의 큰 에덴 공간과 두 개의 작은 생존자 공간으로 나누고, 메모리를 할당할 때는 생존자 공간 중 하나와 에덴만 사용한다. 가비지 컬렉션이 시작되면 에덴과 생존자 공간에서 살아남은 객체들은 나머지 생존자 공간으로 하나씩 복사한 후 에덴과 이전 생존자 공간을 곧바로 비운다. 아펠 스타일 컬렉션은 낭비하는 공간을 대처하기 위해 메모리 할당 보증 메커니즘을 추가하였는데, 이 메커니즘은 마이너 GC에서 살아남은 객체를 생존자 공간이 다 수용하지 못할 경우 다른 메모리 영역을 활용해 메모리 할당을 보증한다. 


- 마크-컴팩트 알고리즘
표시 단계는 마크-스윕과 같다. 하지만 다음 컴팩트 단계에서 회수 대상 객체들을 곧바로 쓸어 담는 대신, 생존한 모든 객체를 메모리 영역의 한쪽 끝으로 모은 다음, 나머지 공간을 한꺼번에 비운다.  마크-스윕과의 차이점은 메모리 이동이 일어난다. 구세대에서는 회수 때마다 살아남는 객체가 많아 생존한 객체를 이동시킨후, 이동된 객체들을 가리키던 기존 참조들을 모두 갱신하기 어렵다. 

메모리 할당과 접근에 부담을 많이 더하지 않는 방식은 대부분의 경우, 메모리 파편화를 감내하면서 마크-스윕을 사용하다가, 객체 할당에 양향을 줄 만큼 파편화가 심해지면 마크-컴팩트를 돌려 연속된 공간을 확보하는 것이다. CMS는 마크-스윕을 기본으로 하며, 메모리 파편화가 심해지면 이 전략을 실행하여 단점을 보완한다.


- 핫스팟 알고리즘 상세 구현
효율적인 가상 머신을 만들려면 각 알고리즘의 실행 효율을 따져봐야 한다. 다양한 가비지 컬렉터를 소개할 것이며, 필요한 기초 지식을 소개한다.

- 루트 노드 열거
'효율적인 가상 머신 구현하기'의 첫 번째 예로는 루트 노드 열거이다.
도달 가능성 분석 알고리즘에서 GC 루트 집합으로부터 참조 체인을 찾는 작업
GC 루트로 고정할 수 있는 노드는 주로 전역 참조(상수와 클래스 정적 속성 등)와 실행 콘텍스트(스택 프레임의 지역 변수 테이블 등)에 존재한다.
오늘 날의 자바 애플리케이션은 거대해지고 있어, 모든 참조를 확인하려면 시간이 많이 소요된다. 지금까지 모든 컬렉터는 루트 노드 열거 단계에서 사용자 스레드를 일시 정지해야 했다. 하지만 현재 도달 가능성 분석 알고리즘의 참조 체인 찾기 과정에서 가장 오래 거리는 작업은 다행히도 사용자 스레드와 동시에 실행할 수 있다. 단, 반드시 일관성이 보장되는 스냅숏 상태에서 수행해야 한다. 여기서의 일관성이란 열거 작업이 진행되는 동안 루트 노드들의 참조 관계가 변하지 않아야 한다. 현재 주류 자바 가상 머신들은 '정확한 가비지 컬렉션을 사용하는데 이는 정확한 메모리 관리 기술을 적용한 가비지 컬렉션을 말한다. 사용자 스레드가 정지한 후 실행 콘텍스트와 전역 참조의 위치를 빠짐없이 확인할 필요가 없다. 그 대신 가상 머신이 객체 참조가 저장된 위치를 직접 알아낼 방법이 있어야 한다.

핫스팟은 0opMap 데이터 구조를 이용해 클래스 로딩이 완료되면 객체에 포함된 각 데이터의 타입을 확인한 후, JIT 컴파일 과정에서 스택의 어느 위치와 어느 레지스터의 데이터가 참조인지 기록하여 이 문제를 해결한다. 컬렉터는 메서드 영역과 다른 GC 루트들을 추적해보지 않고 스캔 과정에서 이 정보를 직접 얻어낸다.


- 안전 지점
핫스팟은 0opMap을 활용하여 GC 루트들을 빠르고 정확하게 열거할 수 있다. 하지만 참조 관계나 0opMap의 내용을 변경할수 있는 명령어가 많으면, 명령어 모두 0opMap을 만들어 놓으면 메모리를 더 많이 사용해야한다.
그래서 핫스팟은 모든 명령어 각각에 0opMap을 생성하지 않고 안전 지점이라고 하는 특정한 위치에만 기록한다. 가비지 컬렉터는 사용자 프로그램이 안전 지점에 도달할 때까지는 절대 멈추지 않는다.
따라서 안점 지점을 너무 적게 설정해서 컬렉터가 너무 오래 기다리게 하거나, 반대로 너무 많이 설정해서 런타임 메모리 부하가 커지지 않도록 주의해야 한다.

안전 지점의 위치를 선택하는 기준은 '프로그램이 장시간 실행될 가능성이 있는가'이다. '장시간  실행'될 가능성을 보옂우는 상황은 명령어 흐름이 다중화 될때인데, 메서드 호출, 순환문, 예외 처리 등 명령어 흐름을 다중화하는 예이며, 이런 기능을 하는 명령어만이 안점 지점을 생성한다. 
또한 추가적으로 안전 지점과 관련하여 고려해야 할 무네는 가비지 컬렉션이 시작되면 JNI 호출을 실행 중인 스레드를 제외한 모든 스레드가 가장 가까운 안전 지점까지 실행하고 멈추게 할 방법이 필요한데, 선제적 멈춤과 자발적 멈춤이 있다.

  - 선제적 멈춤(preemptive suspension)
    스레드의 코드가 가비지 컬렉터를 특별히 신경 쓸 필요가 없다.
    가비지 컬렉션이 실행되면 시스템이 모든 사용자 스레드를 인터럽트 하여, 사용자 스레드가 중단된 위치가 안전 지점이 아니라면 스레드를 재개하고 안전 지점에 도달할 때까지 인터럽트를 반복한다.
    하지만 가비지 컬렉션에 선제적 멈춤 방식을 이용하는 가상 머신은 거의 없다.
  - 자발적 멈춤(voluntary suspension)
    가비지 컬렉터가 스레드 수행에 직접 관여하지 않는다.
    플레그 비트를 설정하고, 각 스레드가 실행 중에 플래그를 적극적으로 폴링 한다. 플래그 값이 true 이면 가장 가까운 안전 지점에스 스스로 멈춘다.
    폴링 플래그들은 안전 지점에 위치한다.
    객체 생성 등 자바 힙 메모리를 소비하는 장소에도 폴링 플래그가 추가된다. 메모리가 부족해 새로운 객체를 할당하지 못하는 일을 예방하기 위해 적절한 시점에 가비지 컬렉션을 수행하기 위함이다.
    폴링은 코드에서 자주 일어나므로 효율적 이여야 한다. 핫스팟은 메모리 보호 트랩이라는 방법을 써서 어셈블리 명령아 하나만으로 수행할 수 있게 단순화했다.

- 안전 지역
안전 지점 메커니즘은 실해 중인 프로그램이 짧은 시간에 안전 지점에 도달하여 가비지 컬렉션 프로세스가 제대로 임무를 다할 수 있게끔 보장하지만, 실행 중이 아닌 프로그램의 스레드들은 가상 머신의 인터럽트 요청에 응답할 수 없고, 안전 지점까지 수행한 후 인터럽트되어 스스로를 일시 정지 시킬 수 없다. 또한 스레드가 다시 활성화되어 프로세서를 할당 받을때까지 가상 머신이 기다리지 않는다.
실행 중이 아닌 프로그램이란 프로세서를 할당받지 못한 프로그램이며, 일반적으로 잠자기 상태이거나 블록된 상태의 사용자 스레드이다. 이런 경우를 위해 안전 지역이라는 개념이 필요하다.
안전 지역은 일정 코드 영역에서는 참조 관계가 변하지 않음을 보장한다. 안전 지역 안이라면 어디서든 가비지 컬렉션을 시작해도 무방하다는 뜻이다. 사용자 스레드는 안전 지역의 코드를 실행하기 앞서 안전 지역에 진입했음을 표시하면, 가비지 컬렉터는 이 스레드들을 신경 쓰지 않는다.
안전 지역에서 벗어나려는 스레드는 가상 머신이 루트 노드 열거를 완료했는지 또는 사용자 스레드를 일시 정지시켜야 하는 다른 가비지 컬렉션 단계를 완료했는지 확인한다.


- 기억 집합과 카드 테이블
가비지 컬렉션 시 컬렉터는 기억 집합을 이용해 특정 비회수 영역에서 회수 영역을 가리키는 포인터만 존재하는지만 확인하면 된다. 세대 간 포인터들 각각에 대해 더 이상 자세한 내용을 알 필요는 없다. 따라서 기억 집합 설계자는 정밀도를 낮춰서, 즉 기록 단위를 더 크게 잡아서 공간과 관리 비용을 절약할 수 있을 것이다. 
- 카드 정밀도
레코드 하나(카드)가 메모리 블록 하나에 매핑된다. 특정 레코드가 마킹되어 있다면, 해당 블록에 세대 간 참조를 지닌 객체가 존재한다는 뜻이다.
기억 집합은 사실 '추상' 데이터 구조다. 카드 정밀도로 기억 집합을 구현한 것을 카드 테이블이라 한다. 카드 테이블은 기록 정밀도와 힙 메모리의 매핑 관계 등을 정의하여 기억 집합을 구체적으로 구현한 방법 중 하나다. 카드 페이지 하나의 메모리에는 보통 하나 이상의 객체가 들어 있다. 이 객체들 중 하나라도 세대 간 포인터를 갖는 필드가 있다면, 카드 테이블에서의 해당 원소를 1로 표시하고, 그 원소는 더럽혀졌다라고 말한다. 세대 간 포인터를 갖는 객체가 하나도 없다면 0으로 표시된다. 그리고 객체를 회수할 때는 카드 테이블에서 더럽혀진 원소만 확인하면 어떤 카드 페이지의 메모리 블록이 세대 간 포인터를 포함하는지 쉽게 파악할 수 있다. 이런 식으로 세대 간 참조를 포함한 블록만 GC 루트에 추가해 함께 스캔한다. 이렇게 기억 집합을 이용해 GC 루트의 스캔 범위를 줄이는 문제를 해결한다.


- 쓰기 장벽
카드 테이블의 원소는 다른 세대의 객체가 현 블록 안의 객체를 참조하면 카드 테이블의 해당 원소는 더럽혀진다. 더럽혀지는 시점은 참조 타입 필드에 값이 대입되는 순간이다.
핫스팟 가상 머신은 쓰기 장벽 기술을 이용해 카드 테이블을 관리한다.
읽기 장벽은 동시 비순차 실행 문제를 해결하기 위한 메모리 장벽 기술이다. 
쓰기 장벽은 가상 머신 수준에서 '참조 타입 필드 대입'시 끼어드는 AOP 애스팩트(aspect)에 비유할 수 있다. 참조타입에 객체가 대입되면 어라운드 어드바이스가 생성되어, 대입 전후로 추가 동작을 수행할 수 있게 한다. 이런 기능 모두를 쓰기 장벽으로 구현할 수 있다. 대입 전 쓰기 장벽을 사전 쓰기 장벽이라 하며, 대입 후 쓰기 장벽을 사후 쓰기 장벽이라 한다. 핫스팟 가상 머신의 컬렉터 다수가 쓰기 장벽을 이용한다. 
쓰기 장벽을 적용하면 가상 머신은 추가로 실행할 명령어를 생성해 대입 연산 모두에 추가한다. 컬렉터가 쓰기 장벽으로 카드 테이블 갱신 연산을 추가한다면 참조가 갱신될 때마다 오버헤드가 더해진다.
카드 테이블은 멀티스레드 시나리오에서 거짓 공유(false sharing) 문제를 일으킬 수 있다.
  - 거짓 공유(false sharing)
  거짓 공유는 낮은 수준에서 동시성을 다룰  때 고려해야 하는 문제다. CPU의 캐시 시스템은 데이터를 캐시 라인 단위로 관리한다. 여러 스레드가 서로 다른 변수를 수정하는 상황에서 그 변수들이 같은 캐시 라인에 저장되어 있다면 라이트백(write back), 무효화, 동기화 등의 작업 시 서로 영향을 주어 성능을 떨어뜨린다. 실제로 공유하고 있지 않음에도 마치 공유하는 것처럼 서로 영향을 준다고 하여 이를 거짓 공유 문제라고 한다.
  JDK 7부터 핫스팟 가상 머신은 -XX:+UserCondCrdMark 매개변수를 추가하여 카드 테이블 갱신 시 조건을 판단할 수 있게 한다. 이 매개 변수를 설정하면 조건을 판단하는 오버헤드가 더해지지만, 거짓 공유 문제는 피할 수 있다.

- 동시 접근 가능성 분석
현재 주류 프로그래밍 언어의 가비지 컬렉터들은 기본적으로 도달 가능성 분석 알고리즘을 써서 객체의 생사를 판단한다. 이론적으로 도달 가능성 분석 알고리즘은 일관성이 보장되는 스냅숏 상태에서, 즉 사용자 스레드는 분석 과정 중 멈춰있는 상태에서 전체 과정을 진행해야 한다. 
루트 노드 열거가 끝나면 가비지 컬렉터는 GC 루트로부터 객체 그래프를 탐색할 수 있다. 이 단계의 일시 정지 시간은 자바 힙 크기에 비례한다. 힙이 클수록 더 많은 객체를 담게 되고 객체 그래프 구조도 복잡해진다. 
참조 관계를 추적하는 가비지 컬렉션 알고리즘들에는 공통적으로 '표시'단계가 등장한다. 표시 단계의 일시 정지 시간이 힙 크기에 비례해 증가한다면 거의 모든 가비지 컬렉터에 악영향을 준다. 즉, 이 단계의 일시 정지 시간을 줄이면 순영향을 준다.


- 삼색 표시(tri-color marking)
객체 그래프를 여행하는 과정에서 마주치는 객체들에 '방문한 객체'인가 라는 조건에 따라 아래 세 가지 색 중 하나를 칠하는 기법이다.
흰색: 가비지 컬렉터가 방문한 적 없는 객체인 경우. 도달 가능성 분석을 시작하면 모든 객체는 흰색이다. 분석을 마친 뒤에도 흰색인 객체는 도달 불가능함을 뜻한다.
검은색: 가비지 컬렉터가 방문한 적이 있으며, 이 객체를 가리키는 모든 참조를 스캔했다. 스캔되었고, 생존하면 검은 객체가 된다. 다른 객체에서 검은 객체를 가리키는 참조가 있다면 다시 스캔하지 않아도 된다. 검은 객체가 흰 객체를 바로 가리키는 건 불가능하다. 회색 객체를 거쳐 가리킬 수 있다.
회색: 가비지 컬렉터가 방문한 적 있으나, 이 객체를 가리키는 참조 중 스캔을 완료하지 않은 참조가 존재한다.
  - 삼색 표시 기법의 장점
    - 인크리멘털(Incremental) GC 가능
      전체 프로그램을 멈추지 않고(Stop-the-world 최소화) 점진적으로 수행할 수 있다.
    - 병렬(Concurrent) GC 가능
      여러 스레드에서 병렬로 가비지 컬렉션이 가능해서 성능이 좋아진다.
    - 안전성(Safety) 확보
      흑색(Black) 객체가 흰색(White) 객체를 직접 참조하는 경우가 없음 → 가비지 컬렉션 중 메모리 정합성을 유지할 수 있다.

만약 사용자 스레드와 컬렉터가 동시에 실행되면, 발생하는 문제점
- 죽은 객체를 살았다고, 잘못 표시할 수 있다.
- 살아 있는 객체를 죽었다고 표시할 수 있다. 치명적이며, 프로그램 오류로 이어진다.

아래 두 조건이 동시에 만족될 때만 객체 사라짐 문제가 나타난다.
사용자 스레드가 흰색 객체로의 새로운 참조를 검은색 객체에 추가
사용자 스레드가 회색 객체에서 흰색 객체로의 직간접적인 참조를 삭제
동시 스캔 도중 객체 사라짐 문제를 해결하려면 두 조건 중 하나만 만족하면 된다. 
해법은 증분 업데이트와 시작 단계 스냅숏(snapshot at the beginning)이 있다.

- 증분 업데이트 (Incremental Update)
  검은색 객체에 흰색 객체로의 참조가 추가되면 새로 추가된 참조를 따로 기록해 두어, 동시 스캔이 끝난 후 기록해 둔 검은색 객체들을 루트로 하여 다시 스캔한다. 
  GC가 루트 객체(root set)부터 점진적으로 객체 그래프를 탐색하면서 업데이트하는 방식.
  탐색 중에도 애플리케이션이 객체의 참조를 변경할 수 있음, 그래서 변경 사항을 즉시 반영해야 함.
  이를 위해 Write Barrier(쓰기 방벽) 기술을 사용하여 새로운 참조를 즉시 회색(Gray)으로 변경함.
  - 장점:
    Stop-the-world 시간을 줄일 수 있음 (애플리케이션과 GC가 병렬로 실행 가능).
    최신 변경 사항을 계속 반영하므로 더 적은 가비지가 떠다님(Floating Garbage 감소).

- 시작 단계 스냅숏 (Snapshot at the Beginning, SATB)
  회색 객체가 흰색 객체호의 참조 관계를 끊으려 하면 그 사실을 기록하며, 동시 스캔이 끝난 후 기록해 둔 회색 객체들을 루트로 하여 다시 스캔한다.  
  GC가 마킹을 시작하는 순간의 객체 그래프 상태를 유지하는 방식.
  애플리케이션이 마킹 중에 참조를 변경하더라도, 마킹 시작 시점의 참조 상태를 기준으로 가비지를 판별함.
  새로운 객체가 추가되더라도 기존에 흰색(White)으로 표시된 객체는 유지, 나중에 다시 탐색하지 않음.
  - 장점:
    마킹 시작 시점의 상태를 기준으로 하기 때문에 예측 가능한 동작을 보장함.
    정합성을 유지하면서 인크리멘털 GC 수행 가능.


가상 머신은 쓰기 장벽을 이용해 기록 작업을 구현한다. 
핫스팟 가상 머신은 증분 업데이트와 시작 단계 스냅숏을 모두 활용한다. 메모리를 다시 확보하는 구체적인 방법은 가상 머신이 사용하는 가비지 컬렉터에 따라 다르며, 일반적으로 가상 머신은 다수의 가비지 컬렉터를 제공한다.

클래식 가비지 컬렉터

클래식 가비지 컬렉터는 고성능 및 저지연 컬렉터와 구분하기 위해 사용되는 용어로, 핫스팟 가상 머신에서 제공하는 전통적인 가비지 컬렉션 방식들을 포함한다. 이 컬렉터들은 각각의 특성에 따라 메모리 관리를 수행하며, 주로 다음과 같은 종류가 있다:
시리얼(Serial) 가비지 컬렉터: 단일 스레드를 사용하여 가비지 컬렉션을 수행한다. 간단하고 효율적이며, 작은 애플리케이션이나 리소스가 제한된 환경에서 적합하다.
파뉴(Parallel) 가비지 컬렉터: 여러 스레드를 사용하여 가비지 컬렉션을 병렬로 수행한다. CPU를 효율적으로 활용하여 짧은 시간 안에 메모리를 회수할 수 있지만, 여전히 일시 정지가 발생할 수 있다.
패러렐 스캐빈지(Parallel Scavenge) 가비지 컬렉터: 파뉴와 유사하지만, 짧은 일시 정지 시간과 높은 처리량을 목표로 한다. 객체의 생존 주기를 고려하여 신세대 객체의 회수를 최적화한다.
패러렐 올드(Parallel Old) 가비지 컬렉터: 구세대(Old Generation)에서 가비지 컬렉션을 병렬로 수행하는 컬렉터로, 패러렐 스캐빈지 컬렉터와 함께 사용된다.
시리얼 올드(Serial Old) 가비지 컬렉터: 단일 스레드를 사용하여 구세대의 가비지 컬렉션을 수행한다. 자원이 제한된 환경에서 효과적이며, 다른 시리얼 컬렉터와 함께 사용할 수 있다.
CMS(Concurrent Mark-Sweep) 가비지 컬렉터: 동시(mark-sweep) 방식으로 구세대 객체를 회수하는 컬렉터로, 응답성이 중요한 애플리케이션에 적합하다. 사용자가 지정한 시점에 가비지 컬렉션을 수행할 수 있어 일시 정지 시간을 줄이는 데 기여한다.
병렬과 동시
병렬과 동시는 모두 '동시성 프로그래밍'과 관련된 기술 용어이다. 

- 병렬(parallel) : GC 스레드들 사이의 관계를 설명하며, 'GC 스레드 다수가' 동시에 함께 작업을 수행한다. 보통 이때 사용자 스레드는 정지 상태다.
- 동시(concurrent) : GC 스레드와 사용자 스레드의 관계를 설명하며, 'GC 스레드와 사용자 스레드가' 동시에 일을 진행한다는 뜻이다. 사용자 스레드가 멈춰 있지 않아 애플리케이션이 서비스 요청에 응답할 수 있다. 하지만 GC 스레드가 시스템 자원 일부를 점유하므로 애플리케이션의 처리량은 평소보다 낮아질 수 있다.
 
 
1. 시리얼 컬렉터
가장 기초적이로 오래된 컬렉터
단일 스레드
가비지 컬렉션이 시작되면 '회수가 완료될 때까지 다른 모든 작업 스레드가 멈춰 있어야 한다.
가용 메모리가 적은 환경에서는 알고리즘 자체가 요구하는 메모리 사용량이 가장 적다. 
단일 코어 프로세서 또는 코어 수가 적은 환경이라면 시리얼 컬렉터는 스레드 상호 작용에 의한 오버헤드가 없다.
가비지 컬렉션에 집중하므로 자연스럽게 회수 효율을 최대로 끌어낸다.
시리얼 컬렉터를 사용하기 위해서는 -XX:+UserSerialGC 매개변수를 추가하면 된다.
 
2. 파뉴 컬렉터
여러 스레드를 활용하여 시리얼 컬렉터를 병렬화한 버전이다.
스레드 회수에 멀티스레드를 이용한다.
GC 스레드와 사용자 스레드가 동시에 실행되는것을 최초로 실현해 냈다.
핫스팟 가상 머신 역사에서 사라진 최초의 가비지 컬렉터
단일 코어 프로세서에서는 시리얼 컬렉터보다 성능이 떨어진다.
스레드들의 상호 작용에 따른 오베허드 존재
코어수가 늘어나면 파뉴는 가비지 컬렉션을 하는 동안에 시스템 자원을 효율적으로 사용할 가능성이 커진다.
 
3. 패러렐 스캐빈지 컬렉터
신세대용이며, PS 컬렉터라고도 불린다.
마크-카피 알고리즘에 기초하며, 여러 스레드를 이용해 회수한다.
프로세서가 사용자 코드를 실행하는 데 사용하는 시간과 프로세서가 소비하는 총시간의 비율을 뜻하는 처리량을 제어하는 게 목표다.
처리량에 관심이 많아 처리량 컬렉터라고ㅗ 부르기도 한다.
 -XX:MaxGCPauseMillis : 가비지 컬렉션 정지 시간의 최댓값을 지정. 컬렉터는 메무리 회수에 소용되는 시간이 이 설정값을 넘지 않는다.
 -XX:GCTimeRatio: 처리량을 직접 지정. 애플리케이션의 총 실행 시간에 대한 가비지 컬렉션 시간의 배율
-XX:+UserAdaptiveSizePolicy : 신세대의 크기, 에덴과 생존자의 공간 비율, 구세대로 옮겨갈 객체의 크기 등. 세부 설정 매개변수를 지정하지 않아도 된다. 가상 머신이 성능 모니터링 정보를 수집하여 최적의 정지 시간과 최대 처리량을 제공할 수 있도록 모든 매개 변수의 값을 동적으로 조율해 준다. GC 인간 공학이라고도 한다.
가상머신이 메모리 관리 최적화를 해주므로 수동으로 최적화하기 어려운 운영자에게는 적응형 조율 전략을 지원하는 PS 컬렉터가 괜찮은 선택지이다.
적응형 조율 전략은 파뉴 컬렉터와 차별화하는 중요한 특성이다.
 
4. 시리얼 올드 컬렉터
시리얼 컬렉터의 구세대용 버전
단일 스레드 컬렉터, 마크-컴팩트 알고리즘 사용
주로 클라이언트용 핫스팟 가상 머신에서 사용한다.
 
5. 패러렐 올드 컬렉터
PS 컬렉터의 구세대용 버전
멀티스레드를 이용한 병렬 회수를 지원하며 마크-컴팩트 알고리즘으로 구현되었다.
구세대 컬렉터들의 메모리 용량은 크고 하드웨어는 좋지만, 단일 스레드로 동작 하여 서버용 프로세서의 병렬 처리 역량을 끌어낼 수 없었다.
처리량이 중요하거나 프로세서 자원이 부족한 상황이라면 처리량을 중시하는 PS 컬렉터와 패러렐 올드 조합이 적합하다.
사용하기 위해서는 XX:+UserParallelGC 매개변수를 지정한다.
 
6. CMS 컬렉터
표시와 쓸기 단계 모두를 사용자 스레드와 동시에 수행한다.
CMS 컬렉터의 목적은 가비지 컬렉션에 따른 일시 정지 시간을 최소로 줄이는 것이다.
자바 애플리케이션의 주력 분야는 인터넷 서비스의 백엔드와 브라우저 기반의 브라우저-서버 시스템이기 때문에 서비스 응답 시간이 중요하므로 시스템의 일시 정지 시간이 짧아야 사용자에게 더 나은 경험을 줄 수 있다. 
마크-스윕 알고리즘을 기초로 구현되었으며, 기존 컬렉터들보다 훨씬 복잡하게 동작한다.
전체 과정은 최초 표시 - 동시 표시 - 재표시 - 동시 쓸기 로 구성된다.
"최초 표시"와 "재표시" 단계는 '스톱 더 월드' 방식이다.
최초 표시 단계에서는 GC 루트와 직접 연결된 객체들만 표시하기 때문에 아주 빠르게 끝난다. 
동시 표시 단계에서는 GC 루트와 직접 연결된 객체들로부터 시작해 객체 그래프 전체를 탐색한다. 시간이 오래 걸리지만 사용자 스레드를 멈추지 않고 GC 스레드와 동시에 실행된다.
재표시 단계에서는 동시 표시 도중 사용자 스레드가 참조 관계를 변경한 객체들을 바로잡는다. 이 단계의 일시 정지 시간은 보통 최초 표시 단계보다 살짝 길며, 동시 표시 단계보다는 훨씬 짧다.
동시 쓸기 단계에서는 죽은 객체들을 쓸어 담으며, 이 단계 역시 사용자 스레드를 멈추지 않고 동시에 수행한다.
중요한 특성은 전체 과정 중 가장 긴 동시 표시와 동시 쓸기 단계에서 사용자 스레드를 멈추지 않는다.
CMS 컬렉터의 주요 장점은 애플리케이션 스레드와 병렬로 가비지 컬렉션을 수행하여 정지 시간을 최소화하는 것이다.
CMS 컬렉터의 첫번째 단점은 프로세서 자원에 민감하다는 점이다. 가비지 컬렉션을 수행하는 GC 스레드가 애플리케이션과 프로세서 성능을 공유하기 때문에, CPU 사용량이 높은 애플리케이션에서는 성능 저하가 발생할 수 있다. 특히, 애플리케이션이 본래 많은 프로세서 리소스를 필요로 하는 경우, GC가 상당한 CPU를 점유하면서 사용자 프로그램의 실행 속도가 눈에 띄게 느려질 수 있다.
CMS의 또 다른 단점은 부유 쓰레기(Floating Garbage)를 회수하지 못한다는 점이다. CMS의 동시 마킹 및 동시 스위핑 단계에서 애플리케이션 스레드는 계속 실행되므로, 이 과정에서 새로운 객체가 생성될 수 있다. 하지만 일부 객체는 마킹이 끝난 후에 가비지가 되어도, 해당 GC 사이클에서는 회수되지 않는다. 이러한 객체들을 부유 쓰레기라고 하며, 결국 다음 GC 사이클까지 메모리를 차지하게 된다. 이로 인해 동시 모드 실패가 발생할 가능성이 있다. 즉, CMS가 메모리를 충분히 확보하지 못하면 결국 Stop-the-World 방식의 전체 GC가 강제로 실행되면서 애플리케이션 응답 시간이 크게 증가할 수 있다. 따라서, CMS를 사용할 경우 가비지 컬렉션 동안에도 사용자 스레드가 원활히 실행될 수 있도록 충분한 메모리 공간을 확보하는 것이 중요하다.
CMS의 또 다른 단점은 메모리 파편화 문제이다. CMS는 마크-스윕(Mark-Sweep) 방식으로 가비지를 정리하는데, 메모리를 압축하지 않기 때문에 파편화가 발생할 수 있다. 파편화가 심해지면 큰 객체를 할당할 때 연속된 메모리 공간을 찾지 못해 할당이 실패할 수 있다. 이 경우 결국 전체 GC(Full GC)를 실행하여 메모리를 정리해야 한다. 이 문제를 해결하기 위해 CMS는 -XX:+UseCMSCompactAtFullCollection 옵션을 제공한다. 이 옵션을 활성화하면 CMS가 Full GC를 수행할 때 메모리 조각 모음(Compaction)도 함께 실행한다. 하지만 이 과정에서 살아있는 객체를 이동해야 하므로, 사용자 스레드와 동시에 실행할 수 없고 정지 시간이 길어질 수 있다. 이를 보완하기 위해 JVM은 -XX:CMSFullGCsBeforeCompaction 옵션을 제공한다. 이 옵션은 지정된 횟수만큼 Full GC를 수행한 후에만 조각 모음을 실행하도록 설정할 수 있다. 즉, 모든 Full GC에서 조각 모음을 수행하는 것이 아니라, 일정 횟수 후에만 실행함으로써 정지 시간을 조절할 수 있도록 한 것이다.
자바 애플리케이션은 웹 서비스의 백엔드(서버 측 로직) 와 브라우저-서버 기반 시스템 개발에 많이 사용됩니다. 이러한 애플리케이션에서 가장 중요한 요소 중 하나가 서비스 응답 시간입니다. 서비스 응답 시간이란 사용자가 요청을 보낸 후 서버가 응답을 주는 데 걸리는 시간을 의미합니다. 응답 시간이 길어지면 사용자 경험(UX)이 나빠지고, 페이지 로딩 속도가 느려지거나 서비스가 끊기는 것처럼 보일 수 있습니다.
시스템의 "일시 정지 시간"이 중요한 이유는 자바는 가비지 컬렉터를 사용하여 메모리를 자동으로 관리합니다. 하지만 GC가 실행될 때 애플리케이션의 일부 또는 전체가 일시적으로 멈추는 "Stop-the-world" 현상이 발생할 수 있습니다. 이 일시 정지 시간이 길어지면, 서버가 클라이언트 요청을 즉시 처리하지 못하고 대기해야 합니다. 결과적으로 사용자는 서비스가 느려졌다고 느끼거나, 심한 경우 서비스가 멈춘 것처럼 보일 수 있습니다.

일시 정지 시간을 줄이는 방법
- GC 튜닝
   - 최신GC 알고리즘(예: G1GC, ZGC, Shenandoah GC) 활용
   - JVM 옵션 조정 (-XX:MaxGCPauseMillis 설정 등)

- 메모리 관리 최적화
   - 불필요한 객체 생성을 줄이고, 메모리 누수 방지
   - 객체 풀(Object Pool) 활용

- 비동기 및 병렬 처리 최적화
   - 요청을 비동기(Async) 방식으로 처리
   - 적절한 스레드 풀(Thread Pool) 설정

즉, "시스템의 일시 정지 시간이 짧아야 한다"는 말은 GC로 인해 애플리케이션이 멈추는 시간을 최소화하여, 서버가 항상 빠르게 응답할 수 있도록 해야 한다는 의미입니다.
 
 
7. G1 컬렉처(가비지 우선 컬렉터)
Garbage First(가비지 우선)을 짧게 줄인 표현이다.
주로 서버용 애플리케이션에 집중한 컬렉터다.
힙 메모리의 어느곳이든 회수 대상에 포함할 수 있다. 이를 회수 집합이라 하며 짧게 CSet라고 한다. '어느 영역에 쓰레기가 가장 많으냐'와 '회수했을 때 이득이 어디가 가장 크냐'가 회수 영역을 고르는 기준이 된다. 이것이 G1의 혼합 GC 모드다.
G1은 자바 힙을 동일 크기의 여러 독립 리전(블록)으로 나눠, 리전 각각에 역할별 전략을 구분하여 적용할 수 있어서 회수 효율을 극대화한다.
큰 객체를 저장하기 위해서는 거대리전(humongous region)이라는 특별한 유형을 활용한다. G1은 리전 용량의 절반보다 큰 객체를 큰 객체로 취급한다. 리전 하나의 크기는 -XX:G1HeapRegionSize 매개변수로 설정한다.
 G1 GC의 회수 효율 극대화 원리
가비지가 많은 리전부터 우선 회수(Garbage First)
기존의 GC는 전체 Young 또는 전체 Old 영역을 대상으로 GC를 수행하지만,
G1은 회수할 가치가 높은 리전부터 선택적으로 GC를 수행하여 최소한의 비용으로 최대한의 메모리를 회수한다.
리전별 독립적인 GC 적용
각 리전의 역할과 상태에 따라 최적의 GC 전략을 적용하여 불필요한 정지 시간을 줄인다.
예를 들어, Young GC는 Young 리전에서만 수행되고, Mixed GC는 Young + Old 리전을 대상으로 수행된다.
연속적인 메모리 확보(Compact) 기능 포함
CMS와 달리 메모리 파편화를 해결하기 위해 객체를 이동하여 연속적인 공간을 확보하는 Compact 기능이 포함되어 있다.
따라서 큰 객체를 할당할 때 메모리 부족 문제가 발생하는 것을 방지할 수 있다.
G1 GC는 힙을 여러 개의 리전으로 나누고, 각 리전에 역할을 동적으로 할당하여 불필요한 GC 작업을 줄이고, 가장 효과적으로 회수할 수 있는 영역을 우선적으로 정리하여 GC 성능을 극대화하는 방식이다.
 
 
8. 오늘날의 가비지 컬렉터들
신세대용과 구세대용 구분이 사라졌다.
저지연 가비지 컬렉터
핫스팟의 가비지 컬렉터는 시리얼 -> CMS -> G1으로 진화했다.
가비지 컬렉터를 측정하는 가장 중요한 지표는 처리량, 지연시간, 메모리 사용량이다. 
하드웨어 성능이 향상되면서 메모리를 조금 더 사용하는 것은 큰 문제가 되지 않는다. 또한 성능이 좋은 가비지 컬렉터는 애플리케이션에 미치는 영향을 줄여 전체 처리량을 증가시킨다. 하지만 메모리를 늘리면 지연 시간이 길어지고 성능에 미묘한 영향을 줄 수 있다. 이러한 이유로 가비지 컬렉터에서 가장 중요한 성능 지표는 지연 시간이다.
셰년도어와 ZGG 컬렉터는 최초 표시와 최종 표시에서만 일시 정지가 짧게 일어나며, 일시 정지 시간은 거의 고정적이다. 즉, 힙 크기와 힙 안의 객체 수가 늘어난다고 해서 더 길어 지지 않는다. 그래서 이 두 컬렉터를 '저지연 가비지 컬렉터'라고 한다.
 
1. 셰년도어
오라클 가상 머신 개발팀이 주도하지 않은 첫번째 핫스팟 가비지 컬렉터라서 오라클 JDK에는 없고 다른 회사 OpenJDK에만 존재하는 컬렉터다.
힙을 리전들로 쪼개 처리하며, 큰 객체 전용의 거대 리전을 지원하고, 기본적으로 회수가치가 큰 리전을 먼저 회수한다. 
셰년도어의 목표는 힙 크기와 상관없이 가비지 컬렉션으로 인한 일시정지를 10밀리 초 이내로 묶어두는 것이었다.
G1 컬렉터는 셰년도어의 코드를 반영하여 동시 실패의 탈출구인 전체 GC를 멀티스레드로 처리할 수 있게 되었다.
 
셰년도어의 개선사항
동시 모으기 지원
신세대 리전과 구세대 리전을 구별하지 않는다. 셰년도어에서 세대 구분은 복잡도와 일정을 고려해 개발 우선순위에서 낮췄다.
메모리와 컴퓨팅 자원을 많이 사용하는 기업 집합 대신 '연결 행렬'로 리전 간 참조 관계를 기록한다. 그 덕분에 관리 비용도 줄고 거짓 공유 문제가 발생할 가능성도 줄었다.
 
동작방식
최초 표시
가장 먼저 GC 루트에서 직접 참조하는 객체들에 표시한다.
이 과정은 "Stop-The-World" 상태에서 실행되며, 빠르게 완료된다.
동시 표시
객체 그래프를 타고 힙을 탐색하며 도달 가능한 모든 객체를 표시한다.
사용자 스레드와 동시에 수행된다.
수행 시가은 살아있는 객체 수와 객체 그래프의 복잡도에 따라 다르다.
사용자 스레드가 새로운 객체를 생성할 수 있으므로 힙 사용량이 늘어날 수 있다.
최종 표시
보류 중인 모든 표시를 완료하고 GC 루트 집합을 다시 스캔한다.
회수가치가 가장 큰 리전들을 추려 회수 집합을 생성한다.
이 단계도 짧지만 일시 정지된다.
동시 청소
살아 있는 객체가 하나도 없는 리전들을 청소한다.
동시 이주
다른 핫스팟의 컬렉터들과 구분되는 핵심 차이
회수 집합 안에 살아 있는 객체들을 다른 빈 리전으로 복사한 후, 해당 객체를 가리키던 참조 모두가 여전히 이동 전 객체를 가리키고 있으므로 읽기 장벽과 포워딩 포인터를 이용한다. 
실행 시간은 회수 집합의 크기에 따라 다르다.
최초 참조 갱신
참조 갱신 : 객체 이동에 따른 참조를 수정한다. 동시 이주 단계에서 객체를 복사한 다음, 힙에서 옛 객체를 가리키는 모든 참조를 복사 후의 새로운 주소로 수정한다.
애플리케이션이 계속 실행되는 동안 힙 내의 참조를 최신 상태로 업데이트한다
동시 참조 갱신
참조 갱신을 시작하며 사용자 스레드와 동시에 수행한다.
수행 시간은 메모리에 존재하는 참조의 수에 따라 다르다.
물리 메모리 주소의 순서대로 참조 타입을 선형 검색하여 이전 값을 새로운 값으로 수정한다.
최종 참조 갱신
힙의 참조를 다 갱신한 후, GC 루트 집합의 참조도 갱신한다.
셰년도어의 마지막 일시 정지 단계다.
정지 시간은 GC 루트의 개수에 따라 다르다.
동시 청소
이주와 참조 갱신이 끝나면 회수 집합의 모든 리전에는 살아 있는 객체가 더 이상 남지 않는다.
그래서 동시 청소를 다시 수행하여 새로운 객체를 할당할 공간을 확보한다.
셰년도어의 가장 중요한 단계는 동시 표시, 동시 이주, 동시 참조 갱신이다. 
 
포워딩 포인터
셰년도어가 이주를 동시에 수행할 수 있도록 하는 핵심 개념이다.
객체 이동과 사용자 프로그램을 동시에 수행하는 방법
객체 이동 시 원래 위치에서 새로운 위치를 가리키는 역할을 하는 포인터이다. 주로 압축(Compaction) 또는 복사(Copying) 가비지 컬렉션 과정에서 사용된다.
 
포워딩 포인터가 필요한 이유
가비지 컬렉션 중 일부 알고리즘(예: Shenandoah GC, G1 GC, Copying GC)에서는 메모리 단편화(Fragmentation) 문제를 해결하기 위해 객체를 이동한다.
이 과정에서 기존 객체의 참조를 그대로 유지하려면 객체가 이동된 후에도 기존 참조들이 새 위치를 찾을 수 있도록 해야 한다.
이를 해결하기 위해 포워딩 포인터를 사용한다.
 
포워딩 포인터의 동작 방식
객체 이동 전
객체가 힙 메모리의 한 위치(예: 주소 A)에 존재하고, 여러 참조가 해당 객체를 가리킨다.
객체 이동 과정
GC가 객체를 새로운 위치(예: 주소 B)로 이동한다.
원래 객체가 있던 자리(주소 A)에 포워딩 포인터를 저장하여 주소 B를 가리키도록 설정한다.
참조 업데이트 과정
이후, 다른 객체나 스레드가 주소 A에 있는 객체를 참조하려고 하면, 포워딩 포인터를 따라 새 주소 B로 이동한다.
GC는 모든 참조를 새로운 위치(B)로 업데이트한 후, 포워딩 포인터를 제거한다.
 
포워딩 포인터의 장점
객체 참조 유지 → 기존 참조가 깨지지 않고 새 위치를 찾을 수 있다.
메모리 단편화 해결 → 객체를 압축하면서도 참조 무결성을 유지할 수 있다.
애플리케이션의 중단 최소화 → 일부 GC 알고리즘은 객체를 이동하면서도 애플리케이션을 실행 가능하게 한다.
단점 및 주의
추가적인 메모리 사용 → 포워딩 포인터를 저장하는 공간이 필요하다.
참조 업데이트 비용 → 모든 참조를 새로운 위치로 변경해야 하므로 성능에 영향을 줄 수 있다.
 
2. ZGC
오라클이 개발한 저지연 가비지 컬렉터
ZGC는 초저지연(Low-Latency) 가비지 컬렉터로, 최대 1~2ms 이하의 GC 일시 정지 시간(Pause Time)을 목표로 설계된 스케일러블(Scalable) GC이다.
셰년도어와 마찬가지로 둘 다 처리량에 미치는 영향을 최소로 억제하면서 힙 크기에 상관없이 가비지 컬렉션으로 인한 일시 정지 시간을 10밀리 초 안쪽으로 줄이고자 했다.
세대 구분 없이 리전 기반 메모리 레이아웃을 사용한다. 낮은 지연 시간을 최우선으로 목표로 하며, 동시 마크-컴팩트 알고리즘을 구현하기 위해 읽기 장벽, 컬러포인터, 메모리 다중 매핑 기술을 이용하는 가비지 컬렉터이다.
리전 기반 메모리 레이아웃
ZGC의 리전은 동적으로 생성/파괴되며, 크기도 동적으로 달라진다.
병렬 모으기
GC는 병렬 모으기(Parallel Compaction) 알고리즘을 사용하여 메모리 단편화(Fragmentation) 문제를 해결한다.
즉, 객체를 이동(Compaction)시키면서 힙을 정리하는 과정을 여러 개의 스레드에서 병렬로 실행하여 GC 일시 정지 시간을 최소화하는 방식이다.
1. 일반적인 GC의 단편화 문제
일반적인 가비지 컬렉터는 객체를 제거하면서 힙 메모리에 빈 공간(단편화)이 발생한다.
단편화가 심해지면 큰 객체를 할당할 연속된 공간을 찾지 못해 할당 실패 발생한다.
해결하려면 객체를 이동하여 연속된 공간을 확보(Compaction) 해야 한다.
하지만 대부분의 GC는 Compaction 단계에서 스톱 더 월드(Stop-The-World, STW) 시간이 길어지는 문제가 있다.
ZGC는 병렬 모으기(Parallel Compaction)를 통해 이 문제를 해결한다.
 
2. ZGC의 병렬 모으기 방식
ZGC는 기존의 GC와 다르게 대부분의 객체 이동 작업을 애플리케이션과 동시에 진행한다.
이 과정에서 Forwarding Pointer(포워딩 포인터)와 Colored Pointer(컬러드 포인터)를 활용하여 객체 참조를 자동으로 업데이트한다.
 
병렬 모으기 3단계
ZGC의 Compaction 과정은 3단계로 이루어진다.
 
1. Prepare(준비 단계)
살아 있는 객체를 식별하고, 어떤 객체를 이동할지 결정
객체 이동이 필요한 리전을 선택
2. Relocation(객체 이동 단계)
객체를 새로운 위치로 병렬로 복사
이전 객체의 주소에 포워딩 포인터(Forwarding Pointer)를 저장하여 참조 자동 업데이트
3. Remapping(참조 업데이트 단계)
애플리케이션 실행 중 모든 참조를 새 주소로 자동 변경
Colored Pointer를 사용하여 객체 참조를 실시간으로 리맵핑
이 과정에서 GC 일시 정지(Pause Time)는 1~2ms 이내로 유지된다.
 
3. 병렬 모으기의 핵심 기술
 1) 포워딩 포인터 (Forwarding Pointer)
객체가 이동되면 이전 위치에 새 위치 정보를 저장
참조된 객체를 자동으로 새로운 위치로 리디렉션 가능
덕분에 애플리케이션이 실행되는 동안에도 안전하게 객체 이동 가능
 2) 컬러드 포인터 (Colored Pointer)
64비트 포인터의 일부 비트를 활용해 객체의 상태를 저장
객체가 이동되었을 때, 참조를 자동으로 업데이트하여 추가적인 스톱 더 월드 과정 없이 GC 수행 가능
 
4. 병렬 모으기의 장점
STW(Stop-The-World) 최소화 → GC 정지 시간이 1~2ms 이하로 유지됨
큰 힙(16TB)에서도 효율적인 메모리 정리 가능
멀티코어 CPU 활용 극대화 → 여러 스레드에서 객체 이동을 병렬로 수행
실시간 애플리케이션에 적합 → 응답 속도가 중요한 환경(실시간 시스템, 대규모 서버 환경)에서 강력한 성능을 발휘한다.
 
5. 병렬 모으기의 단점
CPU 오버헤드 증가
GC가 애플리케이션과 병렬로 실행되므로 일부 CPU 리소스를 사용한다.
Throughput(처리량) 감소 가능성
CPU를 활용한 GC 작업이 많아짐에 따라 처리량이 약간 줄어들 수 있다.
 
 
적합한 가비지 컬렉터 선택하기

자금은 여유롭지만 최적화 경험이 부족하다면 유료 기술 지원을 받을 수 있는 전용 하드웨어와 소프트웨어 솔루션이 좋은 선택이다. 이 경우 C4 컬렉터를 사용할 수 있다.
상용 제품을 쓸 여유는 없지만 소프트웨어와 하드웨어 모델을 제어할 능력이 된다면 최선 버전을 사용하자. 특히 지연 시간이 중요하다면 ZGC를 시도해 보자.
레거시 시스템을 물려받아서 하드웨어와 소프트웨어 시스템에서 운영해야 한다면 메모리 용량에 따라 선택하자. 힙 메모리가 4GB에서 6GB 이하면 CMS 가 괜찮을 것이고, 그보다 많다면 G1을 시도하자.
최대 100MB 정도의 작은 데이터를 다루는 애플리케이션이라면 시리얼 컬렉터.
애플리케이션이 단일 프로세서만 사용하고 일시 정지 시간 관련 제약이 없다면 시리얼 컬렉터.
애플리케이션의 최대 성능이 가장 중요하고, 지연 시간 관련 제약이 없거나 1초 이상의 지연 시간도 허용된다면 가상 머신의 기본 컬렉터나 패러렐 컬렉터.
처리량보다 응답 시간이 중요하고 가비지 컬렉션에 따른 일시 정지가 짧아야 한다면 G1
응답 시간이 매우 중요하면 (세대 구분) ZGC
 
가상 머신과 가비지 컬렉터 로그
자바 가상 머신의 메모리 문제를 다루려면 기본적으로 가상 머신과 가비지 컬렉터가 기록한 로그를 읽고 분석할 줄 알아야 한다.
Java 9부터 -Xlog 옵션을 사용하면 JVM과 GC 로그를 설정할 수 있다. -Xlog 매개 변수로 모든 핫스팟 기능의 로그를 설정할 수 있게 되었고, 이 매개 변수 자체의 기능 역시 늘었다.
 
기본적인 -Xlog 사용법
- Xlog:<출력 대상>:<출력 수준>:<출력 태그>:<파일 경로>:<롤링 옵션>
<출력 대상> → stdout, stderr, file=<파일 경로> 등
<출력 수준> → trace, debug, info, warning, error
<출력 태그> → gc, heap, safepoint, classload, jit 등
<파일 경로> → 로그를 저장할 파일 경로 지정
<롤링 옵션> → 파일 크기 및 개수 제한 (filecount=10, filesize=10MB 등)
 
GC 로그를 기록하는 -Xlog 예제
java -Xlog:gc=info:file=gc.log:time,uptime,level,tags
 
gc=info → GC 관련 로그를 INFO 레벨로 출력
file=gc.log → gc.log 파일에 기록
time, uptime, level, tags → 로그에 시간, 실행 시간, 레벨, 태그 포함
 
다양한 GC 로그 설정 예제
GC 이벤트만 로깅
java -Xlog:gc GCTest
기본 정보를 보려면 -Xlog:gc를 사용한다.
java -Xlog:gc=debug GCTest
debug 수준의 GC 이벤트를 표준 출력으로 기록
java -Xlog:gc* GCTest
gc 태그의 모든 하위 프로세스를 포함한 상세 정보
가비지 컬렉션 전후로 가용한 힙과 메서드 영역의 용량 변화를 확인
java -Xlog:gc+heap=debug GCTest
가비지 컬렉션 중 사용자 스레드의 동시 실행 시간과 일시 정지 시간을 확인
java -Xlog:safepoint GCTest
GC 및 메모리 관련 로그를 파일로 저장
java -Xlog:gc*,heap=info:file=gc.log:time,level,tags
GC와 Heap 관련 INFO 로그를 gc.log 파일에 기록
 
회수 후 남은 객체들의 나이 분포 확인
java -Xlog:gc+age=trace GCTest
 
JVM 내부 동작도 포함하여 상세 로그 기록
java -Xlog:gc*,safepoint,heap,metaspace=debug:file=jvm.log
GC, Safepoint, Heap, Metaspace 관련 DEBUG 로그를 jvm.log 파일에 기록
 
로그 파일 크기 제한 (10MB, 최대 5개 파일 유지)
java -Xlog:gc=info:file=gc.log:time,uptime,level,tags:filecount=5,filesize=10MB
gc.log 파일 크기를 최대 10MB로 설정, 최대 5개까지 유지
 
 
 
 
실전 : 메모리 할당과 회수 전략

자바 시스템의 자동 메모리 관리의 핵심 목표는 객체의 메모리를 자동으로 할당하고, 사용이 끝난 메모리를 자동으로 회수하는 것이다. 객체의 메모리 할당은 힙에서 이루어지며, 전통적인 세대별 설계에서는 새로 생성된 객체가 주로 신세대(Young Generation)에 할당된다.
하지만 객체의 할당 방식은 고정되지 않는다. 자바 가상 머신(JVM) 명세에서는 객체 생성과 저장 방식을 명확히 정의하지 않으며, 실제 동작 방식은 사용하는 가비지 컬렉터(GC)와 JVM 메모리 설정에 따라 달라질 수 있다.
 
1. 객체는 먼저 에덴에 할당된다.
객체는 먼저 에덴(Eden) 영역에 할당되며, 에덴의 공간이 부족해지면 마이너 GC(Minor GC)가 실행된다.
또한, 핫스팟 가상 머신(HotSpot JVM)의 -Xlog:gc* 옵션을 사용하면 가비지 컬렉션(GC) 시 메모리 회수 로그를 출력하며, 프로세스 종료 시 각 메모리 영역의 할당 상태도 확인할 수 있다. 실전에서는 GC 로그를 파일로 저장하여 전문 분석 도구를 활용해 분석하기도 한다.
 
2. 큰 객체는 곧바로 구세대에 할당된다.
큰 객체는 곧바로 구세대(Old Generation)에 할당된다. 여기서 큰 객체는 연속된 메모리 공간을 필요로 하는 자바 객체로, 매우 긴 문자열이나 원소가 많은 배열이 대표적인 예이다.
가상 머신에서 큰 객체의 등장은 바람직하지 않으며, 사라질 큰 객체들이 대량으로 생성되는 상황은 더욱 문제가 된다. 이러한 상황은 여유 공간이 많음에도 가비지 컬렉션(GC)을 자주 발생시키는 원인이 되기 때문이다.
큰 객체를 위한 연속된 공간을 확보하기 위해 다른 객체들을 이동해야 하므로 심각한 메모리 복사 오버헤드를 초래한다. 이 문제를 해결하기 위해 -XX:PretenureSizeThreshold 매개변수를 설정하면, 설정값보다 큰 객체를 곧바로 구세대에 할당하게 되어, 에덴과 두 생존자 공간 사이의 대규모 복사를 줄이는 데 기여한다.
-XX:PretenureSizeThreshold 매개 변수는 시리얼과 파뉴 신세대 컬렉터에만 적용된다. PS 컬렉터와 다른 컬렉터들은 이 매개변수를 지원하지 않는다. 
 
3. 나이가 차면 구세대로 옮겨진다.
핫스팟 가상 머신의 가비지 컬렉터는 힙 메모리 관리를 위해 세대 단위 컬렉션을 활용한다. 메모리를 청소할 때는 어떤 새로 생성된 객체를 신세대(Young Generation)에 남기고, 어떤 생존 객체를 구세대(Old Generation)로 옮길지를 결정해야 한다. 이를 위해 각 객체의 객체 헤더에 세대 나이 카운터가 포함되어 있다.
객체는 주로 에덴(Eden)에서 태어나며, 초기 나이는 0이다. 첫 번째 마이너 GC(Minor GC)에서 살아남은 객체는 생존자 공간(Survivor Space)으로 이동하고 나이가 1로 증가한다. 이후 생존자 공간에서 마이너 GC를 겪을 때마다 나이가 1씩 증가하며, 특정 나이에 도달하면 구세대로 승격된다.
구세대로 승격되는 나이는 -XX:MaxTenuringThreshold 매개변수로 설정할 수 있으며, 기본값은 가비지 컬렉터의 종류와 JDK 버전에 따라 달라진다.
-XX:TargetSurvivorRatio 매개변수를 지정하면 나이 상관없이 생존자 공간이 지정한 비율 이상 차면 살아남은 객체들을 구세대로 승격시킨다. 
 
공간이 비좁으면 강제로 승격시킨다.
다양한 프로그램의 메모리 사용 패턴에 더 정밀하게 대응하기 위해 핫스팟 가상 머신은 나이가 -XX::MaxTenuringThreshold보다 적어도 구세대로 승격시키기도 한다. '생존자 공간 점유율'이 조건이며, 기본값은 50%라서 생존 객체 전체의 크기 총합이 생존자 공간의 절반을 넘어서면 모든 객체를 구세대로 옮긴다.
