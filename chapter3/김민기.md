# 3. 가비지 컬렉터와 메모리 할당 전략 part 1

가비지 컬렉터는 자바 이전에 개발된 기술로 리스프의 존 맥카시는 가바지 컬렉션이 처리해야 하는 문제 세 가지를 생각해 냈다.

1. 어떤 메모리를 회수해야 하나?
2. 언제 회수해야 할까?
3. 어떻게 회수해야 할까?

자바 메모리를 구성하는 **다양한 런타임 영역, 프로그램 카운터, 가상 머신 스택, 네이티브 메서드 스택**은 스레드와 함께 생성되고 소멸된다. 또한 메서드에 진입하고 빠져나올 땐 스택 메모리에 스택 프레임을 `push`하고 `pop` 한다. 아무튼 이 영역의 메모리 할당과 회수는 결정적이라 어떻게 회수할지 고민하지 않아도 된다. 메서드가 끝나거나 스레드가 종료되면 자연스레 회수된다.

반면, **자바 힙과 메서드 영역**은 불확실한게 많다. 같은 인터페이스라 해도 구현한 클래스마다 요구하는 메모리 크기가 다를 수 있다. 하나의 메서드에서도 어떤 조건 분기를 실행하느냐에 따라 메모리 요구량이 달라질 수 있다. 프로그램이 어떤 객체를 생성할지, 얼마나 많이 만들지는 오직 런타임에만 알 수 있다. 그래서 이 메모리 영역들의 할당과 회수는 동적으로 이뤄진다. GC는 이런 영역을 관리하는 데 집중한다. 앞으로 내용에서 ‘메모리 할당과 회수’라고 할때 ‘메모리’는 이 영역들(**자바 힙과 메서드 영역**)만 지칭한다.

## 참조 카운팅 알고리즘

많은 교재에서 객체가 살아 있는지 판단하는 알고리즘을 다음과 같이 설명한다.

1. 객체를 가리키는 참조 카운터(reference counter)를 추가한다. 참조하는 곳이 하나 늘어날 때마다 카운터 값을 1씩 증가시킨다.
2. 참조하는 곳이 하나 사라질 때마다 카운터 값을 1씩 감소시킨다.
3. 카운터 값이 0이 된 객체는 더는 사용될 수 없다.

보통 참조 카운터에 대해 묻는다면 이렇게 답변한다 “*참조 카운팅 알고리즘은 횟수를 세기 위해 약간의 메모리를 추가로 사용하지만 원리가 간단하고 판단에 드는 에너지도 적다. 그래서 대다수 상황에서 좋은 알고리즘이며 실제로도 많이 쓰인다. 다양한 언어에서도 사용….*“

하지만 JVM에서는 참조 카운팅을 쓰지 않는다. 간결해도 고려할 특이 상황이 적지 않고, 모든 상황에서 문제없이 동작하게 하려면 계산할 게 많다. 예를 들어 순환 참조(circular reference) 문제를 풀기 어렵다.

```java
public class ReferenceCountingGC {
	public Object instance = null;
	private static final int _1MB = 1024*1024;
	// 메모리를 많이 차지하여 GC 로그에서 회수 여부를 명확히 알아볼 수 있게 한다.
	private byte[] bigSize = new byte[2* _1MB];
	
	public static void testGC() {
		// 두 객체 생성
		ReferenceCountingGC objA= new ReferenceCountingGC();
		ReferenceCountingGC objB= new ReferenceCountingGC();
		// 내부 필드로 서로를 참조
		objA.instance = objB;
		objB.instance = objA;
		// 참조 해제
		objA = null;
		objB = null;
		// 이 라인에서 GC가 수행된다면 objA와 objB가 회수될까?
		System.gc();
	}
	
	public static void main(String[] args){
		testGC();
	}
}
```

objA, objB 객체에는 모두 instance 라는 필드가 있고 이 필드들에 값을 할당한 다음 객체의 참조를 해제했다. 그럼 이제부턴 외부에서 이 객체에 접근할 방법이 사라진다. 하지만 서로 참조를 하고 있기때문에 참조카운터는 0이 아니다. 그러므로 참조 카운팅 알고리즘으로는 회수하지 못하는 문제가 발생한다.

### 도달 가능성 분석 알고리즘

주류 프로그래밍 언어들은 모두 객체 생사 판단에 도달 가능성 분석(reachability analysis) 알고리즘을 이용한다. 이 알고리즘의 기본 아이디어는 GC루트라고 하는 루트 객체들을 시작 노드 집합으로 쓰는 것이다. 시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색해 들어간다. 시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색해 들어간다. 탐색 과정에서 만들어지는 경로를 참조 체인(reference chain)이라 한다. 그리고 어떤 객체와 GC루트 사이를 이어 주는 참조 체인이 없다면, 즉 GC 루트로부터 도달 가능한 객체는 더 이상 사용할 수 없는 게 확실해진다.

자바에서 GC루트로 이용할 수 있는 객체는 정해져 있다.

- 가상 머신 스택(스택 프레임의 지역 변수 테이블)에서 참조하는 객체 : 현재 실행중인 메서드에서 쓰는 매개 변수, 지역 변수, 임시 변수 등
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체 : 자바 클래스의 참조 타입 정적 변수
- 메서드 영역에서 상수로 참조되는 객체 : 문자열 테이블 안의 참조
- 자바 가상 머신 내부에서 쓰이는 참조 : 기본 데이터 타입에 해당하는 Class 객체, 일부 상주 예외 객체, 시스템 클래스 로더
- 동기화 락(synchronized) 로 잠겨 있는 모든 객체
- 자바 가성 머신 내부 상황을 반영하는 JMXBean : JVMTI에 등록된 콜백, 로컬 코드 캐시 등

이상의 정해진 GC루트들 외에도 가비지 컬렉터 종류나 현재 회수 중인 메모리 영역에 따라 다른 객체들도 ‘임시로’ 추가될 수 있다. 이렇게 해서 전체 GC 루트 집합이 만들어진다.

### 다시 참조 이야기로

객체의 생사 판단과 ‘참조’는 떼어서 생각할 수 없다. 참조 개수를 세어 판단하는 참조 카운팅 알고리즘이든, 객체까지 이어지는 참조 체인이 존재하는가로 판단하는 도달 가능성 분석 알고리즘이든 마찬가지다. JDK 1.2 전의 자바에서는 참조를 전통적인 의미로 해석했다.

<aside>
💡

참조 타입 데이터에 저장된 값이 다른 메모리 조각의 시작 주소를 뜻한다면, 이 참조 데이터를 해당 메모리 조각이나 객체를 참조한다고 말한다.

</aside>

JDK 1.2부터 참조 개념이 확장되어 참조를 네 가지로 구분하기 시작했다. 강한 참조, 부드러운 참조, 약한 참조, 유령 참조인데 나열순으로 강도가 약해진다.

- 강한 참조(strong reference) : 가장 전통적인 정의의 참조를 뜻한다. Object obj = new Object() 처럼 프로그램 코드에서 참조를 할당하는 걸 말한다. 강한 참조 관계가 남아 있는 객체는 가비지 컬렉터가 절대 회수하지 않는다.
- 부드러운 참조(soft reference) : 유용하지만 필수는 아닌 객체를 표현한다. 부드러운 참조만 남은 객체라면 메모리 오버플로가 나기 직전에 두 번째 회수를 위한 회수 목록에 추가된다. 두 번째 회수에도 메모리가 부족하면 그때 메모리 오버플로 예외를 던진다.
- 약한 참조(weak reference) : 부드러운 참조와 비슷하지만 연결 강도가 더 약하다. 약한 참조뿐인 객체는 다음번 가비지 컬렉션까지만 살아 있다. 가비지 컬렉터가 동작하기 시작하면 메모리가 넉넉해도 약하게 참조된 객체는 모두 회수된다.
- 유령 참조(phantom reference) : 참조 중에 가장 약하다. 유령 참조는 객체 수명에 아무런 영향을 주지 않으며 유령 참조를 통해 객체 인스턴스를 가져오는 것마저 불가능하다. 유령 참조를 거는 유일한 목적은 대상 객체가 회수될 때 알림을 받기 위해서다.
- 파이널 참조(final reference) : 참조 강도는 약한 참조와 유령 참조 사이다. finalize() 메서드를 구현한 객체는 모두 파이널 참조의 대상이 되어 별도의 대기열에 등록된다. 그 다음 해당 객체에 도달할 수 있는 강한 참조, 부드러운 차조, 약한 참조가 모두 없어지면 finalize() 메서드를 호출한다.

### 살았나 죽었나?

도달 가능성 분석 알고리즘이 ‘도달 불가능’으로 판단한 객체라고 해서 반드시 죽어야 하는 건 아니다. 아직 ‘유예’ 단계가 남았다. 확실한 사망 선고를 내리려면 두 번의 표시(marking) 과정을 거쳐야 한다. 도달 가능성 분석으로 GC루트와 연결된 참조 체인을 찾지 못한 객체에는 표시가 이뤄지며 이어서 필터링이 진행된다. 필터링 조건은 종료자(finalizer), 즉 ‘finalize() 메서드를 실행해야 하는 객체인가’ 이다. finalize가 필요 없는 객체거나, 가상 머신이 이미 호출한 경우 모두 실행할 필요 없음으로 처리한다.

finalize 를 실행해야 하는 객체로 판명나면 F큐라는 대기열에 추가된다. 그러면 가상 머신이 나중에 우선순위가 낮은 종료자 스레드를 생성해 F큐에 들어 있는 객체들의 finalize 메서드를 실행한다. 참고로 가상 머신은 이 메서드를 실행만 할 뿐 끝날 때까지 기다리지 않는다. 기다리게되면 너무 오래걸리거나 무한루프에 빠질 때 문제가 되기 때문이다.

### 메서드 영역 회수하기

(핫스팟 가상 머신의 메타스페이스나 영구 세대 같은) 메서드 영역은 가비지 컬렉션 대상이 아니라고 생각하는 사람도 있다. **명세**에 따르면 가비지 컬렉터가 메서드 영역을 반드시 청소해야 하는 건 아니다. 실제로도 메서드 영역 타입 언로딩을 구현하지 않거나 완벽하게 수행하지 않는 가상 머신도 있다. 메서드 영역 가비지 컬렉션은 대체로 ‘비용 효율’이 좋지 않기 때문이다. 일반적인 애플리케이션에서 자바 힙은, 그중 신세대는 가비지 컬렉션 한 번으로 메모리 공간의 70-99%를 회수해 낸다. 반면 메서드 영역은 까다로워서 효율이 훨씬 떨어진다.

메서드 영역의 가비지 컬렉션은 크게 두 가지를 회수한다. 더 이상 사용되지 않는 ‘상수’와 ‘클래스’다. 다 쓴 상수를 회수하는 방법도 자바 힙에서 객체를 회수하는 방법과 비슷하다. 다 쓴 상수인지 판단하는 일은 비교적 간단하지만, 더 이상 쓰이지 않는 ‘클래스’인지 판단하는 조건은 더 까다롭다. 세 조건을 동시에 만족해야 한다.

- 이 클래스의 인스턴스가 모두 회수되었다. 즉 자바 힙에는 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
- 이 클래스를 읽어 들인 클래스 로더가 회수되었다. 이 조건은 OSGi나 JSP 리로딩처럼 세심하게 설계된 대안 클래스 로더 없이는 충족하기 어렵다.
- 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다.

JVM은 세 조건에 부합하는 쓸모없는 클래스들을 회수하도록 허용한다. 다만 허용한다 했지 반드시 회수한다고는 안했다.

## 가비지 컬렉션 알고리즘

가비지 컬렉션 알고리즘을 구현하는 데는 수많은 기법이 활용되며 가상 머신 또는 플랫폼에 따라 차이가 많다. 객체의 생사를 판별하는 방식을 기준으로 가비지 컬렉션 알고리즘을 ‘참조 카운팅 GC’와 ‘추적 GC’로 나눌 수 있다. 이 둘을 ‘직접 가비지 컬렉션’과 ‘간접 가비지 컬렉션’이라 부르기도 한다.

### 세대 단위 컬렉션 이론

상용 가상 머신들이 채택한 가비지 컬렉터는 대부분 세대 단위 컬렉션 이론에 기초해 설계되었다.

1. **약한 세대 가설 : 대다수 객체는 일찍 죽는다.**
2. **강한 세대 가설 : 가비지 컬렉션 과정에서 살아남은 회수가 늘어날수록 더 오래 살 가능성이 커진다.**

이 두 가정이 합쳐져 널리 알려진 가비지 컬렉터들에 일관된 설계 원칙을 제공한다. 자바 힙을 몇 개의 영역으로 나누고 객체들을 나이(가비지 컬렉션에서 살아남은 횟수)에 따라 각기 다른 영역에 할당하는 것이다.

영역 안의 객체 대부분이 곧바로 죽을 운명이라면, 그 객체들을 몰아놓고 (신 세대)살아남는 소수의 객체를 유지하는 방법에 집중하는 편이 유리하다. 확실히 적은 비용으로 대량의 메모리를 확보할 수 있다. 한 번 살아남은 객체는 통계적으로 잘 죽지 않으니 다른 영역에 따로 모아 두고, 가상 머신이 그 영역을 회수하는 빈도를 줄이는 것이다. 이러면 가비지 컬렉션에 드는 전체 시간도 줄고 메모리 공간도 효율적으로 이용할 수 있다. (구 세대?)

자바 힙을 여러 영역으로 나누면 가비지 컬렉터는 한 번에 하나 또는 몇 개 영역만 선택해 회수할 수 있는데 이를 기준으로 마이너 GC, 메이저 GC, 전체 GC 식으로 부르곤 한다. 각 영역에 담긴 객체들의 생존 특성에 따라 마크-스윕(mark-sweep: 표시 후 쓸기), 마크-카피(mark-copy: 표시 후 복사), 마크-컴팩트(mark-compact: 표시 후 모으기) 등 가비지 컬렉션 알고리즘을 구분해 적용한다.

세대 단위 컬렉션 이론을 가상 머신에 적용한 설계자들은 자바 힙을 최소 두 개 영역으로 나눈다. 신, 구 세대다. 신세대는 가비지 컬렉션 때마다 다수의 객체가 죽고 살아남은 소수만 구세대로 승격된다. 핫 스팟의 소스 코드 중 `DefNewGeneration`, `PerNewGeneration` 처럼 뒤에 **Generation**이 붙는 구현 코드가 핫스팟의 세대별 가비지 컬렉터 프레임워크다.

객체들은 단독으로 존재하는 게 아니기 때문에 다른 세대에 존재하는 객체들을 참조하는 상황이 자연스럽게 나타난다. 신세대에서만 가비지 컬렉션을 하고싶어도(마이너 GC), 신세대에 속하지만 구세대에서 참조 중인 객체도 충분히 있을 수 있다. 따라서 살아남을 객체를 찾으려면 도달 가능성을 분석할 때 고정된 GC 루트들뿐 아니라 구세대 객체까지 모두 탐색해야 결과를 신뢰할 수 있다. 반대로 구세대 전체의 객체들까지 탐색해야 한다면 성능면에서 부담이 클 것이다. 그래서 세 번째 경험 규칙을 추가해야 한다.

1. **세대 간 참조 가설 : 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.**

세 번째 가설은 사실 처음 두 가설로부터 논리적으로 유추할 수 있는 암묵적인 추론이다. 상호 참조 관계의 두 객채는 삶과 죽음을 함께하는 경향이 있다. 예를 들어 신세대 객체가 세대 간 참조를 가지고 있다고 해 보자. 구세대 객체는 잘 죽지않는다. 따라서 가비지 컬렉션을 거쳐도 신세대 객체는 세대 간 참조 덕에 구세대로 승격될 것이다. 그럼 세대 간 참조는 자연스럽게 사라진다. 이 가설에 따르면 세대 간 참조의 수는 적기 때문에 구세대 전체를 검토하는건 비효율이고, 객체와 세대 간 참조가 있는지 관리할 필요가 없다. 신세대에 기억 집합이라는 전역 데이터 구조를 하나 두면 된다.

이 구조를 통해 구세대를 작은 조각 몇 개로 나누고, 그중 어느 조각에 세대 간 참조가 있는지 기록해 관리하는 것이다. 마이너 GC가 수행되면 세대 간 참조를 포함하는 작은 메모리 블록 안의 객체들만 GC 루트에 추가된다. 이 방식은 객체 사이에서의 참조 관계 변화를 정확히 관리해야 한다. 런타임에 할 일이 늘어나지만 구세대 전체를 확인하는 비용보다 저렴하다.

### 용어 정리

- 부분 GC : 자바 힙의 일부만 회수하는 가비지 컬렉션을 말하며 다음과 같이 세분화된다.
    - 마이너(신세대) GC : 신세대만 대상으로 하는 가비지 컬렉션
    - 메이저 (구세대) GC : 구세대만 대상으로 하는 가비지 컬렉션, CMS 컬렉터만 구세대를 따로 회수한다. 맥락에 따라 구세대 회수인지, 힙 전체 회수인지 구분해야 한다.
    - 혼합 GC : 신세대 전체와 구세대 일부를 대상으로 하는 가비지 컬렉션, G1이 이렇게 동작한다.
- 전체 GC : 자바 힙 전체와 메서드 영역까지 모두를 대상으로 하는 가비지 컬렉션

### 마크-스윕 알고리즘

리스프의 아버지 존 맥카시가 1960년에 제안한 최초이자 기본 GC 알고리즘이다. 작업을 표시(mark)와 쓸기(sweep)라는 두 단계로 나눠 진행한다. 먼저 회수할 객체들에 모두 표시한 다음, 표시된 객체들을 쓸어 담는 식이다. 반대로 살릴 객체에 표시하고 표시되지 않은 객체들을 회수하기도 한다.

기존 알고리즘인 이유는 뒤이어 나온 컬렉션 알고리즘들 대부분이 이를 기초로 그 단점을 보완하는 형태로 발전했기 때문이다. 이 알고리즘의 큰 단점은 두 가지다.

1. 실행 효율이 일정하지 않음. 자바 힙이 다량의 객체로 가득 차 있고 그 대부분이 회수 대상이라면 표시하는 일도, 회수하는 일도 모두 커진다. 즉 객체가 많아질수록 표시하고 쓸어 담는 작업의 효율이 떨어진다.
2. 메모리 파편화가 심함. 가비지 컬렉터가 쓸고 간 자리는 불연속적인 메모리 파편이 만들어진다. 파편화가 너무 심하면 프로그램이 큰 객체를 만드려 할 때 충분한 크기의 연속된 메모리를 찾기 점점 어려워지고 그 결과 다른 가비지 컬렉션을 유발한다.



### 마크-카피 알고리즘

간단히 카피 알고리즘이라고도 하며 회수할 객체가 많아질수록 효율이 떨어지는 마크-스윕 알고리즘의 문제를 해결하기 위해 1969년 로버트 페니첼은 세미스페이스 복사라는 가비지 컬렉션 알고리즘을 제안한다. 가용 메모리를 똑같은 크기의 두 블록으로 나눠 한 번에 한 블록만 사용한다. 한쪽이 가득 차면 살아남은 객체들만 다른 블록에 복사하고 기존 블록을 한 번에 청소한다.

대다수 객체가 살아남으면 메모리 복사에 상당한 시간을 사용하는 반면, 대다수가 회수되면 소수의 객체만 복사하면 된다. 더욱이 복사 과정에서 객체들이 메모리의 한쪽 끝에서부터 차곡차곡 쌓이기에 메모리 파편화 문제를 해결할 수 있다. 구현하기 쉽고 실행 효율도 좋지만 가용 메모리를 절반으로 줄여 낭비가 심하다.


대부분의 상용 가상 머신은 신세대에 이 알고리즘을 활용한다. IBM의 연구에서 신세대 객체 중 90%가 첫 GC에서 살아남지 못한다. 신세대용 메모리 영역을 1:1로 나눌 필요가 없다는 결론이다.

1989년 앤드류 아펠은 이 특성을 반영해 더 최적화된 전략을 제안했다. 아펠 스타일 컬렉션이라고 부르며 시리얼과 파뉴 같은 핫스팟 가상 머신의 신세대 컬렉터는 모두 신세대 메모리의 레이아웃을 이 전략에 부합하게 구성한다. 아펠 스타일 컬렉션 방식을 구체적으로 보면 신세대를 하나의 큰 에덴 공간과 두 개의 작은 생존자 공간으로 나눈다. 그리고 메모리를 할당할 때는 생존자 공간 중 하나와 에덴만 사용한다. 가비지 컬렉션이 시작되면 에덴과 생존자 공간에서 살아남은 객체들을 나머지 생존자 공간으로 하나씩 복사한 후 에덴과 이전 생존자 공간을 곧바로 비운다.

핫스팟 가상 머신에서 에덴과 생존자 공간의 비율은 기본적으로 8:1이다. 즉, 신세대에 할당된 전체 메모리 중 90%를 활용한다. (에덴 80% + 생존자 공간 중 하나 10%) 낭비되는 공간은 단 10% 이다.

98%의 객체가 회수된다는 데이터는 물론 ‘일반적인 상황’에서 측정된 결과라서 10% 넘게 살아남는 일이 절대 없다고 단정할 수 없다. 그래서 아펠 스타일 컬렉션에서도 10%가 넘는 특이 케이스에 대처하기 위한 설계가 하나 추가되어 있다. 메모리 할당 보증이라는 메커니즘으로, 마이너 GC에서 살아남은 객체를 생존자 공간이 다 수용하지 못할 경우 다른 메모리 영역을 활용해 메모리 할당을 보증하는 것이다.


### 마크-컴팩트 알고리즘

위 마크-카피 알고리즘은 객체 생존율이 높을수록 복사할 게 많아져서 효율이 나빠진다. 더구나 공간을 50%나 낭비하기 싫다면 할당 보증용 공간을 따로 마련하여 대다수 객체가 살아남는 극단적 상황에 대처해야 한다. 그래서 구세대에는 적합하지 않다.

표시 단계는 마크-스윕과 같다. 하지만 다음 컴팩트 단계에서 (회수 대상 객체들을 곧바로 쓸어 담는 대신) 생존한 모든 객체를 메모리 영역의 한쪽 끝으로 모은 다음, 나머지 공간을 한번에 비운다.


마크-스윕가 핵심적인 차이는 **메모리 이동**이 일어난다는 점이다. 그런데 가비지 컬렉션 후 살아남은 객체를 이동할지는 양날의 검 같은 결정이다. 구세대에선 회수 마다 살아남는 객체가 상당히 많을 것이라 이동시킨 후 이동된 객체들을 가리키던 참조들을 모두 갱신하기는 부담되는 작업이다. 더욱이 스탑더월드 상태에서 진행해야 하므로 신중해야 한다.

하지만 객체를 전혀 이동시키지 않는다면 힙이 파편화되어 접근 방식이 복잡해진다. 그래서 할당 문제는 ‘파편화 없는 할당 연결 리스트(partition free allocation linked list)’로 해결할 수 있다. 메모리 읽기는 프로그램에서 가장 빈번한 동작이다. 이 동작의 부담이 커지면 성능이 눈에 띄게 느려질 것이다.

두 관점에서 객체를 이동시킬 때와 아닐 때 모두 단점이 있다. 이동시키면 회수 작업이 복잡해지고, 이동시키지 않으면 할당 작업이 복잡해진다. GC의 스탑더월드 시간을 기준으로 보면 이동시키지 않는 편이 유리하다. 하지만 처리량 기준이라면 객체를 이동시키는 편이 효율적이다.

객체를 이동시키지 않으면 컬렉터의 효율이 높아진다. 하지만 메모리를 할당하고 접근하는 빈도가 가비지 컬렉션 수행 빈도보다 훨씬 많으므로 할당과 접근 효율이 떨어지면 전체 처리량은 나빠진다.