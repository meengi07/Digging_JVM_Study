## 자바

- 언어뿐 아니라 여러 가지 소프트웨어와 명세로 구성된 기술 시스템
- 하드웨어 플랫폼이라는 족쇄를 제거
- 상당히 안전한 메모리 관리 시스템을 갖춘 덕에 메모리 누수 문제와 엉뚱한 메모리를 가리키는 문제 대부분을 피할 수 있다.
    - 어떻게 구성이 되었길래 상당히 안전한 메모리 관리 시스템을 갖춘거지?
    - 엉뚱한 메모리를 가리키는 문제가 그래도 있는가? (대부분이라길래..)
        - 자동 메모리 관리
            - Java는 개발자가 메모리 할당 해제를 직접 관리X
            - 대신 JVM이 GC를 통해 더 이상 사용되지 않는 객체 자동 탐지, 메모리 해제
            - GC 동작 방식
                - 참조 카운팅(Reference Counting) 기반 탐색: JVM은 객체가 더 이상 어떤 참조 변수도 가리키지 않을 때 가비지로 간주
                - JVM은 힙 메모리를 지속적으로 스캔, 사용되지 않는 객체들 제거
                - 순환 참조가 발생 → GC가 인식하고 수집 가능
            - 장점
                - 개발자가 직접 free() 호출과 같은 메모리 해제 작업 필요X
                - 포인터를 잘못 해제해서 dangling pointer(엉뚱 메모리 가리키기) 발생X
        - 강력한 타입 시스템, NPE 방지
            - 컴파일 타임에 타입 검사 → 잘못된 메모리 접근 방지
            - 다른 타입으로 잘못된 변수 할당 컴파일러가 사전 감지
            - 포인터 개념 대신 객체 참조를 사용 → 잘못된 메모리 주소 참조가 원천적으로 발생하지 않음
        - 직접 메모리 주소를 다루지 않음
            - 모든 메모리 접근은 객체의 참조 변수를 통해서만 이뤄짐
            - 임의로 메모리 주소를 조작할 수 없음
        - 스택과 힙 메모리 분리
            - 스택: 메서드 호출 시 지역 변수 저장, 메서드 종료되면 자동으로 메모리가 해제
            - 힙: 객체가 동적으로 할당되는 공간, 가비지 컬렉터가 관리
            - 장점
                - 지역 변수는 스택에서 자동으로 관리되므로 스택 오버플로우 외의 메모리 문제는 거의 발생 X
                - 객체는 힙에서 가비지 컬렉터가 수집하므로 dangling pointer 문제 방지
- 런타임에 핫 코드 감지, 컴파일하고 최적화하여 최상의 성능을 내도록 해줌
    - 핫 코드 감지는 어떻게 하는거지?
    - 컴파일 시점에 어떻게 최적화 하는거지?
        - 메서드 호출 횟수, 루프 반복 횟수, 런타임 프로파일링 데이터를 바탕으로 이뤄짐
        - JIT 컴파일러는 인라이닝, 루프 전개, 동적 타입 분석, 탈출 분석 등 다양한 최적화 기법을 사용해서 성능 극대화
        - 런타임 정보를 적극 활용하여 더 높은 성능을 제공

> 핫 코드: 빈번하게 실행되어 전체 성능에 영향을 크게 주는 코드
> 

### 자바 기술 시스템

- JVM 위에서 동작하는 언어(코틀린, 그루비 등..)
- JVM 구현 (다양한 하드웨어 플랫폼용)
- 클래스 파일 포맷
- 자바 클래스 라이브러리 API (자바 표준 API)
- 다른 기업과 오픈 소스 커뮤니티에서 제공하는 서드 파티 클래스 라이브러리

> Language + JVM + Java Class Library = JDK
JDK는 자바 프로그램 개발에 필요한 최소 환경
> 

![JDK 7 시절 그림](/image/wj_1_1.png)

JDK 7 시절 그림

- 셰넌도어 가비지 컬렉터(레드햇) vs ZGC(오라클)
- 메서드 핸들이란?
    - 동적 메서드 호출을 지원하면서도 리플렉션보다 빠르고 안전
    - 람다 표현식, 동적 바이트코드와 연계되어 고성능 동적 메서드 호출 가능
    - 리플렉션보다 빠름
    - 런타임 오버헤드 낮음
    - 컴파일 시 타입 검증 가능
    - invokedynamic 바이트코드와 밀접한 연관
- JDK 21 가상 스레드 도입
    - 기존에는 커널 스레드에 의존하던 한계가 있었다.
        - 그렇다면 커널 스레드를 기반으로한 구현은 어떻게 되어 있을까?
        - 가상 스레드는 어떻게 구현된걸까?
- 가상 머신 기술 공부 목적으로는 OpenJ9을 뜯어보면 재밌을거 같다.
- 자바 가상 머신 명세 한번 찾아보자!

![스크린샷 2025-01-24 오전 1.04.43.png](/image/wj_1_2.png)

- 생각보다 Java 라는 시스템 자체가 MSA 에는 어울리지 않는 시스템
    - 고가용성 서비스로 인해 빠르게 실행되고 빠른 성능을 내는게 중요
        - 하지만 자바는 구동 시간이 길고 최고 성능을 내기까지 예열이 필요
        - 최근 JDK에서 애플리케이션 클래스 데이터 공유(AppCDS)와 노옵(no-op) 가비지 컬렉터인 엡실론 등의 기술이 포함
        - APPCDS는 로딩한 클래스 정보를 캐싱 (다음번 구동 시간 줄이기)
        - 앱실론은 메모리를 할당만 해 줄 뿐 회수 X, 간단한 작업을 빠르게 처리 후 즉시 종료하는 앱에 적절
- 스프링 프레임워크 공식 예제 펫클리닉 기반으로 여러가지 테스트 해볼 수 있을 것 같음
    - JIT가 탑재된 그랄VM CE vs 오라클 그랄VM 네이티브 이미지 비교와 같은 일들
- 그랄VM의 일부인 서브스트레이트 VM 한번 찾아보기!
- JDK 9 이후에 자바 언어 수준의 컴파일러 인터페이스인 JVMCI 가 도입
    - 가상 머신 외부에서 JIT 컴파일러를 추가하거나 교체할 수 있음
    - 가상 머신의 더 깊은 내부가 열려서 핫스팟 코드를 침범하지 않고도 기능 확장, 수정 가능
    - 그랄VM이 대표적인 예시임

## JDK 직접 빌드해보기

OpenJDK를 사용하여!

https://jdk.java.net/java-se-ri/17

```bash
.
└── openJDK
    ├── ADDITIONAL_LICENSE_INFO
    ├── ASSEMBLY_EXCEPTION
    ├── CONTRIBUTING.md
    ├── LICENSE
    ├── Makefile
    ├── README.md
    ├── bin
    ├── configure
    ├── doc
    ├── make
    ├── src
    └── test
```

- 타겟: Mac OS Apple silicon
- 권장 사양
    - CPU: 2 ~ 4Core
    - Memory: 2 ~ 4GB(CPU 코어가 많을수록 메모리를 더 소비함)
    - 디스크 여유 공간: 6GB
- 핫스팟 가상 머신은 최적화 수준(Product, FastDebug, SlowDebug)에 따라 중간 파일을 반복해서 생성할 수 도 있음
- 이 개발자 도구에는 OpenJDK를 컴파일할 Clang 컴파일러와 Makefile에서 쓰는 기타 외부 도구들이 포함되어 있음
- 맥: XCode SDK로부터 Clang 컴파일러를 얻어옴 (Clang 3.5이상 버전이 필요함)
- 컴파일에 필요한 서드 파티 라이브러리 및 빌드 도구
    - Fontconfig: 폰트 설정 라이브러리(폰트가 왜 필요하지?)
    - FreeType: 폰트 렌더링 라이브러리
    - CUPS
    - X11: X 윈도 시스템
    - ALSA
    - libffi: 포터블 외부 함수 인터페이스(foreign function interface) 라이브러리
    - Autoconf: M4 매크로의 확장 패키지
- Mac OS Apple silicon 이므로 도커에 ubuntu 를 설치하여 진행

```bash
$ sudo apt-get install libfontconfig1-dev
$ sudo apt-get install libfreetype6-dev
$ sudo apt-get install libcups2-dev
$ sudo apt-get install libx11-dev libxext-dev libxrender-dev libxrandr-dev libxtst-dev libxft-dev
$ sudo apt-get install libasound2-dev
$ sudo apt-get install libffi-dev
$ sudo apt-get install autoconf
```

- JDK 구성 요소 중 일부는 c c++ 로 작성되어 있지만, 그보다 많은 코드가 자바 언어로 구현되어 있음
    - 자바 코드들을 컴파일하려면 또 다른 JDK가 설치되어 있어야 함 → 이때 쓰이는걸 부트 JDK
    - 직전 메이저 버전이 원칙이지만, 같은 버전을 사용해도 무방하다.