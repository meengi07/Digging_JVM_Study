# 5장 사례 분석

# 흥미있는 사례만 정리해보자

- HashMap<Long, Long>
    - 키와 값에 해당하는 long 정수 2개는 사용자에게 의미있는 데이터 (16바이트)
    - long 데이터 각각은 java.lang.Long 객체로 래핑
    - Long 타입은 8바이트의 마크워드, 8바이트의 클래스 포인터, 데이터 공간 8바이트의 long 변수(총 24바이트)
    - 위 구조에서 Long 객체는 Map.Entry 에 저장됨 16바이트의 객체 헤더, 8바이트의 next 필드, 4바이트의 해시 필드, 패딩 4바이트 (총 32바이트)
    - HashMap에서는 8바이트 참조로 Map.Entry를 가리킴
    - 결과적으로 long 정수 두개를 담는 데 쓰이는 메모리는 (Long(24바이트)x2) + Entry(32바이트) + HashMap의 참조(8바이트)로 총 88바이트가 쓰인다. 유효 데이터의 비율은 18% (16/88)

- JDK 버전 업그레이드에 따른 성능 변화
    - JDK11 대비 17은 10% 개선
- 컴파일 시간 최적화
    - 컴파일 시간과 가비지 컬렉션 시간이 시간을 크게 잡아먹음
    - 컴파일 시간은 핫 코드를 JIT컴파일러가 컴파일하는 데 쓰는 시간을 의미
    - JDK1.2 이후에 핫스팟 가상 머신은 JIT컴파일러를 제공, 일정 횟수 이상 호출되는 자바 메서드를 핫 코드로 분류하여 JIT컴파일러에 넘겨 해당 코드를 런타임에 네이티브 코드로 변환해 수행속도를 개선
    - 일반적으로 메모리 누수등의 문제가 없는 한 오래 실행할수록 코드가 꾸준히 최적화되어 점점 빨라짐
    - 하지만 동적 컴파일은 실행 시간에 영향을 줌, 사용자 프로그램과 동시에 동작해서 컴퓨팅 자원을 공유하기 때문에 느려질 수 있음

- 메모리 설정 최적화
    - 가비지 컬렉션 시간 중 가장 많이 성능에 영향을 주는건 구세대를 포함하는 전체GC


# 따로 알아보자

현 회사의 스펙 / 프로젝트마다 다름

### OS

- Rocky8.9-x86_64
- CentOS7.9.2009-x86_64

### Spec

- 서버 자원

    | type | 코어 | 메모리 |
    | --- | --- | --- |
    | web | 2 | 4 |
    | was | 8 | 8 |
    | was | 4 | 8 |
- JDK, SpringBoot
    - JDK : 8
    - SpringBoot : 1.5.22
    - GC : Parallel

# 공부하면 좋은 것

- 객체 타입별 메모리
    - primitive (원시 타입)

      원시 타입(primitive type)은 객체 헤더 없이 순수하게 데이터만 저장, 가장 효율적인 메모리 사용

      | 타입 | 크기 (바이트) |
      | --- | --- |
      | `boolean` | 1 |
      | `byte` | 1 |
      | `char` | 2 |
      | `short` | 2 |
      | `int` | 4 |
      | `float` | 4 |
      | `long` | 8 |
      | `double` | 8 |
    - wrapper (Boxed Type)
        - Wrapper 클래스(`Integer`, `Long`, `Double` 등)는 원시 타입을 객체로 감싸는 구조로, 추가적인 오버헤드가 발생
        - 객체는 **기본적으로 16바이트의 객체 헤더**를 포함하며, 그 외에 클래스 포인터, 데이터 필드 등이 추가
        - **원시 타입보다 2~3배 이상 메모리를 차지**하며, 박싱된 객체는 추가적인 참조(포인터) 오버헤드

      | 타입 | 크기 (바이트) | 구성 요소 |
              | --- | --- | --- |
      | `Boolean` | 16 | 객체 헤더(16) + 내부 boolean(1, 패딩 7) |
      | `Byte` | 16 | 객체 헤더(16) + 내부 byte(1, 패딩 7) |
      | `Character` | 16 | 객체 헤더(16) + 내부 char(2, 패딩 6) |
      | `Short` | 16 | 객체 헤더(16) + 내부 short(2, 패딩 6) |
      | `Integer` | 16 | 객체 헤더(16) + 내부 int(4) + 패딩 4 |
      | `Float` | 16 | 객체 헤더(16) + 내부 float(4) + 패딩 4 |
      | `Long` | 24 | 객체 헤더(16) + 내부 long(8) |
      | `Double` | 24 | 객체 헤더(16) + 내부 double(8) |
    - Array (배열)
        - 배열은 객체이므로 객체 헤더(16바이트)를 포함하며, 원소 개수에 따라 크기가 결정
        - **배열은 8바이트 단위 정렬(Padding)이 필요**하며, 작은 배열일수록 오버헤드 비율이 큼

      | 배열 타입 | 크기 계산법 |
              | --- | --- |
      | `int[]` | `16 + (4 * length)` |
      | `double[]` | `16 + (8 * length)` |
      | `boolean[]` | `16 + ceil(length / 8)` (1비트 단위 저장) |
      | `Object[]` | `16 + (8 * length)` (객체 참조는 8바이트) |

    - object

      사용자 정의 객체는 **기본적으로 16바이트의 객체 헤더**를 가지며, 필드 크기에 따라 메모리 크기가 결정됨.

        ```java
        
        class Example {
            int a;    // 4바이트
            double b; // 8바이트
        }
        
        ```

      위 객체의 메모리 사용량:

        - 객체 헤더: 16바이트
        - `int a`: 4바이트
        - 패딩: 4바이트 (JVM은 8바이트 단위 정렬을 수행)
        - `double b`: 8바이트
        - **총합: 32바이트**

      💡 **필드 정렬(Padding)으로 인해 예상보다 메모리 사용량이 클 수 있음.**

    - collection framework

      컬렉션(`List`, `Set`, `Map` 등)은 내부적으로 객체와 배열을 사용하므로, 원시 타입보다 메모리 사용량이 훨씬 많음.

      ### `ArrayList<E>`

        - 기본적으로 내부 `Object[]` 배열을 유지
        - 최소 크기: 24바이트 (헤더 16 + 참조 필드 8)
        - 원소는 `Object[]` 배열에 저장되므로, `8 * 원소 개수`만큼 추가 메모리 사용
        - 원소가 `Integer` 같은 래퍼 객체라면 `Integer(16바이트) * 개수` 추가

      ### `LinkedList<E>`

        - 각 노드는 `Node<E>` 객체로 구성됨
        - `Node<E>` 구조:
            - 객체 헤더(16) + 데이터 참조(8) + `next` 참조(8) + `prev` 참조(8)
            - **총 40바이트** + 원소의 크기

      ### `HashMap<K, V>`

        - `HashMap`은 내부적으로 **배열 + 연결 리스트(또는 트리) 구조**를 사용
        - 기본적으로 **배열(`Node<K, V>[]`)이 16바이트 단위로 존재**
        - 각 `Node<K, V>`는 32바이트 + key/value 객체의 크기
        - `HashMap<Long, Long>`의 경우:
            - `Long(24바이트) * 2` + `Node<K, V>`(32바이트) + 참조(8바이트) = **88바이트**
            - 유효 데이터 비율: 18% (16/88)

      💡 **원시 타입을 다룰 때는 `Long`, `Integer` 같은 래퍼 타입을 피하는 것이 메모리 절약에 중요.**


## **메모리 사용 최적화 방법**

1. **Primitive 타입을 사용하라**
    - `int`, `long` 등의 원시 타입을 사용하면 래퍼 객체(`Integer`, `Long`)보다 훨씬 효율적임.
2. **Primitive 특화 컬렉션 사용**
    - `Trove`, `HPPC`, `fastutil` 같은 라이브러리는 원시 타입 전용 컬렉션을 제공하여 `HashMap<Long, Long>` 같은 구조의 오버헤드를 줄여줌.
3. **객체 필드 정렬을 고려**
    - JVM은 필드를 8바이트 단위로 정렬하므로, 작은 필드(`boolean`, `byte`)를 모으고 큰 필드(`long`, `double`)을 나중에 배치하면 패딩 오버헤드를 줄일 수 있음.
4. **객체 풀링(Object Pooling)**
    - `Integer.valueOf()` 같은 방법을 활용하여 박싱된 객체를 재사용하면 메모리 절약 가능.