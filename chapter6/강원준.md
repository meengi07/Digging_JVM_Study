### 튜링 완전성(Turing completeness)이란?

어떤 계산 시스템(프로그래밍 언어, 기계, 논리 체계 등)이 튜링 기계(Turing Machine)와 동일한 계산 능력을 가짐

- 임의의 계산을 수행할 수 있어야 함 (무제한 루프, 조건문, 상태 변경 가능)
- 무한한 메모리 사용할 수 있어야 함 (이론적)
- 임의의 알고리즘을 표현할 수 있어야 함 (순차 실행, 분기, 반복 기능)

## 바이트코드

- 바이트코드는 튜링 완전하다.
- 바이트 코드는 자바 가상 머신에서 어떠한 언어도 표현할 수 있도록 보장
- 자바 컴파일러를 사용하면 자바 코드를 바이트코드로 바꿔 ‘클래스 파일’로 저장할 수 있음
- 코틀린 등 다른 언어의 컴파일러 역시 해당 언어의 소스 코드를 ‘클래스 파일’로 컴파일할 수 있음

![스크린샷 2025-03-04 오후 11.19.17.png](attachment:593d5707-34f7-4224-a461-9fb4f87fc3fa:스크린샷_2025-03-04_오후_11.19.17.png)

## 클래스 파일의 구조

클래스 파일은 바이트를 하나의 단위로 하는 이진 스트림 집합체

각 데이터 항목이 정해진 순서에 맞게, 구분 기호 없이 조밀하게 나열

1바이트가 넘는 데이터 항목은 바이트 단위로 분할

- 큰 단위의 바이트가 먼저 저장되는 빅 엔디언 방식으로 표현

클래스 파일에 데이터를 저장하는 데는 C 언어의 구조체와 비슷한 의사 구조(pseudo structure)를 이용한다.

- 이 의사 구조에는 ‘부호 없는 숫자’와 ‘테이블’이라는 두 가지 데이터 타입만 존재

**부호 없는 숫자(unsigned number)**: 기본 데이터 타입을 표현한다.

- u1, u2, u4, u8은 각각 1바이트, 2바이트, 4바이트, 8바이트 뜻함
- 숫자, 인덱스 참조, 수량 값을 기술하거나 UTF-8로 인코딩된 문자열 값을 구성할 수 있음

테이블: 여러 개의 부호 없는 숫자나 또 다른 테이블로 구성된 복합 데이터 타입을 표현한다. 구분이 쉽도록 테이블 이름 관례적으로 ‘_info’로 끝남

- 클래스 파일 전체는 본질적으로 테이블, 테이블은 계층적으로 구성된 복합 구조의 데이터를 설명하는 데 사용

![스크린샷 2025-03-04 오후 11.33.06.png](attachment:786f2574-3137-403d-abf4-856de74e7b2a:스크린샷_2025-03-04_오후_11.33.06.png)

- 같은 타입의 데이터 여러 개를 표현할 때 그 개수가 정해져 있지 않다면 개수를 알려 주는 타입이 바로 앞에 등장 “*_count” 형태 항목들
    - 이처럼 [개수 + 개수만큼의 데이터 타입] 형태를 해당 타입의 ‘컬렉션’이라고 한다.
- 구분자가 없기 때문에 구조 정의 6-1의 데이터 항목은 데이터가 저장되는 바이트 순서(byte ordering), 각 바이트의 의미, 길이, 순서가 모두 엄격하게 제한되며 변경할 수 없다.

### 매직 넘버와 클래스 파일의 버전

모든 클래스 파일의 처음 4바이트는 매직 넘버로 시작

- 가상 머신이 허용하는 클래스 파일인지 여부를 확인하는 용도
- 클래스 파일의 매직 넘버는 0xCAFEBABE
- 매직 넘버의 다음 4바이트: 클래스 파일의 버전 번호
    - 5-6번째 바이트는 마이너 버전
    - 7-8번째 바이트는 메이저 버전을 뜻함
    - 자바 버전 번호는 45부터 시작
- JDK 1.1 이후 주요 JDK 릴리스의 메이저 버전은 1씩 증가
- 상위 버전 JDK는 하위 버전을 인식할 수 있음
- 하위 버전에서 상위 버전 클래스 파일 실행 X
- JDK 1.x 이전에 마이너 버전 번호를 잠시 사용 했었다.
    - 사용 안하다가 JDK 12에서 복잡한 베타 기능 출시할 때 마이너 버전 다시 활용

![스크린샷 2025-03-04 오후 11.46.58.png](attachment:a9dda92b-c351-448a-b389-914a1ee86210:스크린샷_2025-03-04_오후_11.46.58.png)

### 상수 풀

상수 풀에 들어 있는 상수 수는 고정적이지 않으므로 상수 풀 항목들에 앞서 항목 개수를 알려주는 u2 타입 데이터가 필요함

- “1부터 시작”

![스크린샷 2025-03-04 오후 11.54.13.png](attachment:cc1a50cb-1ae5-472b-9453-1423f9b3919c:스크린샷_2025-03-04_오후_11.54.13.png)

- 0x0013: 십진수 19, 상수 풀에 상수가 18개 존재하며 인덱스 범위는 1 ~ 18까지
- 0번째 상수를 비운 이유는?
    - 상수 풀 인덱스를 가리키는 데이터에서 ‘상수 풀 항목을 참조하지 않음’을 표현해야하는 특수 케이스에 인덱스를 0으로 설정하도록 한 것
- 상수 풀에 담기는 상수 유형
    - 리터럴
        - 자바 언어 수준에서 상수(final로 선언된 문자열이나 상수)와 비슷한 개념
    - 심벌 참조
        - 컴파일과 관련된 개념
        - 모듈에서 익스포트하거나 임포트하는 패키지
        - 클래스와 인터페이스의 완전한 이름(full qualified name)
        - 필드 이름과 서술자(descriptor)
        - 메서드 이름과 서술자
        - 메서드 핸들과 메서드 타입(method handle, method type, invoke dynamic)
        - 동적으로 계산되는 호출 사이트와 동적으로 계산되는 상수(dynamically-computed call site, dynamically-computed constant)
- **C, C++ 컴파일 과정 (4단계)**
    1. **전처리(Preprocessing)**: #include, #define 같은 전처리 지시문을 처리
    2. **컴파일(Compilation)**: 소스 코드(.c, .cpp)를 **어셈블리 코드**로 변환
    3. **어셈블(Assembly)**: 어셈블리 코드를 **기계어(바이너리, .o 파일)**로 변환
    4. **🔗 링크(Linking)**: 여러 개의 오브젝트 파일(.o)과 라이브러리를 묶어서 실행 파일 생성

자바에서는 컴파일할 때 링크 단계가 없고, 가상 머신이 클래스 파일을 로드할 때 동적으로 이뤄짐

링크: 필드와 메서드가 메모리에서 어떤 구조로 표현되는가에 관한 정보를 담고 있음

- 가상 머신은 클래스 파일을 로드할 때 상수 풀에서 해당 심벌 참조들을 가져옴
- 런타임에 클래스가 생성되거나 구동할 때 해석하여 실제 메모리 주소로 변환

**JDK 21 기준 총 17가지 상수 타입이 존재한다.**

- 17가지 타입의 테이블들은 공통적으로 u1 타입의 플래그 비트(tag)로 시작 → 상수 타입을 나타냄

![스크린샷 2025-03-05 오후 9.19.28.png](attachment:c9828618-8d64-4191-9bf7-94f25189abfd:스크린샷_2025-03-05_오후_9.19.28.png)

**e.g.** 0x0A (십진수 10): CONSTANT_Methodref_info는 같은 클래스의 메서드를 가리키는 심벌 참조

![스크린샷 2025-03-05 오후 9.21.02.png](attachment:9518c471-f51f-4f07-9497-f412afcece45:스크린샷_2025-03-05_오후_9.21.02.png)

![스크린샷 2025-03-05 오후 9.21.55.png](attachment:c48a58d3-f8a9-4b1b-bf5d-d0ec7ba20236:스크린샷_2025-03-05_오후_9.21.55.png)

- 첫 번째 인덱스와 두 번째 인덱스 모두 상수 풀에서의 인덱스 값

해석하는게 꽤 빡세고만..

index가 u2라 함은 위 그림에서 0B, 0C 두 칸을 쓴다는 뜻..

두 번째 상수의 플래그 비트의 값은 07: CONSTANT_Class_info → 클래스나 인터페이스를 가리키는 심벌 참조

![스크린샷 2025-03-05 오후 9.29.38.png](attachment:a17f884d-1e71-4aeb-a0bb-d663239abc7e:스크린샷_2025-03-05_오후_9.29.38.png)

name_index가 04이므로 상수 풀의 네 번째 상수를 보면 이 메서드가 정의된 클래스의 이름을 알 수 있음

첫 번째 상수의 의미는 Object 클래스의 기본 인스턴스 생성자임을 알 수 있음

![스크린샷 2025-03-05 오후 9.30.56.png](attachment:33619cd8-00ae-4bf8-9ed2-644b6b53509a:스크린샷_2025-03-05_오후_9.30.56.png)

클래스 이름(#4), 메서드 이름(#5), 메서드의 타입(#6) 정보는 모두 UT-8로 인코딩된 문자열로 표현된다.(플래그 비트가 0x01)

`{jdk-root}/bin/javap` 실행 파일로 클래스 파일의 바이트코드 분석 가능

![스크린샷 2025-03-05 오후 9.41.29.png](attachment:1d1fb254-e7b0-4a20-863b-12168e14eeff:스크린샷_2025-03-05_오후_9.41.29.png)

![스크린샷 2025-03-05 오후 9.42.32.png](attachment:df944637-64e9-4604-8ded-2b09f5866a49:스크린샷_2025-03-05_오후_9.42.32.png)

### 접근 플래그(access_flags)

상수 풀 다음의 2바이트 → 현재 클래스(or interface) 의 접근 정보를 식별

- 현재 클래스 파일이 표현하는 대상이 클래스인지, 인터페이스인지, public인지, abstract인지, 클래스인 경우 final인지 등…

![스크린샷 2025-03-05 오후 9.44.43.png](attachment:5c75bf57-b604-4ae7-ac49-6026d0aaa6c3:스크린샷_2025-03-05_오후_9.44.43.png)

### 클래스 인덱스, 부모 클래스 인덱스, 인터페이스 인덱스

현재 클래스 인덱스(this_class)와 부모 클래스 인덱스(super_class), 인터페이스 인덱스 컬렉션(interfaces)이 나옴

- 클래스 파일의 상속 관계를 규정

![스크린샷 2025-03-05 오후 9.48.23.png](attachment:36ed5af3-26c5-46a3-972e-18d7b6c20b68:스크린샷_2025-03-05_오후_9.48.23.png)

- 인터페이스 인덱스 컬렉션의 첫 항목은 u2 타입, 값은 인덱스 테이블의 크기를 뜻 함 → 현재 클래스가 구현한 인터페이스의 수(interfaces_count)

![스크린샷 2025-03-05 오후 9.49.20.png](attachment:bcb205a7-4920-4340-901d-a45f9ee48057:스크린샷_2025-03-05_오후_9.49.20.png)

![스크린샷 2025-03-05 오후 9.51.23.png](attachment:1195e71d-d909-4bba-ad33-6813449b4ac5:스크린샷_2025-03-05_오후_9.51.23.png)

### 필드 테이블

필드 테이블(field_info)은 인터페이스나 클래스 안에 선언된 변수들 설명

![스크린샷 2025-03-07 오후 10.33.53.png](attachment:23f8a0d7-347d-4910-96c6-657b0bacbf6e:스크린샷_2025-03-07_오후_10.33.53.png)

- 필드의 access_flags
    
    ![스크린샷 2025-03-07 오후 10.34.30.png](attachment:340b8463-a9c1-4e7f-a8a1-cd9f1763e6f5:스크린샷_2025-03-07_오후_10.34.30.png)
    
- name_index와 descriptor_index 는 상수 풀에서 인덱스로, 각각 ‘필드의 단순 이름’과 ‘필드 및 메서드 서술자’ 참조를 가리킴
    - 완전 이름: “org/test/TestClass” 같은 것
    - 단순 이름: inc() 메서드 → inc, m 필드: m
    - 서술자의 역할:
        - 필드: 데이터 타입
        - 메서드: 매개 변수 목록(개수, 타입, 순서 포함)과 반환값까지 기술
        
        ![스크린샷 2025-03-07 오후 10.41.31.png](attachment:631aae67-062a-4161-9d07-6c22cb7966bb:스크린샷_2025-03-07_오후_10.41.31.png)
        
        - 배열: java.lang.String[][] → “[[Ljava/lang/String”이 됨 (차원 수 만큼 “[”가 붙음)
        - primitive type: “[I”
        - 메서드를 기술할 때 매개 변수 목록 먼저 적고 반환값 적음
            - void inc() → “()V”
            - java.lang.String.toString() → “()Ljava/lang/String”
            - int indexOf(char[] source, int sourceOffset, char[] target) → “([CI[C)I”

![스크린샷 2025-03-07 오후 10.46.42.png](attachment:3865ea34-49bf-4043-9c7d-b3af280de3f2:스크린샷_2025-03-07_오후_10.46.42.png)

### 메서드 테이블

method_info

![스크린샷 2025-03-07 오후 10.49.12.png](attachment:d150f668-a9a0-4f36-9a1c-2b9dd7e6aa48:스크린샷_2025-03-07_오후_10.49.12.png)

![스크린샷 2025-03-07 오후 10.49.31.png](attachment:8b3beb8a-3428-4d2f-9c85-04ab9908fbb8:스크린샷_2025-03-07_오후_10.49.31.png)

**메서드 본문 코드**

- javac 에 의해 바이트코드 명령어로 변환된 후, 메서드 속성 테이블 컬렉션의 “Code” 속성에 따로 저장

![스크린샷 2025-03-07 오후 10.50.55.png](attachment:003acb37-da41-4ef4-be88-a7f2857fddda:스크린샷_2025-03-07_오후_10.50.55.png)

### 속성 테이블

![스크린샷 2025-03-07 오후 10.55.47.png](attachment:439aea6f-ee61-4923-8594-e070856495cd:스크린샷_2025-03-07_오후_10.55.47.png)

![스크린샷 2025-03-07 오후 10.56.01.png](attachment:e0f07a59-cf0c-4223-89b3-149ff29175e6:스크린샷_2025-03-07_오후_10.56.01.png)
