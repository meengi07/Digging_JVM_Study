# 6. 클래스 파일 구조
자바의 언어 독립성을 보장하는 핵심
- 가상 머신과 바이트코드 저장 형식
- JVM은 자바를 포함한 프로그래밍 언어에 종속되지 않음
- 클래스 파일이라는 특정한 바이너리 파일 형식에만 의존

클래스 파일

- JVM 명령어 집합과 심벌 테이블, 몇 가지 추가 정보
- **JVM 명세**는 클래스 파일이 여러 필수 구문과 구조를 따르도록 제약
- 하지만 바이트코드 형식은 완전 튜링(turing complete)하기에 어떤 언어도 표현할 수 있음
- 클래스 파일은 프로그램을 전달하는 매채로 이용

  ![스크린샷 2025-03-08 오전 9.48.39.png](attachment:6bc3cd01-2100-4809-b327-63130542bd65:스크린샷_2025-03-08_오전_9.48.39.png)


## 클래스 파일의 구조

모든 클래스 파일은 각각 하나의 클래스 또는 인터페이스를 정의한다. 하지만 클래스나 인터페이스를 꼭 파일에 담아 둘 필요는 없다. 예컨대 동적으로 생성하여 클래스 로더에 직접 전달할 수 있다.

- 클래스 파일은 바이트를 하나의 단위로 하는 이진 스트림 집합체
- 각 데이터 항목이 정해진 순서에 맞게, 구분 기호 없이 나열됨
- 낭비되는 공간 없이 프로그램을 실행하는데 필요한 데이터로 채워짐
- 1바이트가 넘는 데이터 항목은 바이트 단위로 분할되며, 큰 단위의 바이트가 먼저 저장되는 빅 엔디언방식임
    - Big Endian 큰 단위부터 저장, 반대는 Little Endian 작은 단위부터 저장

클래스 파일에 데이터를 저장하는 데는 C언어의 구조체와 비슷한 의사 구조(pseudo structure)를 이용함.

- 부호 없는 숫자(unsigned number) : 기본 데이터 타입을 표현 u1, u2, u4, u8은 각각 1바이트, 2바이트, 4바이트, 8바이트를 뜻함, 숫자, 인덱스 참조, 수량 값을 기술하거나 UTF-8로 인코딩된 문자열 값을 구성 가능
- 테이블 : 여러개의 부호 없는 숫자나 다른 테이블로 구성된 복합 데이터 타입, 구분이 쉽도록 테이블 이름은 관례적으로 “_info”로 끝낸다. 테이블은 계층적으로 구성된 복합 구조의 데이터를 설명하는데 사용.

  ![스크린샷 2025-03-08 오전 10.03.28.png](attachment:66122f29-ab8a-494d-b215-0ff15740bc7c:스크린샷_2025-03-08_오전_10.03.28.png)

    - 같은 타입의 데이터 여러 개를 표현할 때 그 개수가 정해져 있지 않다면 개수를 알려주는 타입이 “_count” 형태임 이처럼 {개수 + 개수만큼의 데이터 타입} 형태를 해당 타입의 ‘컬렉션’이라 함

### 매직 넘버와 클래스 파일의 버전

모든 클래스 파일의 처음 4바이트는 매직 넘버로 시작하며 매직 넘버는 VM이 허용하는 클래스 파일인지를 확인하는 용도다.

- JVM 클래스 파일의 매직 넘버는 **0xCAFEBABE** 이다.
- 그 다음 4바이트는 클래스 파일의 버전 번호이다.
    - 5~6번 째 바이트는 마이너 버전을 의미
    - 7~8번 째 바이트는 메이저 버전을 의미
    - 자바 버전 번호는 45부터 시작하며 1.1 이후 1씩 증가
        - JDK 8 : 52
        - JDK 11 : 55
        - JDK 17 : 61
        - JDK 21 : 65

      ![스크린샷 2025-03-08 오전 10.31.50.png](attachment:3af82a51-17ec-45ca-a009-6c60fbc59999:스크린샷_2025-03-08_오전_10.31.50.png)


### 상수 풀

클래스 파일의 ‘자원 창고’로 다른 클래스와 가장 많이 연관된 부분으로 차지하는 공간도 대체로 가장 크다

- 가장 먼저 등장하는 테이블 타입 데이터 항목
- 상수의 수는 고정적이지 않으므로 항목 개수를 알려 주는 u2 타입 데이터가 필요함
- 자바 언어의 관례상 개수를 0이 아닌 1부터 시작한다.
- 0이 아닌 이유는 상수 풀 인덱스를 가리키는 데이터에서 ‘상수 풀 항목을 참조하지 않음’ 을 표현해야 하는 특수한 경우에 인덱스를 0으로 하기 위함

상수 풀에 담기는 상수 유형

- 리터럴 : 자바 언어 수준에서 이야기하는 상수(`final`)와 비슷한 개념
- 심벌 참조 : 컴파일과 관련된 개념
    - 모듈에서 익스포트하거나 임포트하는 패키지
    - 클래스와 인터페이스의 완전한 이름
    - 필드 이름과 서술자
    - 메서드 이름과 서술자
    - 메서드 핸들과 메서드 타입
    - 동적으로 계산되는 호출 사이트와 동적으로 계산되는 상수

자바 코드를 컴파일할 땐 링크 단계가 없음, 자바에서 링크는 가상 머신이 클래스 파일을 로드할 때 동적으로 이뤄짐, 필드와 메서드가 메모리에서 어떤 구조로 표현되는가에 관한 정보는 클래스 파일에 저장되지 않는다는 뜻.

가상 머신이 필드와 메서드의 심벌 참조를 런타임에 변환하지 않으면 각 항목의 실제 메모리 주소를 알 수 없다. 가상 머신은 클래스 파일을 로드할 때 상수 풀에서 해당 심벌 참조들을 가져오고 클래스가 생성되거나 구동할 때 해석해서 실제 메모리 주소로 변환한다. ‘동적 링크’라고 함

상수 풀 안의 상수 각각이 모두 테이블이다. 17가지 타입의 테이블들은 공통적으로 u1 타입의 플래그 비트(tag) 로 시작하며 그 값은 현재 상수가 속한 상수 타입을 나타낸다. 상수 풀이 가장 복잡한 이유는 17가지 상수 타입 각각의 데이터 구조가 완전히 독립적이기 때문이다. 연관성이나 공통점이 없어서 따로 알아야 함.

![스크린샷 2025-03-08 오전 10.51.13.png](attachment:4d4eb5a8-5c06-4a86-8bdc-656959e6bdfe:스크린샷_2025-03-08_오전_10.51.13.png)

### 접근 플래그

상수 풀 다음 2바이트는 현재 클래스의 접근 정보를 식별하는 접근 플래그(access_flags)임

### 클래스 인덱스, 부모 클래스 인덱스, 인터페이스 인덱스

이어서 현재 클래스 인덱스(this_class), 부모 클래스 인덱스(super_class), 인터페이스 인덱스 컬렉션(interfaces) 가 나오는데, 클래스 파일의 상속 관계를 규정함

### 필드 테이블 (field_info)

인터페이스나 클래스 안에 선언된 변수들을 설명하는 데 쓰임, 여기서 필드란 클래스 변수와 인스턴스 변수를 뜻하며 메서드의 지역 변수는 아니다.

### 메서드 테이블 (method_info)

클래스 파일에서 메서드 저장 형태는 필드 저장 형태와 거의 같음, 각 데이터 항목의 의미도 필드 테이블의 항목과 매우 비슷한데, 접근 플래그와 속성 테이블 컬렉션에서 선택할 수 있는 값만 살짝 다르다.

### 속성 테이블 (attribute_info)

클래스 파일, 필드 테이블, 메서드 테이블, Code 속성, 특정 시나리오에서 특정한 정보를 설명하기 위해 고유한 속성 테이블을 포함할 수 있다.