6장 클래스 파일 구조

- 6.1 들어가며
- 6.2 플랫폼 독립을 향한 초석
- 6.3 클래스 파일의 구조
- 6.3.1 매직 넘버와 클래스 파일의 버전
- 6.3.2 상수 풀
- 6.3.3 접근 플래그
- 6.3.4 클래스 인덱스, 부모 클래스 인덱스, 인터페이스 인덱스
- 6.3.5 필드 테이블
- 6.3.6 에서드 테이블
- 6.3.7 속성 테이블

# 클래스 파일의 구조

- 클래스 파일: 바이트를 하나의 단위로 하는 이진 스트림 집합체
- 모든 클래스 파일은 각각 하나의 클래스 또는 인터페이스를 정의
- 반면 클래스나 인터페이스를 꼭 파일에 담아 둘 필요는 없다.
    - 예컨대 동적으로 생성하여 클래스 로더에 직접 제공할 수 있다.
    - 이번 장에서는 클래스나 인터페이스가 반드시 따라야 하는 형식을 ‘클래스 파일 형식’으로 지칭할 것이다.
    - 즉, 디스크에 파일 형태로 존재할 필요는 없다

## 의사구조

- **부호 없는 숫자(unsigned number)**: 기본 데이터 타입을 표현
    - u1, u2, u4, u8: 각각 1바이트, 2바이트, 4바이트, 8바이트
    - 숫자, 인덱스 참조, 수량 값을 기술 / UTF-8로 인코딩된 문자열 값을 구성
- **테이블**: 여러 개의 부호 없는 숫자나 또 다른 테이블로 구성된 복합 데이터 타입
    - 구분이 쉽도록 테이블 이름은 관례적으로 ' info'로 끝남
    - 계층적으로 구성된 복합 구조의 데이터를 설명하는 데 사용된다.
    - 클래스 파 일전체는 본질적으로 테이블

![image.png](attachment:c82f532c-9a1b-4f8a-970b-d552528e7016:image.png)

# 매직 넘버와 클래스 파일의 버전

- `CAFEBABE` (0xCAFEBABE) → 클래스의 매직넘버 ㅁ
    - 매직 넘버: 모든 클래스 파일의 첫 4바이트
    - JVM이 정상적인 클래스 파일인지 판별하는 값
- `minor_version`, `major_version`
    - 매직 넘버 다음의 4바이트
    - JVM 버전과의 호환성 확인

![image.png](attachment:1ae8a10a-7fef-40bd-9a1f-5f4eafb2dcfc:image.png)

# Constant Pool (상수 풀)

- 클래스 파일의 자원창 창고
- 클래스, 메서드, 문자열, 인터페이스 참조 등을 저장하는 영역 ⇒ 가장 타 클래스와 많이 연관됨
- **대부분의 바이트코드 명령어가 여기 저장된 값(상수 풀 인덱스)을 참조**함

---

- **상수 풀에 들어 있는 상수의 수**는 고정적이지 않음
    - 항목 개수를 알려 주는 U2 타입 데이터가 필요
    - 상수 풀만 개수를 셀 때는 0이 아닌 1부터 시작
    - c.f TestClass 클래스의 상수 풀 크기 (오프셋 주소: 0x00000008)
        - 십육진수로 0x0013 / 십진수 19
        - 상수 풀에는 상수가 18개 존재 / 인덱스 범위는 **1**~18

---

- **상수 유형**
    - 리터럴: like 자바의 상수
    - 심벌 참조: 컴파일 관련

---

- **자바의 링크**: 가상 머신이 클래스 파일을 로드할 때 동적으로 이루어짐
    - → 가상 머신이 심벌 참조를 런타임에 변환하지 않으면 각 항목의 실제 메모리 주소를 알 수 없다.

---

## 상수 타입

- → 상수 풀 안의 상수 각각이 모두 테이블
- 상수 풀이 가장 복잡한 데이터인 이유
- 17가지 상수 타입 각각의 데이터 구조가 완전히 독립적이기 때문
- `tag`(플래그 비트): 상수 타입을 구분하는 용도
- `length` : UTF-8 축약 인코딩된 문자열이 몇 바이트인지
    - 이 길이만큼의 데이터가 문자열의 실제 데이터
- `CONSTANT_Utf8_ info` 타입 상수
    - 클래스 파일에서 메서드와 필드 등의 이름을 기술하는 데 참조
    - 이 상수의 최대 길이가 결국 자바 메서드와 필드 이름의 최대 길이를 규정한다는 뜻
    - 최대 길이는 length의 최댓값

---

# **Access Flags (접근 제어자 - 접근 플래그)**

- 클래스의 접근 범위(`public`, `private` 등)와 특성을 정의
- 예: `ACC_PUBLIC`, `ACC_FINAL`, `ACC_SUPER` 등

- **상수 풀 다음의 2바이트**
    - 현재 클래스(또는 인터페이스)의 접근 정보를 식별하는 접근 플래그(access_flags)
    - 클래스인지, 인터페이스인지, Public인지, abstract인지, 클래스인 경우 final인지 등의 정보

# 클래스 인덱스

### **클래스 인덱스/부모 클래스 인덱스**

- 현재 클래스와 부모 클래스의 완전한 이름을 결정.
- 자바는 다중 상속을 허용하지 않음 → 부모 클래스는 하나만 존재
- `java.lang.Object`(0)를 제외한 모든 자바 클래스는 하나의 부모 클래스 인덱스를 가짐 (0이 아님)

### 인터페이스 인덱스 컬렉션

- 현재 클래스가 구현한 인터페이스 목록을 저장
- 클래스 코드에서 `implements` 키워드 / 인터페이스 코드일 경우 `extends` 키워드
- 컬렉션 순서는 해당 뒤에 나열된 순서
- 인터페이스는 다중 상속이 가능하여 여러 개의 인덱스를 가질 수 있음.

### 클래스 파일에서의 저장 방식

- 부모 클래스 및 인터페이스의 정보는 CONSTANT_Class_info 형태로 저장됨.
- `CONSTANT_Utf8_info` 타입을 활용하여 해당 클래스의 경로를 정의함.

# 필드 테이블 - (**Fields/멤버 변수)**

- 인터페이스나 클래스 안에 선언된 클래스 변수와 인스턴스 변수
- 메서드 안에 선언된 지역 변수는 필드가 아님

```java
field_info { 
	u2 access_flags;
	u2 name_index;
	u2 descriptor_index;
	u2 attributes_count;
	attribute_info attributes[attributes_count];
}
```

### **단순 이름과 완전한 이름**

- **완전한 이름:** 패키지 경로를 포함  전체 경로 (e.g., `org/fenixsoft/clazz/TestClass`)
- **단순 이름:** 특정 메서드나 필드에 대한 축약 표현(e.g., `inc` → `"m"`)

### **서술자(Descriptor)**

![image.png](attachment:e6729124-a817-48cb-abda-6c2f938f9010:image.png)

- 필드: **데이터 타입**을 표현
- 메서드: **매개변수 목록 + 반환 타입**을 표현
- 기본 타입은 단일 문자로 표현되며, 객체 타입은 `"L"`을 앞에 붙임
- 매개변수 목록을 먼저 적고 반환값을 적음

![image.png](attachment:8f9189a6-c5a4-40fa-8114-5c1a1bbe0fff:image.png)

### **필드 테이블 구조**

- `fields_count`**:** **fields_count**(u2)로 시작 / 개수를 나타냄
    - c.f `fields_count = 0x0001` → **필드가 하나 존재**
- `access_flags` : 접근 제어자 플래그 (e.g., ACC_PRIVATE 등 - 표 6-6 참고)
- `name_index`: 필드 이름을 가리키는 상수 풀 인덱스
- `descriptor_index` : 필드 타입을 가리키는 상수 풀 인덱스
- `attributes_count` : 추가 속성 개수 및 속성 정보

- 필드 포함 여부
    - 필드 테이블에는 **현재 클래스에서 정의된 필드만 포함**
    - 부모 클래스로부터 상속받은 필드는 **필드 테이블 컬렉션에 포함되지 않음**

# **메서드 테이블 - (Methods)**

- 필드 테이블과 동일한 구조 / 접근 플래그와 속성 테이블 컬렉션에서 선택할 수 있는 값만 차이
- 메서드 목록과 바이트코드가 저장됨
- `main` 메서드나 `clinit`(클래스 초기화 블록) 등이 여기에 포함
- **클래스 파일의 오버로딩**
    - 서술자가 완전히 같지 않다면 두 메서드가 공존할 수 있음
    - ⇒ 이름과 시그너처가 같고 반환값이 다른 메서드가 하나의 클래스에 공존 가능

# 속성 테이블

- 특정 시나리오에서 특정한 정보를 설명하기 위해 존재
    - 클래스 파일, 필드 테이블, 메서드 테이블, Code 속성, 레코드 구성 요소가 가질 수 있음
- 속성 테이블 컬렉션은 제약이 살짝 느슨하며 순서에도 엄격하지 않음

### Code 속성

- **클래스 파일에서 가장 중요한 속성**
- 클래스 파일 전체는 '코드를 설명하는 Code 속성'과 '메타데이터를 설명하는 나머지 데이터 항목'으로 구분할 수 있음
- **Code 속성은 다음 두 개 장에서 다룰 바이트코드 실행 엔진을 이해하기 위해 반드시 이해하고 넘어가야 함**
- `args_size`: 인스턴스 객체에서의 this 포함 - (static only 외의 상황에서는 최소 1)
- **자바 예외나 finally를 처리**: 점프 명령어 대신 예외 테이블을 사용해야 함

### Exceptions 속성

- 메서드에서 throw될 수 있는 검사 예외, 즉 메서드 설명에서 throws 키워드 뒤에 나오는 예외들을 나열하는 기능