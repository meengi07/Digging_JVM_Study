# 자동 메모리 관리
자바 개발자는 메모리 할당에 신경쓰지 않아도 메모리상 큰 문제를 거의 겪지 않는다.
(안 겪는 것은 아니다.) 한번 문제가 생기면 메모리 관리 방식을 이해 못하면 해결하기 참 힘들다.
가상 머신의 메모리 관리를 이해해보자

## 런타임 데이터 영역
// 이미지

### 프로그램 카운터
- 작은 메모리 영역
- 현재 실행 중인 스레드의 바이트코드 줄 번호 표시기
- 인터프리터 이 카운터 값을 바꿔 다음에 실행할 바이트코드 명령어를 선택하는 식으로 동작
- 자바 가상 머신에서는 멀티스레딩은 CPU 코어를 여러 스레드가 교체로 사용하는 방식을 사용하기 떄문에
  한 코어에서 여러개의 스레드를 스위칭 할 때 프로그램 카운터에서 어떤 바이트 코드를 실행할지를 알 수 있다.
- 스레드는 각각의 프로그램 카운터를 가지고 있다.  
- 서로 영향을 주지 않는 독립된 영역에 저장되기 때문에 이 영역을 스레드 프라이빗 메모리라 한다.
- 스레드가 네이티브 코드를 실행할 때 프로그램 카운터 값은 Undifiend이다.
- 프로그램 카운터 메모리 영역은 OutofMemoryError 조건이 명시되지 않은 유일한 영역이다.

### 자바 가상 머신 스택
- 스레드 프라이빗, 스레드와 생명주기가 같음
- 각 스레드마다 각 메서드가 호출될 때마다 자바 가상 머신은 스택 프레임을 만들어
  지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등의 정보를 저장한다.
- 그런 다음 스택 프레임을 가상 머신 스택에 푸시하고, 메서드가 끝나면 팝하는 일을 반복한다.
- 지역 변수 테이블에는 가상 머신이 알 수 있는 다양한 기본 데이터 타입, 객체 참조, 반환 주소 타입
  을 저장한다.
- 자바 메서드는 스택 프레임에서 지역 변수용으로 할당 받아야 할 공간의 크기가 이미 완벽하게 준비되어
  있다.  
- 가상 머신이 허용하는 깊이보다 크다면 StackOverflowError를 던진다 (지뢰찾기 게임)  
- 스택 용량을 동적을 확장하려는 시점에 여유 메모리가 충분하지 않다면 OutOfMemoryError를 던진다.

### 네이티브 메서드 스택
- 가상 머신 스택과 비슷한 역할
- 네이티브 메서드 스택을 쌓음
- 가상 머신이 허용하는 깊이보다 크다면 StackOverflowError를 던진다 (지뢰찾기 게임)  
- 스택 용량을 동적을 확장하려는 시점에 여유 메모리가 충분하지 않다면 OutOfMemoryError를 던진다.

### 자바 힙
- 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리
- 자바 힙은 모든 스레드가 공유하며 가상 머신이 구동될 때 만들어진다.
- 이 메모리 영역의 유일한 목적은 객체 인스턴스를 저장하는 것
- 거의 모든 인스턴스가 이 영역에 할당.
- 가비지 컬렉터가 관리하는 메모리 영역, GC힙이라고도 불림
- 자바 힙은 작게 또 구분하는 이유는 오직 메모리 회수와 할당을 더 빠르게 하기 위함이다.
- 자바힙은 물리적으로 떨어진 메모리에 위치해도 상관 없으나 논리적으로 연속되어야 한다.
- 자바 힙은 크기를 고정할 수도, 확장할 수도 있게 구현되었다.
- -Xmx와 -Xms 매개변수를 사용하여 확장한다.
- 새로운 인스턴스에 할당해 줄 힙 공간이 부족하고 힙은 더는 확장할 수 없다면 OutofMemoryError를 던진다.

### 메서드 영역
- 모든 스레드가 공유
- 가상머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고 JIT 컴파일러가 컴파일한 코드 캐시 등을 저장하는데 이용된다.
- <<자바 가상 머신 명세>> 에서는 이 영역의 제약을 많이 두지 않았다.
- 연속될 필오가 없고, 크기를 고정할 수도 있고, 확장도 가능하고, 가비지 컬렉션을 하지 않아도 된다.
- 이 영역을 GC를 할 일이 거의 없다.
- 메서드 영역이 꽉 차서 필요한 만큼 메모리를 할당할 수 없다면 OutofMemoryError를 던진다.

### 런타임 상수 풀
- 런타임 상수 풀은 메서드 영역의 일부
- 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보에 더해 컴파일 타임에 생성된
다양한 정보를 메서드 영역에 런타임 상수 풀에 저장.
- 동적, 런타임에도 메서드 영역의 런타임 상수 풀에 새로운 상수가 추가될 수 있다.
- 런타임 상수 풀은 메서드 영역에 속하므로 자연스럽게 메서드 영역을 넘어서까지 확장될 수 없다.
- 상수풀 공간이 부족하면 OutOfMemoryErorr를 던진다.

### 다이렉트 메모리 
- 가상 머신 런타임에 속하지 않는다.
- 자주 쓰는 메모리, OutOfMemoryError의 원인이 되기도 한다.
- NIO는 힙이 아닌 메모리를 직접 할당할 수 있는 네이티브 함수 라이브러리를 이용하며, 이 메모리에
저장되어 있는 DirectByteBuffer 객체를 통해 작업을 수행할 수 있다. 자바 힙과 네이티브 힙 사이에서 데이터를 복사해 주고받지 않아도 돼 일부 시나리오에서 성능을 크게 개선했다.
- 물리적 메모리를 직접할당 하기 때문에 힙 크기의 제약과는 무관
- 물리 메모리 한계를 넘어서면 OutOfMemoryError를 발생시킴

## 핫스팟 가상 머신 객체

### 객체 생성
1. 가상 머신이 new 명령에 해당하는 바이트 코드를 만나면 매개 변수가 상수 풀 안의 클래스를 가리키는
심벌 참조인지 확인
2. 이 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화 되었는지 확인
3. 준비되지 않은 클래스라면 로딩부터 진행
4. 로딩이 완료된 클래스라면 새 객체를 담을 메모리를 할당
5. 객체에 필요한 메모리 크기는 클래스를 로딩하고 나면 완벽하게 알 수 있다.
6. 객체용 메모리 공간 할당은 자바 힙에서 특정 크기의 메모리 블록을 잘라 주는 일
7. 자바 힙이 완벽히 규칙적이라고 가정하면, 포인터가 두 영역의 경계인 가운데 지점을 가리킨다.
8. 이 상태에서 메모리를 할당하면 포인터를 여유 공간 쪽으로, 객체 크기만큼 이동한다 : 포인터 밀치기
9. 하지만 자바 힙은 규칙적이지 않다. 가상 머신은 가용 메모리 블록들을 목록으로 따로 관리한다. :
여유 목록 방식
10. 어떤 방식을 쓸지는 자바 힙이 규칙적이냐 아니냐에 따라 달라진다. 가비지 컬렉터가 컴팩트(모으기)를 할 수 있느냐에 따라 다르다.컴팩트가 가능하면 밀치기 방식, 아니라면 여유 목록 방식을 사용한다.
11. 메모리 할당 후 가상머신은 할당받은 공간을 0으로 초기화(객체 헤더는 제외)
12. 스레드 로컬 할당 버퍼를 사용한다면 초기화는 TLAB 할당 시 미리 수행.
13. 자바 가상 머신은 각 객체에 필요한 설정을 해준다. (어느 클래스의 인스턴스인지, 클래스의 메타 정보는 어떻게 찾는지, 객체의 해시코드는 무엇인지, GC 나이는 얼마인지)
14. 머신 관점에서 새로운 객체가 다 만들어진 것, 이후 자바 프로그램 관점에서 시작, 생성자가 실행되지 않았고, 모든 필드는 기본값인 0인 상태, new 명령어에 이어서 <init>() 메서드가 실행되어야 비로서 사용 가능한 진짜 객체가 완성된다.

### 멀티 스레딩 환경에서의 여유 메모리의 시작 포인터 위치 수정
- 여러 스레드가 동시에 객체를 생성하려고 할 떄 문제가 생길 수 있다.
- 해결방법 1 : 메모리 할당을 동기화
- 해결방법 2 : 스레드마다 다른 메모리 공간을 할당, 스레드 각각이 자바 힙 내에 작은 크기의 전용 메모리를 미리 할당 받는 방법. 이런 메로리를 스레드 로컬 할당 버퍼(TLAB)라고 한다.
- 각 스레드는 로컬 할당 버퍼(TLAB)라고 한다. 각 스레드는 로컬 버퍼에 메모리를 할당 받아 사용하다가 버퍼가 버퍼가 부족해지면 그 때 동기화를 해 새로운 버퍼를 할당 받는다.
- 가상 머신이 스레드 로컬 할당 버퍼를 사용할지는 -xx:+/-useTLAB 매개변수로 설정

> 자바 컴파일러는 자바의 new 키워드를 발견하면 바이트코드 명령어인 new와 invokespecial로 변환
> new는 메모리 할당 단계를 수행, invokespecial은 <init>()을 메서드를 호출
> But, 자바 코드에서 new가 아닌 다른 방식으로 객체를 생성한 경우라면 invokespecial이 연이어 나오지 않을 수 있다.

### 객체의 메모리 레이아웃

### 객체 헤더
1. 객체 자체의 런타임 데이터
- 해시코드, GC 세대 나이, 락 상태 플래그, 스레드가 점유하고 있는 락들, 편향된 스레드의 아이디
- 객체는 아주 많은 런타임 데이터를 필요로 해서, 32비트, 64비트 구조에 다 담을 수 없다. 그래서
마크워드의 데이터 구조는 동적으로 의미가 달라진다. 작은 공간에 가능한 많은 정보를 담고, 객체 상태에 따라 공간을 재활용할 수도 있게 한다.

### 인스턴스 데이터
- 객체가 실제로 담고 있는 정보
- 다양한 타입의 필드 관련 내용
- 부모 클래스 유무
- 부모 클래스에서 정의한 모든 필드가 이 부분에 기록
- +XX:CompactFields 매개변수를 true로 설정하면(기본값이 true) 하위 클래스의 필드 중 길이가 짧은 것들은 상위 클래스의 변수 사이사이에 끼워져서 공간이 그나마 절약된다.

### 정렬 패딩
- 존재하지 않을 수도 있음
- 공간 확보 역할
- 핫스팟 가상 머신의 자동 메모리 관리 시스템에서 객체 시작 주소는 반드시 8바이트의 정수배여야 한다.
- 충족하지 못하는 경우 패딩으로 채움

## 실습

### VM arguments
```
-Xms2m -Xmx2-m -XX:HeapDumpOutOfMemoryError
```
- -Xms : 힙 최소 크기(ex : -Xms20m)
- -Xmx : 힙 최대 크기(ex : -Xmx20m)
- -XX:HeapDumpOutOfMemoryError : 메모리가 오버플로 됐을 때 가상 머신이 예외 발생 시점의 힙 메모리 스냅숏을 파일로 저장
- -Xss : 스택 크기(ex : -Xss180k)

### 힙 덤프 파일 확인
이클립스 > Help > Eclipse marketplace > Memory Analyzer

### 영구 세대 크기
- -XX:PermSize (JDK7)
- -XX:MaxPermSize (JDK7)

- -XX:MetaspaceSize (JDK8) (ex : -XX:MetaspaceSize=6M)
- -XX:MaxMetaspaceSize (JDK8) (ex : -XX:MetaspaceSize=6M) : 기본값은 -1, 네이티브 메모리 크기가 허용하는 만큼
- -XX:MinMetaspaceFreeRatio : 가비지 컬렉션 후 가장 작은 메타스페이스 여유 공간의 비율(%)을 설정, 이 값을 조절하여 메타스페이스 공간이 부족해 발생하는 가비지 컬렉션 빈도를 줄일 수 있다.

### 네이티브 다이렉트 메모리 오버플로

- -XX:MaxDirectMomorySize : 다이렉트 메모리 용량, 기본적으로 -Xmx로 설정한 자바 힙의 최대값과 같다.

다이렉트 메모리에서 발생한 메모리 오버플로가 발생하면 힙 덥프 파일에서 이상한 점을 찾을 수 없다.
메모리 오버 플로로 생성된 덤프 파일이 매우 작다면, 그리고 DirectMemory를 직접 또는 간접적으로(보통 NIO를 통해 사용했다면)
다이렉트 메모리에서 원인을 찾는데 집중해야 한다.