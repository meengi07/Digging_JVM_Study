# 2. 자바 메모리 영역과 메모리 오버플로

## 런타임 데이터 영역

JVM은 프로그램을 실행하는 동안 필요한 메모리를 몇 개의 데이터 영역으로 나눠 관리한다.

![chapter2_runtime.png](/image/chapter2_runtime.png)

프로그램 카운터 레지스터는 작은 메모리 영역으로 현재 실행중인 스레드의 ‘바이트코드 줄 번호 표시기’라고 생각하면 쉽다. 일반적인 JVM에서 바이트코드 인터프리터는 이 카운터의 값을 바꿔 다음에 실행할 바이트코드 명령어를 선택하는 식으로 동작한다.

JVM에서 멀티스레딩은 CPU 코어를 여러 스레드가 교대로 사용하는 방식으로 구현되기 때문에 특정 시각에 각 코어는 한 스레드의 명령어만 실행하게 된다. 따라서 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확히 찾아 복원하려면 스레드 각각에는 고유한 프로그램 카운터가 필요하게 되고, 각 프로그램 카운터는 독립된 영역에 저장되며 이것을 **프라이빗 메모리**라고 한다.

### JVM Stack (자바 가상 머신 스택)

JVM 스택도 ‘스레드 프라이빗’하며, 연결된 스레드와 생명주기가 동일 하다. 스택은 자바 메서드를 실행하는 스레드의 메모리 모델을 설명하는데, 각 메서드가 호출될 때마다 JVM은 스택 프레임(메서드 실행 도중 사용되는 기본 stack 데이터 구조)을 만들어 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등 정보를 제공하며 스택 프레임을 JVM 스택에 `push`, `pop`하는 일을 반복한다.

일반적으로 자바 프로그램에서 ‘스택’이라고 한다면 보통 JVM 스택 중 **지역 변수 테이블**을 가리키는 경우가 많으며, JVM이 컴파일 타임에 알 수 있는 다양한 기본 데이터 타입(boolean, byte, int, long…), 객체 참조(참조 포인터, 객체의 핸들, 관련 위치 등), 반환 주소 타입(바이트코드 명령어의 주소)을 저장하는데, 이 데이터 타입들을 저장하는 공간을 **지역 변수 슬롯**이라 한다. 이 슬롯 하나당 크기는 32비트이며, 일반적인 타입은 1개의 슬롯, double 타입처럼 길이가 64비트인 경우는 2개의 슬롯을 할당한다. 그리고 지역 변수 테이블을 구성하는 데 필요한 데이터 공간은 컴파일 과정에서 할당된다. 그래서 자바의 메서드는 스택 프레임에서 지역 변수용으로 할당받아야 할 공간의 크기가 이미 결정되어 있고 변하지 않는다. 여기서 말하는 ‘크기’ 는 슬롯의 개수다.

**`자바 가상 머신 명세 - 명세`**는 스택 메모리 영역에서 두 가지 오류가 발생할 수 있도록 정의했다.
첫째, 스레드가 요청한 스택 깊이가 가상 머신이 허용하는 깊이보다 크다면 `StackoverflowError`를 던진다. 둘째, 스택 용량을 동적으로 확장할 수 있는 JVM에서는 스택을 확장하려는 시점에 여유 메모리가 충분하지 않다면 `OutOfMemoryError`를 던진다.

### 네이티브 메서드 스택

위 스택과 비슷한 역할로, 네이티브 메서드를 실행할 때 사용한다는 점이 다르다. **`명세`**에는 어떻게 표현해야 하는지 명시하지 않아서 자유롭게 커스텀이 가능하다. 그래서 네이티브 메서드 스택과 스택을 합쳐 놓은 가상 머신도 있다. (핫스팟 VM도 포함)

### 자바 힙

자바 애플리케이션이 사용할 수 있는 가장 큰 메모리 영역이다. 모든 스레드가 공유하며 VM 이 구동될 때 생성된다. 이 영역의 목적은 객체 인스턴스를 저장하는 것으로, ‘거의’ 모든 객체 인스턴스가 이 영역에 할당된다.

자바 힙은 GC가 관리하는 메모리 영역이기 때문에 어떤 문헌에는 GC Heap 이라고도 한다. 메모리 회수 관점에서 대다수 현대 GC들은 세대별 컬렉션 이론(generational collection theory)을 기초로 설계됐고, 그래서 신세대, 구세대, 영구 세대, 에덴 공간 등 용어들이 나타나는데 사실 명세에서는 정해진 세부 영역 구분에 관련된 내용이 없다.

메모리 할당 관점에서 자바 힙은 모든 스레드가 공유하며, 객체 할당 효율을 높이고자 스레드 로컬 할당 버퍼(Thread Local Allocation buffer, TLAB) 여러개로 나뉜다. 세부 영역을 버퍼 여러개로 나누든 데이터가 자바 힙에 저장된다는 사실은 달라지지 않지만 버퍼로 구분하는 이유는 메모리 회수와 할당을 빠르게 하기 위함이다.

**`명세`** 에는 자바 힙은 물리적으로 떨어진 메모리에 위치해도 상관 없으나, 논리적으로는 연속되야 한다.

### 메서드 영역

메서드 영역도 **힙** 처럼 모든 스레드가 공유한다. 메서드 영역은 VM이 읽어 들인 타입 정보, 상수, 정적 변수, JIT 컴파일러가 컴파일한 코드 캐시등을 저장하는 데 이용된다. **`명세`**에서는 논리적으로는 힙의 한 부분이지만, 힙과 구분하기 위해 논힙(non-heap)이라 부르기도 한다.

### 런타임 상수 풀

메서드 영역의 일부로 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보에 더해 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다. VM이 클래스를 로드할 때 이러한 정보를 메서드 영역의 상수 풀에 저장한다. JVM은 클래스 파일의 영역별로 엄격한 규칙을 정해 놓았는데, 런타임 상수 풀에 대해서는 **`명세`**가 요구 사항을 상세하게 정의하지 않아서 VM 제공자가 커스텀할 수 있지만 클래스 파일에 기술된 심벌 참조와 직접 참조는 런타임 풀에 저장되는 게 일반적이다.

> ***심벌릭 참조(Symbolic Reference)**는 **JVM이 특정 클래스, 메서드, 필드 등을 직접 메모리 주소로 참조하지 않고, 대신 "문자열, 필드 이름, 메서드 시그니처" 등의 형태로 참조하는 방식**을 말한다.
즉, 실행 전에 **어떤 객체가 어디에 있는지 정확한 메모리 주소를 알 수 없기 때문에**, 바이트코드에서는 **이름 기반의 참조 방식(심벌릭 참조)** 을 사용한다.*
>

| **비교 항목** | **심벌릭 참조 (Symbolic Reference)** | **직접 참조 (Direct Reference)** |
| --- | --- | --- |
| 참조 방식 | 문자열, 클래스명, 메서드명, 필드명 등 | 실제 메모리 주소 |
| 바이트코드 내 표현 | `ClassName`, `MethodName`, `FieldName` | 객체의 실제 메모리 위치 |
| 사용 시점 | 클래스 로딩 & 링킹 단계에서 실제 참조로 변환됨 | 이미 실행 중이므로 변환 과정 없음 |
| 장점 | 클래스가 다른 환경에서 로드되어도 유연하게 처리 가능 | 속도가 빠름 (메모리 접근 최적화) |
| 단점 | 실행 전에 실제 주소를 모름 → 변환 과정 필요 | 클래스가 변경되면 새로 빌드해야 함 |

클래스 파일의 상수 풀(`.class` 파일 내부에 포함된 상수 테이블, 클래스 로딩 시점에 JVM에 의해 해석됨)과 비교해 런타임 상수 풀의 중요한 특징이 하나 더 있는데, 동적이라는 점으로 자바는 상수가 꼭 컴파일타임에 생선되는게 아니라 런타임에도 메서드 영역의 런타임 상수 풀에 새로운 상수가 추가될 수 있다. (예 : String 의 `intern()`)

### 다이렉트 메모리

다이렉트 메모리는 런타임에 속하지 않고, **`명세`**에 정의된 영역도 아니다. 하지만 자주 사용되는 영역으로 OOM이 발생할 원인이 될 수 있다. NIO가 도입되면서 채널과 버퍼 기반 IO메서드가 소개됐는데, NIO는 힙이 아닌 메모리를 직접 할당할 수 있는 네이티브 함수 라이브러리를 이용하며, 이 메모리에 저장된 `DirectByteBuffer` 객체를 통해 작업을 수행할 수 있게 되면서 자바 힙과 네이티브 힙 사이에 데이터를 주고받지 않아도 돼서 일부 시나리오에서 성능 개선이 이뤄졌다.

## 핫스팟 가상 머신에서의 객체 들여다보기

가장 보편적인 핫스팟 VM과 자바 힙을 예시로 메모리 모델을 확인한다.

### 객체 생성

객체 지향 프로그래밍 언어인 자바에서 객체는 수시로 생성되는데, 보통은 객체 생성(복사, 역직렬화 제외)은`new` 키워드면 되는데 생성 시점에서 VM 수준에선 어떤 과정이 발생하여 객체가 생성되는지 알아보자.

1. JVM이 `new` 명령의 바이트코드를 만나면 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인
2. 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화 되었는지 확인
    1. 만약 준비되지 않은 클래스라면 로딩부터 한다.
3. 로딩이 완료되면 클래스를 새 객체를 담을 메모리 할당
    1. 객체에 필요한 메모리 크기는 클래스를 로딩하고 나면 완벽히 알 수 있다.

   자바 힙이 완벽히 규칙적이라면 사용중인 메모리는 한쪽에, 여유있는 메모리는 반대편에 두고, 포인터가 두 영역의 가운데 지점을 가리키게 될 것이며, 이 상태에서 메모리를 할당하면 포인터를 여유 공간쪽으로 객체의 크기만큼 이동시키는데 이런 할당 방식을 **포인터 밀치기**(bump the pointer)라고 한다.
   ![chapter2_memory_init.png](/image/chapter2_memory_init.png)

   하지만 자바 힙은 규칙적이지 않아 포인터 밀치기가 간단하지 않다. 대신 VM은 가용 메모리 블록들을 목록으로 따로 관리하며, 객체 인스턴스를 담기 충분한 공간을 찾아 할당한 후 목록을 갱신한다. 이 할당 방식을 **여유 목록**(free list)라 한다.

   가상 머신에서 객체 생성은 매우 빈번하고 멀티스레딩 환경에서는 여유 메모리의 시작 포인터 위치를 수정하는 단순한 일도 thread safe하지 않기 때문에 여러 스레드가 동시에 객체를 생성하려고 할 때 문제가 발생할 수 있다. 예를 들어 한 스레드가 요청한 객체 A를 위해 메모리를 할당하는 과정에서 포인터의 값을 아직 수정하기 전에 다른 스레드가 객체 B용 메모리를 요청할 수 있는 동시성 문제가 발생할 수 있는 방법

   1. 메모리 할당을 동기화하는 방법으로 비교 및 교환(CAS)과 실패 시 재시도 방식의 VM은 갱신을 원자적으로 수행한다.
   2. 스레드마다 다른 메모리 공간을 할당해 스레드 각각이 자바 힙 내에 작은 크기의 전용 메모리를 미리 할당받아 두는 것이다. 이 방식의 메모리를 **스레드 로컬 할당 버퍼**(TLAB)라고 한다. 각 스레드는 로컬 버퍼에서 메모리를 할당받아 사용하다가 버퍼가 부족해지면 동기화를 해 새로운 버퍼를 할당받는 식으로 동작한다.
      ![chapter2_memory_thread_local.png](/image/chapter2_memory_thread_local.png)
      
    메모리 할당이 끝났으면 가상 머신은 공간을 0으로 초기화한다. 스레드 로컬 할당 버퍼를 사용한다면 초기화는 TLAB 할당 시 미리 수행한다. 
객체 헤더에는 클래스 메타 정보는 어떻게 찾는지, 해시코드, GC세대 나이 등 이 속한다.
이런 과정이 끝나면 생성자(`<init>()` 메서드)가 아직 실행 전이고 필드가 기본값인 0인 상태로, new 명령어에 이어 `<init>()` 메서드 까지 실행되어 초기화해야 진짜 객체가 완성된다. 
    
    ### 객체의 메모리 레이아웃
    
    핫스팟 가상 머신은 객체를 세 부분으로 나눠 힙에 저장한다.
    
    - 객체 헤더
        - 마크 워드 (해시 코드, GC 세대 나이, 락 정보, 편향된 스레드 아이디 등) : 32 | 64비트의 크기로 한정적인 크기 내에 많은 런타임 정보를 담기위해 데이터 구조는 동적으로 의미를 달리 한다.
        - 클래스 워드 (객체의 클래스 관련 메타데이터를 가리키는 클래스 포인터가 저장) : 이 포인터를 통해 특정 객체가 어느 클래스의 인스턴스인지 런타임에 알 수 있다.
        - 객체가 배열의 경우 배열 길이도 헤더에 저장한다.
    - 인스턴스 데이터 : 객체가 실제로 담고 있는 정보로, 다양한 타입의 필드 내용, 부모 클래스 유무, 부모 클래스의 필드 등을 기록한다. 저장 순서는 JVM 할당 전략 매개 변수와 자바 소스 코드에서 필드를 정의한 순서에 따라 달리지며, 기본 타입 → 일반 객체 포인터 순으로 할당한다.
    - 길이 맞추기용 정렬 패딩(alignment padding) : 존재하지 않을 수도 있고, 의미 없이 자리 확보의 역할만 한다. 핫스팟 JVM의 자동 메모리 관리 시스템에서 객체의 시작 주소는 8바이트의 정수배여야 한다. 즉 모든 객체의 크기가 8바이트의 정수배여야 한다. 그래서 정렬 패딩으로 길이를 8바이트에 맞춘다.
    
    ### 객체에 접근
    
    대다수 객체는 다른 객체 여러 개를 조합해 만들어진다. 그리고 자바 프로그램은 스택에 있는 참조 데이터를 통해 힙에 들어 있는 객체들에 접근해 이를 조작한다. **명세**에는 참조 타입을 단지 ‘객체를 가리키는 참조’라고만 정했을 뿐 힙에서 객체의 정확한 위치를 알아내어 접근하는 구체적인 방법은 규정하지 않았다. 따라서 객체에 접근하는 방식 역시 VM에서 구현하기 나름이며, 주로 **핸들**이나 **다이렉트 포인터** 를 사용해 구현한다. 
    
    - 핸들 : 가장 큰 장점은 참조에 ‘안정적인’ 핸들의 주소가 저장된다는 것이다. GC과정에서 객체가 이동하는 일은 아주 흔하다. 핸들을 이용하면 이렇게 객체의 위치가 바뀌는 상황에서도 참조 자체는 손댈 필요가 없다. 대신 핸들 내 인스턴스 데이터 포인터만 변경하면 된다.

      ![chapter2_variable_handle.png](/image/chapter2_variable_handle_pool.png)
        
    - 다이렉트 포인터 : 자바 힙에 위치한 객체에서 인스턴스 데이터뿐 아니라 타입 데이터에 접근하는 길도 제공해야 한다. 스택의 참조에는 객체의 실제 주소가 바로 저장되어 있다. 가장 큰 장점은 속도다. 핸들을 경유하는 오버헤드가 없기 때문이다. 자바에서는 다른 객체에 접근할 일이 많기 때문에 이 오버헤드도 실행 시간에 영향을 크게 줄 수 있다. 핫스팟은 다이렉트 포인터 방식을 이용한다.

      ![chapter2_direct_pool.png](/image/chapter2_direct_pool.png)


## OutOfMemoryError 예외

**명세**에 따르면 프로그램 카운터 외에도 가상 머신 메모리의 여러 런타임 영역에서 OOM가 날 수 있다.

### 자바 힙 오버플로

자바 힙은 객체 인스턴스를 저장하는 공간으로 객체를 계속 생성하고 그 객체들에 접근할 경로가 살아 있다면 언젠간 힙의 최대 용량을 넘어설 것이다. 그러면 메모리가 오버플로된다. 자바 힙 크기(`-Xms`)를 20MB로 제한하고 자동 확장 방지를 위해 최대 크기(`-Xmx`)도 20MB로 설정한다. 그리고 메모리 오버플로가 됐을 때 가상 머신이 예외 발생 시점의 힙 메모리 스냅숏을 파일로 저장(dump)해주도록 했다. (`-Xx:+HeapDumpOnOutOfMemoryError`)

```kotlin
// VM Option : -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
package org.example

class OOMObject

fun main() {
    val list = mutableListOf<OOMObject>()
    while (true) {
        list.add(OOMObject())
    }
}
```

![OOM 발생](/image/chapter2_heap_oom.png)

OOM 발생

파일로 저장된(dump) 스냅숏 파일을 확인해보면 메모리 누수일 경우 누수된 객체로부터 GC루트까지의 참조 사슬(reference chain)을 살펴볼 수 있다. 이 내용으로 어느 GC루트와 연결되어 있기에 가비지 컬렉터가 회수하지 못했는지 찾아볼 수 있고 누구된 객체의 타입 정보와 GC루트까지의 참조 사슬 정보를 보면 대부분의 경우 해당 객체가 만들어진 위치를 더 정확히 알 수 있다. → 메모리 누수를 일으키는 코드의 위치를 찾을 수 있다.

![OOMObject class 객체의 정보](/image/chapter2_memory_dump.png)

OOMObject class 객체의 정보

![GC Root](/image/chapter2_gc_root.png)

GC Root

### 가상 머신 스택과 네이티브 메서드 스택 오버플로

핫스팟VM은 VM Stack과 Native Method Stack을 구분하지 않는다. 따라서 네이티브 메서드 스택의 크기를 설정하는 `-Xoss` 매개 변수를 설정해도 효과가 없다. 스택 크기는 오직 `-Xss` 매개 변수로만 변경 가능하다. **명세**에 따르면 다음 두 경우에 예외가 발생한다.

1. 스레드가 요구하는 스택 깊이가 VM이 허용하는 최대 깊이보다 크면 `StackOverflowError`를 던진다.
2. VM이 스택 메모리를 동적으로 확장하는 기능을 지원하나, 가용 메모리가 부족해 스택을 더 확장할 수 없다면 `OutOfMemoryError`를 던진다.

**명세**에서는 분명 스택을 동적으로 확장할 수 있는 여지를 주었지만 핫스팟 VM은 확장을 지원하지 않는다. 따라서 스레드를 생성할 때 메모리가 부족하여 OOM이 나는 경우를 제외하고는 스레드가 실행 중에 VM 스택이 넘치는 일은 없다. 즉, 스택 용량이 부족하여 새로운 스택 프레임을 담을 수 없을 때만 `StackOverflowError`가 발생한다.

- `-Xss` 매개 변수로 스택 메모리 용량을 줄인다. 결과를 `StackOverflowError` 발생이다. 예외 발생 시 출력된 스택 깊이는 의도대로 축소되어 있다.
- 지역 변수를 많이 선언해서 메서드 프레임의 지역 변수 테이블 크기를 키운다. 결과는 `StackOverflowError` 발생이다. 예외 발생 시 출력된 스택 깊이는 의도대로 축소되어 있다.

```kotlin
class StackTest {
    var stackLength = 1

    private fun stackLeak() {
        stackLength++
        stackLeak()
    }

    // VM Option : -Xss256k (예제의 180k 는 너무 작아서 실행안됨)
    // The Java thread stack size specified is too small. Specify at least 208k
    fun stackSOF_1() {
        try {
            stackLeak()
        } catch (t: Throwable) {
            println("Stack length : ${stackLength}")
            throw t
        }
    }
}
```

![chapter2_stack_log](/image/chapter2_stack_log.png)

```kotlin
private fun varTest() {
	var unused: Long
	var unused1: Long
	...
	var unused100: Long
}

fun stackSOF_2() {
	try {
	    varTest()
	} catch (e: Error) {
	    println("Stack length : ${stackLength}")
	    throw e
	}
}
```

![chapter2_stack_log2](/image/chapter2_stack_log2.png)

```kotlin
 private fun thredTest() {
        while (true) {}
    }

    fun stackLeakByThread() {
        while (true) {
            Thread().run {
                thredTest()
            }
        }
    }
```

이건 예외가 잘 안일어나서 패스..

### 메서드 영역과 런타임 상수 풀 오버플로

런타임 상수 풀은 메서드 영역에 속하므로 이 두 영역의 오버플로 테스트는 함께 수행할 수 있다. 앞서 핫스팟은 JDK7 부터 영구세대를 점진적으로 없애서 JDK8에서 메타스페이스로 완전히 대체했다. 이번 테스트는 메서드 영역을 ‘영구 세대’에 구현했는지, ‘메타스페이스’에 구현했는지 확인하는 테스트 코드다.

`String::intern()`은 네이티브 메서드로 문자열 상수 풀에 이 메서드가 호출된 String 객체와 똑같은 문자열이 이미 존재한다면 풀에 있던 기존 문자열의 참조를 반환한다. 같은 문자열이 없다면 현재 String 객체에 담긴 문자열이 상수 풀에 추가되고 이 String의 참조가 반환된다. JDK 6까지 핫스팟은 상수 풀을 영구 세대에 할당했다. 영구 세대의 크기는 `-XX:PermSize`와 `-XX:MaxPermSize` 매개 변수로 조절할 수 있고, 이는 상수 풀 용량에도 간접적으로 영향을 준다.

```kotlin
// -XX:MetaspaceSize=6M -XX:MaxMetaspaceSize=6M
class RuntimePoolTest {
    var set = HashSet<String>()
    var i: Short = 0

    fun whileTest() {
        while(true) {
            set.add(i++.toString().intern())
        }
    }
}
```

![chapter2_runtime_log](/image/chapter2_runtime_log.png)

### 네이티브 다이렉트 메모리 오버플로

다이렉트 메모리의 용량은 `-XX:MaxDirectMemorySize` 매개 변수로 설정한다. 따로 설정하지 않았다면 기본적으로 `-Xmx`로 설정한 자바 힙의 최댓값과 같다. 예제 코드는 NIO 의 DirectByteBuffer 클래스를 건너뛰고 리플렉션을 이용해 Unsafe 인스턴스를 직접 얻어 메모리를 할당받고 있다. DirectByteBuffer를 통해 메모리를 할당해도 오버플로될 수는 있지만, 이 경우는 운영 체제 단에서 메모리를 할당하느라 나는 예외가 아니다. 하지만 Unsafe를 이용하면 할당할 수 없는 크기를 계산해 오버플로를 수동으로 일으킬 수 있다. `Unsafe::allocateMemory()`가 메모리를 할당하는 메서드다.

```kotlin
// -Xmx20M -XX:MaxDirectMemorySize=10M
class DirectMemoryOOMTest {
    val _1MB: Long = 1024 * 1024

    fun directMemoryTest() {
        val field = Unsafe::class.java.getDeclaredFields()[0]
        field.setAccessible(true)
        val unsafe: Unsafe = field.get(null) as Unsafe
        while (true) {
            unsafe.allocateMemory(_1MB)
        }
    }
}
```