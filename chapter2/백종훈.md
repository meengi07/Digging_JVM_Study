자바 개발자는 JVM에서 제공하는 자동 메모리 관리 메커니즘 덕에 메모리 할당과 해제라는 작업에서 자유로울 수 있다. 하지만 문제가 발생하게 되면 JVM의 메모리 관리 방식을 이해하지 못하는 한 문제 해결이 상당히 어려워진다.
그렇기 때문에 JVM이 관리하는 다양한 메모리 영역과 각 영역의 역할 등에 대해 알아둬야 한다.
## 2.1 런타임 데이터 영역
![[100. 기타 파일/JVM 구조.png]]
#### 2.2.1 프로그램 카운터
프로그램 카운터 레지스터는 작은 메모리 영역으로, 현재 실행 중인 스레드의 '바이트 코드 줄 번호 표시기'라고 볼 수 있다. 다시 말해 프로그램의 제어 흐름, 분기, 순환, 점프 등을 표현한 것이다.
JVM의 멀티 스레딩은 CPU 코어를 여러 스레드가 교대로 사용하며, 특정 시각에 각 코어는 한 스레드의 명령어만 실행하게 된다. 그러므로 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하려면 스레드 각각에는 고유한 프로그램 카운터가 필요하다. 이러한 이유 때문에 **프로그램 카운터(PC)레지스터는 각 스레드의 고유한 공간에 저장된다.**
>[!NOTE]
> 스레드가 자바 메서드를 실행할 땐, 바이트 코드 명령어의 주소가 저장되지만 네이티브 메서드를 실행할 땐 Undefined가 프로그램 카운터에 저장된다.
#### 2.2.2 자바 가상 머신 스택
가상 머신 스택도 스레드 프라이빗하며, 연결된 스레드와 생명주기가 같다. 자바에서 각 **메서드가 호출될 때마다 자바 가상 머신은 스택 프레임을 만들어 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등의 정보를 저장**한다. 이후 스택 프레임을 가상 머신 스택에 push, pop을 반복한다.

지역 변수 테이블에는 자바 가상 머신이 컴파일 타임에 알 수 있는 다양한 기본 데이터 타입, 객체 참조, 반환 주소 타입을 저장한다. 그리고 지역 변수 테이블에서 이러한 데이터 타입들을 저장하는 공간을 지역 변수 슬롯이라고 한다.

지역 변수 테이블을 구성하는 데 필요한 데이터 공간은 컴파일 과정에서 할당된다. 다시 말해 런타임에 해당 공간의 크기(슬롯 개수)는 변하지 않는다.
>[!NOTE]
반환 주소 타입이란?
>  return 문이 실행될 때, 어느 위치로 돌아가야 하는지를 가리킴
>  일반적인 자바 코드에선 다룰 일이 없고, 보통 바이트 코드 수준에서 존재함

#### 2.2.3 네이티브 메서드 스택
가상 머신 스택과 비슷한 역할을 하지만 대상이 네이티브 메서드라는 점에서 다르다. 자바 가상 머신 며엣에 네이티브 메서드 스택에 대해 명시된 것이 없어 네이티브 메서드 스택과 가상 머신 스택을 하나로 합쳐 놓은 가상 머신도 존재한다. 대표적으로 핫스팟 가상 머신이 그러하다.
#### 2.2.4 자바 힙
힙은 모든 스레드가 공유하는 메모리 영역이며 자바 애플리케이션이 사용할 수 있는 가장 큰 공간이다. 해당 영역의 유일한 목적은 **객체 인스턴스를 저장**하는 것이다.
메모리 할당 관점에서 자바 힙은 모든 스레드가 공유한다. 따라서 객체 할당 효율을 높이고자 스레드 로컬 할당 버퍼 여러 개로 나뉜다. 이와 같이 작게 구분하는 이유는 오직 메모리 회수와 할당을 더 빠르게 하기 위함이다.
힙은 물리적으로 떨어진 메모리에 위치해도 상관 없으나 논리적으로는 연속되어야 한다.
> 구현 관점에서 자바 언어가 계속 발전하면서 앞으로는 값 타입도 지원할 것으로 보인다.
> 따라서 모든 자바 객체 인스턴스가 힙에 할당된다는 설명이 절대적 진리라고 보기에는 조금씩 애매해지고 있다.
> -> 메서드 내부에서만 사용되는 객체라면 굳이 힙에 할당할 필요 없이 스택에 할당하여 최적화 할 수 있다는 의미?

>[!NOTE]
신세대? 구세대? 에덴 공간?
> 자바 힙을 설명할 때 신세대, 구세대, 영구 세대, 에덴 공간, 생존자 공간에서부터 등의 용어는 GC의 일반적 특성 또는 설계 방식일 뿐이다.

#### 2.2.5 메서드 영역
메서드 영역도 모든 스레드가 공유하는 영역이다. 해당 영역의 목적은 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고 JIT 컴파일러가 컴파일한 코드 캐시 등을 저장하는데 이용된다.
과거 핫스팟 가상 머신 개발 팀에서 GC의 수집 범위를 메서드 영역까지 확장하기로 결정했다. 그래서 메서드 영역을 영구 세대에 구현했다. 이 때문에 많은 사람들이 메서드 영역 == 영구 세대라고 개념을 혼동했다. 자바 가상 머신 명세에선 원칙적으로 메서드 영역을 어떻게 구현할지는 강제하지 않았기에 발생한 현상이었다. 메서드 영역을 영구 세대에 구현한 결정은 오히려 좋은 생각이 아니었다. 메모리 오버 플로를 겪을 가능성이 높아지기 때문이다. JDK 8이 되면서 영구 세대라는 개념을 완전히 지우고 네이티브 메모리에 메타스페이스를 구현했다.
메서드 영역에서 회수할 대상은 거의 대부분 상수 풀과 타입이라서 회수 효과가 상대적으로 매우 작다.
>[!NOTE]
>자바 가상 머신 명세에서는 메서드 영역도 논리적으로는 힙의 한 부분으로 기술하지만, 자바 힙과 구분하기 위해 논힙이라고 부르기도 한다.
#### 2.2.6 런타임 상수 풀
런타임 상수 풀은 메서드 영역의 일부다. 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 메타 데이터에 더해 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다.
클래스 파일의 상수 풀과 비교해 런타임 상수 풀의 주요한 특징은 바로 동적이라는 점이다.
자바 언어에서는 상수가 꼭 컴파일 타임에 생성되어야 한다는 규칙이 없다. **즉, 상수 풀의 내용 전부가 클래스 파일에 미리 완벽하게 기술되어 있는 것이 아니다.**
#### 2.2.7 다이렉트 메모리
다이렉트 메모리는 가상 머신 런타임에 속하지 않으며 자바 가상 머신 명세에 정의된 영역도 아니다. 해당 영역은 물리 메모리를 직접 할당하기에 자바 힙 크기의 제약과는 무관하지만 이 또한 메모리라는 점을 간과해선 안된다.
## 2.3 핫스팟 가상 머신에서의 객체 들여다 보기
#### 2.3.1 객체 생성
JVM이 new 명령에 해당하는 바이트 코드를 만나면, 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인한다. 그 다음 이 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화 되었는지 확인한다. 만약 로드되지 않았다면 .class 파일을 읽어와 메서드 영역에 클래스 정보를 로딩한다.  
로딩이 완료된 클래스라면 새 객체를 담을 메모리를 할당한다. 객체용 메모리 공간 할당은 자바 힙에서 특정 크기의 메모리 블록을 잘라 주는 일이라고 볼 수 있다. 자바 힙이 완벽하게 규칙적이라면 메모리 할당 이후 포인터를 여유 공간쪽으로 '포인터 밀치기'를 객체 크기만큼 하면 된다.
하지만 자바 힙은 규칙적이지 않기 때문에 포인터 밀치기가 쉽지 않다. 그렇기에 **가용 메모리 블록들을 목록으로 따로 관리**하며, 객체 인스턴스를 담기에 충분한 공간을 찾아 할당 후 목록을 갱신한다. 이를 여유 목록(free list)라고 한다. 자바 힙의 규칙적이냐 아니냐는 GC가 컴팩트를 할 수 있느냐에 달렸다.
>[!NOTE]
포인터 밀치기란?
>![[포인터 밀치기.png]]
>객체 크기만큼의 메모리 할당 이후 여유 공간으로 포인터를 이동하는 작업

멀티 스레딩 환경에서 여유 메모리의 시작 포인터 위치를 수정하는 단순한 일도 스레드 세이프하지 않기 때문에 여러 스레드가 동시에 객체를 생성한다면 문제가 발생할 수 있다.
이에 대한 해결책은 두 가지다.
- **메모리 할당 동기화**
  - 비교 및 교환 실패 시 갱신을 원자적으로 수행
- **스레드마다 다른 메모리 공간을 할당**
  - 스레드 각각이 자바 힙 내에 작은 크기의 전용 메모리를 미리 할당 받음(Thread Local Allocation Buffer - TLAB)
  - ![[TLAB.png]]

메모리 할당이 끝났으면 가상 머신은 할당 받은 공간을 0으로 초기화한다(헤더 제외). TLAB을 사용한다면 초기화는 TLAB 할당 시 미리 수행한다. 이로 인해 자바에선 객체 인스턴스 필드를 초기화 하지 않고도 사용할 수 있다.
이후 JVM은 각 객체의 메타 데이터(클래스 타입, 클래스 메타 정보 찾는 방법, GC 나이 등)를 객체 헤더에 저장한다.
여기까지가 가상 머신 관점에서 새 객체가 생성되는 과정이다. 이후 자바 프로그램 관점에서 init() 메서드가 실행되어 객체를 개발자 의도대로 초기화되는 과정이 진행된다.
>[!NOTE]
>자바 컴파일러는 자바의 new 키워드를 발견하면 바이트 코드 명령어인 new와 invokespecial로 변환한다. 바이트 코드의 new는 vm관점에서, invokespecial은 자바 프로그램 관점에서 init()을 호출한다. 만약 new 키워드를 사용하지 않고 객체를 생성했다면 invokespecial은 나오지 않을 수도 있다.

#### 2.3.2 객체의 메모리 레이아웃
![[객체의 메모리 레이아웃.png]]
핫스팟 VM은 객체를 세 부분으로 나눠 힙에 저장한다.
##### 객체 헤더
객체 헤더엔 두 유형의 정보를 담는다.
- **마크 워드 - 객체 자체의 런타임 데이터**
  - 해시코드, GC 세대 나이, 락 상태 플래그, 스레드가 점유하고 있는 락들
  - 32비트 VM에선 32비트 64비트 VM에선 64비트의 크기를 가지며 객체 자체가 정의한 데이터와 관련 없는 정보까지 담아야 해서 한정된 메모리를 효율적으로 써야 함
- **클래스 워드 - 클래스 포인터 저장**
  - 객체의 클래스 관련 메타 데이터를 가리키는 클래스 포인터를 저장하며, JVM은 **이 포인터를 통해 특정 객체가 어느 클래스의 인스턴스인지 런타임에 식별**
##### 인스턴스 데이터
인스턴스 데이터는 객체가 실제로 담고 있는 정보다. 프로그램 코드에서 정의한 다양한 내용을 담는다.
이러한 데이터의 저장 순서는 가상 머신의 할당 전략 매개 변수(-XX:FieldAllocationStyle)와 소스 코드에 필드를 정의한 순서에 따라 달라진다. 기본적으로는 long과 double -> int -> short와 char -> byte와 boolean -> 일반 객체 포인터 순으로 할당된다.
##### 정렬 패딩
핫스팟 VM의 자동 메모리 관리 시스템에서 객체의 시작 주소는 반드시 8바이트의 정수배여야 한다. 즉, 모든 객체의 크기가 8바이트의 정수배여야 하고, 이를 맞춰주기 위해 정렬 패딩이 존재한다. 객체 헤더의 경우 정확히 정수배가 되도록 설계되어 있지만 인스턴스 데이터를 그렇지 않다.
#### 2.3.3 객체에 접근하기
자바 프로그램은 스택에 있는 참조 데이터를 통해 힙에 들어 있는 객체들에게 접근할 수 있다. 자바 가상 머신 명세에선 힙에서 객체의 정확한 위치를 알아내 접근하는 방법에 대해 명시하지 않기에 주로 두 가지 방법으로 구현된다.
- **핸들을 이용한 객체 접근**
  - ![[핸들을 이용해 객체에 접근하기.png]]
  - 힙 영역에 핸들 저장용 풀이 별도 존재
  - 스택의 참조 데이터엔 핸들 주소가 저장
  - 핸들에는 해당 객체의 인스턴스 데이터, 타입 데이터 및 구조 등의 정확한 주소 정보를 저장
  - 핸들을 이용할 경우 객체의 위치가 바뀌어도 참조 자체엔 변경이 일어나지 않는 장점
- **다이렉트 포인터 방식**
  - ![[다이렉트 포인터 방식.png]]
  - 힙에 위치한 객체에서 인스턴스 데이터 + 타입 데이터를 확인할 수 있는 경로를 저장
  - 참조에 객체의 실제 주소가 저장
  - 핸들 방식보다 오버헤드가 적어 빠름
  - 핫스팟 VM도 해당 방식을 사용
## 2.4 실전 : OutOfMemoryError 예외
이번 절의 핵심은 두 가지 실용적인 목적에 있다.
- **자바 가상 머신 명세에 정의된 각 런타임 영역에 저장되는 내용을 검증**
- **실제 메모리 오버플로가 일어나는 과정을 경험**
  예제는 OpenJDK 17의 핫스팟 VM을 기준으로 한다.
#### 2.4.1 자바 힙 오버플로
```Java
/**
* VM 매개변수 : -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
* 순서대로 최소 힙 크기, 최대 힙 크기, 메모리 오버 플로시 예외 발생 시점의 스냅샷 파일로 덤핑
**/
public class HeapOOM {
	static class OOMObject {
	}

	public static void main(String[] args) {
		List<OOMObject> list = new ArrayList<>();
	
		while(true) {
			list.add(new OOMObject());
		}
	}
}

/**
java.lang.OutOfMemoryError: Java heap space 
...
**/
```
예외 메세지에서 확인할 수 있듯 힙 메모리 영역에서 발생하는 에러다.
이 문제를 해결하는 방법은 메모리 이미지 분석 도구로 힙 덤프 스냅샷을 분석하는 것이다.
- 오버플로를 일으킨 객체가 꼭 필요한 객체인가 확인
  - 메모리 누수 or 오버플로를 확인
- 메모리 누수인 경우 누수된 객체로부터 GC 루트까지의 참조 사슬을 확인
  - 메모리 누수를 일으키는 코드의 정확한 위치를 확인
- 메모리 누수가 아닌 경우
  - 힙 사이즈를 조절할 수 있는지 확인
  - 코드 레벨에서 수명 주기가 너무 길거나 상태를 오래 유지하는 객체가 존재하는지 확인
  - 공간 낭비가 심한 자료 구조를 사용하는지 확인
#### 2.4.2 가상 머신 스택과 네이티브 메서드 스택 오버플로
핫스팟 VM은 가상 머신 스택과 네이티브 메서드 스택을 구분하지 않는다.
자바 가상 머신 명세에 따르면 스택(VM+네이티브)에선 다음 두 경우에 예외가 발생한다.
- 스레드가 요구하는 스택 깊이가 VM이 허용하는 것보다 깊으면 StackOverflowError
- VM이 스택 메모리를 동적으로 확장하는 기능을 지원하나, 가용 메모리가 부족하여 스택을 확장 못하면 OutOfMemoryError
```Java
/**
* VM 매개 변수 : -Xss180k
**/
public class JavaVMStackSOF_1 {
	private int stackLength = 1;

	public void stackLeak() {
		stackLength++;
		stackLeak();
	}

	public static void main(String[] args) throws Throwable {
		JavaVMStackSOF_1 oom = new JavaVMStackSOF_1();
		try {
			oom.stackLeak();
		} catch (Throwable e) {
			System.out.println("스택 길이" + oom.stackLength);
			throw e;
		}
	}
}
/**
	스택 길이: 1558
	Exception in thread "main" java.lang.StackOverflowError
**/

public class JavaVMStackSOF_2 {
	private static int stackLength = 0;

	public static void test() {
		long unused1, ... , unused100;
		
		stackLength++;
		test();
	
		unused1 = unused2 = unused3 ... = unused = 0;
	}

	public static void main(String[] args) throws Throwable {
		try {
			test();
		} catch (Error e) {
			System.out.println("스택 길이" + oom.stackLength);
			throw e;
		}
	}
}

/**
	스택 길이 : 5063
	Exception in thread "main" java.lang.StackOverflowError
**/
```
같은 코드를 윈도우와 JDK 1.0.2환경(클래식 VM)에서 실행하면 OOM이 발생한다.
여기서 핵심은 단일 스레드로 제한 했다는 점이다. 그렇기에 매번 StackOverflow가 발생하는 것이다.
만약 계속해서 스레드를 만들어내면 핫스팟 VM에서도 OOM을 발생시킬 수 있다.
-> OS가 각 프로세스에 할당하는 메모리 크기가 제한적이기 때문
따라서 각 스레드에 스택 메모리를 많이 할당하면 생성할 수 있는 스레드 수가 적어진다.
핵심은 프로세스에 할당되는 메모리와 스레드에 할당될 스택 메모리의 양의 관계다.
#### 2.4.3 메서드 영역과 런타임 상수 풀 오버플로
```Java
/**
* VM 매개 변수 : (JDK 7 이하) -XX:PermSize=6M -XX:MaxPermSize=6M
* VM 매개 변수 : (JDK 8 이상) -XX:MetaspaceSize=6M -XX:MaxMetaspaceSize=6M
**/
public class RuntimeConstantPoolOOM_1 {  
    public static void main(String[] args) {  
        // 전체 GC가 상수 풀을 회수하지 못하도록 집합(Set)을 이용해 
        // 상수 풀의 참조를 유지  
        Set<String> set = new HashSet<>();  
  
        // short 타입의 범위면 6MB 크기의 영구 세대에서 오버플로를 일으키기 충분함  
        short i = 0;  
  
        while(true) {  
            set.add(String.valueOf(i++).intern());  
        }  
    }  
}
/** Java 7 미만
	Exception in thread "main" java.lang.OutOfMemoryError: PermGen space
	at java.lang.String.intern (Native Method)
**/
/** Java 7 이상
	Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
**/

public class RuntimeConstantPoolOOM_2 {  
    public static void main(String[] args) {  
        String str1 = new StringBuilder("컴퓨터").append(" 소프트웨어").toString();  
        System.out.println(str1.intern() == str1); // JDK 17기준 true 반환
    }  
}
```
Java 7 미만, 이상의 에러 메세지가 다르다. 이는 영구 세대에 저장했던 문자열 상수 풀을 JDK 7부터 자바 Heap으로 옮겼기 때문이다.
-> 실제 테스트 결과 JDK 8(Amazon correto, -Xmx6m), OpenJDK 17 기준 OOM을 확인하기 어렵다.

RuntimeConstantPoolOOM_2를 실행하면 JDK 6에선 false를 7에선 true를 반환
- JDK 6
  - intern()을 통해 생성된 문자열은 영구 세대의 문자열 상수 풀에 저장
  - StringBuilder로 생성된 문자열은 Heap에 존재
- JDK 7
  - 문자열 인스턴스를 복사하지 않고 참조만 바꿔줌
```Java
/**
* VM 매개 변수 : (JDK 7 이하) -XX:PermSize=10M -XX:MaxPermSize=10M
* VM 매개 변수 : (JDK 8 이상) -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M
**/
public class JavaMethodAreaOOM {  
    public static void main(String[] args) {
	    Enhancer enhancer = new Enhancer();
	    enhancer.setSuperclass(OOMObject.class);
	    enhancer.setUseCache(false);
	    enhancer.setCallback(new MethodInterceptor() { ... });

		enhancer.create();
	}  

	static class OOMObject {
	}
}

/** 
	Exception in thread "main" java.lang.OutOfMemoryError: Metaspace
**/
```
위 코드는 CGLIB로 런타임에 바이트 코드를 조작해 다량의 클래스를 동적으로 생성한다. 이를 통해 메서드 영역에 OOM을 야기할 수 있다.
GC가 클래스 하나를 회수하기 위한 조건은 까다롭기 때문에 CGLIB와 같은 기술을 사용할 땐 특별히 주의해야 한다.

>[!NOTE]
> **String::intern()**
> "abc".intern()을 호출했을 때, 문자열 상수 풀에 같은 문자열이 존재한다면 기존 문자열의참조를 반환하는 메서드

#### * JVM 메모리 영역 정리
![[영구세대 VS 메타스페이스.png]]
- **JDK 7 이전**
  - Heap 영역 중 일부인 영구 세대에 메서드 영역을 구현
  - 메서드 영역엔 클래스의 메타 데이터, 런타임 상수 풀, String 상수 풀 등이 존재
- **JDK 8 이후**
  - 클래스의 메타 데이터들은 '메타스페이스'라는 네이티브 메모리 영역에 저장
  - 메서드 영역 또한 메타스페이스로 이동
  - String 상수 풀은 Heap 영역에 여전히 존재
- **클래스 데이터 로딩 과정**
  - 컴파일시 클래스의 메타 데이터가 심볼릭 참조 형태로 디스크에 저장(.class)되고 이를 클래스 파일 상수 풀 또는 상수 풀 테이블이라고 부름
  - JVM이 실행되면 클래스를 로드하고, 상수 풀 테이블에서 데이터를 가져와 런타임 상수 풀과 메타스페이스에 데이터를 저장
  - 이 때, 런타임 상수 풀은 숫자 리터럴, 문자열 리터럴 참조 등의 상수 데이터를 저장하고 메타스페이스엔 클래스의 메타 데이터가 저장됨

>[!NOTE]
>**다양한 종류의 상수 풀**
>- **클래스 파일 상수 풀(Constant Pool in Class File)**
   >	- 클래스 버전, 필드, 메서드, 인터페이스 등
          >	- 클래스 파일에 포함된 설명 정보 + 컴파일 타임에 생성된 리터럴, 심벌 참조를 저장
>- **런타임 상수 풀(Runtime Constant Pool)**
   >	- 메서드 영역의 일부
          >	- VM이 클래스를 로드할 때 상수 풀의 정보를 런타임 상수 풀에 저장
>	- 상수 풀과 달리 동적
>- **문자열 상수 풀(String Constant Pool)**
   >	- JDK 7부터 Heap 영역에 저장
          >	- JDK 7 이전엔 영구 세대 저장

>[!NOTE]
>**클래스 파일 상수 풀과 메타스페이스 영역**
> 클래스 파일 상수 풀과 메타스페이스 영역 둘 다 같은 데이터를 저장하지만 시점에 따라 저장하는 방식이 다르다고 볼 수 있다.
>- 클래스 파일 상수 풀은 컴파일 시점에 클래스 메타 데이터를 심볼릭 참조 형태로 저장
>- 메타스페이스 영역은 런타임에 JVM을 통해 로드된 클래스의 상수 풀 테이블에 저장된 심볼릭 참조 값을 활용해 실제 메모리 참조 값으로 저장한다.
>- 즉, 클래스 파일 상수 풀은 컴파일 시점에 디스크에 데이터를 저장
>- 메타스페이스 영역은 런타임에 클래스 메타 데이터를 네이티브 메모리에 저장

>[!NOTE]
>**영구세대**
>JDK 7 이전엔 클래스의 메타 데이터, 메서드 정보, 정적 변수 등을 영구 세대에 저장
>영구 세대는 Heap 영역의 일부로 크기가 고정되어 있어 OOM발생 가능성이 높음

>[!NOTE]
>**심볼릭 참조**
>실제 메모리 주소를 나타내는 직접 참조와 달리 **문자열 또는 기호로 특정 클래스, 메서드 필드 등을 간접 참조하는 것**

참고 :
- https://jaemunbro.medium.com/java-metaspace%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-ac363816d35e
- https://deveric.tistory.com/123