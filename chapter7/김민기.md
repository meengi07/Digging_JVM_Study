# 7. 클래스 로딩 메커니즘

JVM은 클래스를 설명하는 데이터를 클래스 파일로부터 메모리로 읽고 데이터를 검증, 변환, 초기화하고 JVM이 사용할 수 있는 자바 타입을 생성함 이 과정을 **클래스 로딩 메커니즘**이라 한다.

컴파일 시 클래스 로딩, 링킹, 초기화가 모두 ‘런타임’에 이뤄지므로, AOT 컴파일에 제약이 생기고 클래스 로딩을 거치느라 실행 성능이 살짝 떨어지지만 자바 애플리케이션의 높은 확장성과 유연성을 가진다.

자바가 동적 확장 언어 기능을 제공할 수 있는 것은 런타임에 이뤄지는 동적 로딩과 링킹 덕 이다.


## 클래스 로딩 시점
타입의 생애 주기는 가상 머신의 메모리에 로드되는 걸 시작으로 다시 언로드될 때까지
로딩 -> 검증 -> 준비 -> 해석 -> 초기화 -> 사용 -> 언로딩 과정을 거친다. 이 중 검증, 준비, 해석 단계를 링킹이라고 한다.

![mingi-7.1.png](/image/mingi-7.1.png)


로딩 -> 검증 -> 준비 -> 초기화 -> 언로딩은 반드시 순서대로 진행해야 한다.
그리고 '로딩' 단계는 어떤 상황에서 시작해야 하는지 명세되있지 않지만, '초기화'는 즉시 시작되어야 하는 상황 여섯 가지를 엄격히 규정
1. 바이트코드 명령어인 new, getstatic, putstatic, invokestatic 을 만났을 때 해당 타입이 아직 초기화되어 있지 않다면 초기화를 촉발한다. 이 명령어들의 시나로이는 다음과 같음
    1. new 키워드로 객체의 인스턴스 생성
    2. 타입의 정적 필드를 읽거나 설정(final로 지정된 정적 필드는 컴파일타임에 상수 풀에 채워지므로 제외)
    3. 타입의 정적 메서드 호출
2. class 클래스나 java.lang.reflect 패키지 등 표준 클래스 라이브러리에서 제공하는 리플렉션 메서드를 사용할 때 해당 타입이 아직 초기화되어 있지 않다면 초기화를 촉발한다.
3. 클래스를 초기화할 때 상위 클래스가 초기화되어 있지 않다면 상위 클래스 초기화를 촉발한다.
4. 가상 머신은 구동 직후 사용자가 지정한 메인 타입(main() 메서드를 포함하는 클래스나 인터페이스)을 찾아 실행한다. 이때 메인 타입의 초기화를 먼저 시작
5. `REF_getStatic`, `REF_putStatic`, `REF_invokeStatic`, `REF_newInvokeSpecial` 타입 메서드 핸들을 해석해 얻은 java.lang.invoke.MethodHandle 인스턴스를 호출할 때 해당하는 클래스가 초기화되어 있지 않았다면 초기화를 촉발
6. 인터페이스에 디폴트 메서드를 정의했다면, 해당 인터페이스를 직간접적으로 구현한 클래스가 초기화될 때 인터페이스부터 초기화

위에 타입 초기화를 촉발하는 상황 여섯가지를 능동 참조(active reference)며, 반대로 그 외 참조는 수동 참조(passive reference)라고 함

수동 참조 예시 3가지
```java 
class SuperClass {
	static {
		System.out.println("상위 초기화");
	}
	public static int value = 123;
}	

class SubClass extends SuperClass {
	static {
		System.out.println("하위 초기화");
	}
}
```

1. 정적 필드를 참조할 때 필드를 직접 정의한 클래스만 초기화됨, 상위 클래스에 정의된 필드를 하위 클래스를 통해 참조하면 하위 클래스는 초기화되지 않음
```java 
public class NotInit {
	public static void main(String[] args) {
		System.out.println(SubClass.value);
	}
}
```

2. 배열 정의에서 클래스를 참조하는 경우 클래스 초기화를 촉발하지 않는다.
```java
package org.exam.jvm.chapter7;

public class NotInit_2 {
	public static void main(String[] args) {
		SuperClass[] sca = new SuperClass[10];
	}
}
```
해당 케이스의 경우 org.exam.jvm.chapter7.SuperClass가 아닌, Lorg.exam.jvm.chapter7.SuperClass라는 초기화 단계를 촉발함. 이는 jvm이 java.lang.Object 로 상속하여 자동 생성한 하위 클래스다. 이런 클래스는 원소타입(element type)이 SuperClass 인 **일차원 배열** 인데, 자바 소스 코드에서 제공하는 속성과 메서드를 구현한 실체가 이 클래스다. 자바 배열이 C, C++ 보다 안전한 이유는 *배열 원소로 직접 접근하지 못하도록 이 클래스가 감싸기 때문*이고, 배열 범위를 벗어나 접근하는 경우 **ArrayIndexOutOfBoundsException**을 던진다.

3. 상수는 컴파일 과정에서 호출하는 클래스의 상수 풀에 저장, 직접 참조가 없는 셈으로 초기화 x
```java
package org.exam.jvm.chapter7;

class ConstClass {
	static {
		System.out.println("ConstClass");
	}
	public static final String HELLO_WORLD = "hello world";
}

public class NotInit_3 {
	public static void main(String[] args) {
		System.out.println(ConstClass.HELLO_WORLD);
	}
}
```
컴파일 과정에서 상수 전파 최적화가 이뤄지기 때문, NotInit_3 클래스에 상수 풀에 "hello world" 가 저장됨,


## 클래스 로딩 처리 과정
### 로딩, *클래스 로딩의 전체 과정 중 한 단계.*
1. 완전한 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림을 가져옴
2. 바이트 스트림으로 표현된 정적인 저장 구조를 메서드 영역에서 사용하는 런타임 데이터 구조로 변환
3. 로딩 대상 클래스를 표현하는 java.lang.Class 객체를 힙 메모리에 생성, 이 Class 객체는 애플리케이션이 메서드 영역에 저장된 타입 데이터를 활용할 수 있게 하는 통로

배열 외 타입의 로딩(로딩 단계에서 클래스의 바이너리 바이트 스트림을 얻는 동작)은 제어하기 쉽다.
로딩 단계는 JVM에 내장된 부트스트랩 클래스 로더를 사용하거나 사용자 정의 클래스 로더를 사용할 수 있다.

ClassLoader의 findClass(), loadClass() 메서드로 오버라이딩하면 바이트 스트림 얻는 방법을 통제 가능함 이 방법으로 애플리케이션에 필요한 코드를 동적으로 가져와 실행하는 역동성을 얻음

배열 클래스는 다른데, 클래스 로더가 생성하지 않고 JVM이 직접 메모리에 동적으로 생성함, 그렇다고 클래스 로더와 관계가 끊기는 건 아니고, 배열 클래스의 원소 타입은 클래스 로더를 통해 로드된다.

배열 클래스 생성 과정은 다음과 같다
1. 배열의 컴포넌트 타입(배열의 첫 번째 차원이 제거된 타입)이 참조 타입이면 로딩 과정을 재귀적으로 수행하여 컴포넌트 타입을 로딩, 배열 C는 컴포넌트 타입을 로드하는 클래스로더의 이름 공간(namespace)에 자리함
2. 배열의 컴포넌트 타입이 참조 타입이 아니면, JVM은 배열C를 부트스트랩 클래스 로더에 맡김
3. 배열 클래스의 접근성은 해당 컴포넌트 타입과 같고, 컴포넌트 타입이 참조 타입이 아닌 배열 클래스라면 public 이라 모든 클래스와 인터페이스에서 접근 가능

로딩 단계가 끝나면 바이너리 바이트 스트림은 JVM이 정의한 형식에 맞게 메서드 영역에 저장됨, 메서드 영역의 데이터 저장 형식에 대해선 명세에서 아무것도 정의하지 않음, 타입 정보를 메서드 영역에 저장한 다음 java.lang.Class 객체를 자바 힙에 초기화함, 로딩 단계와 링킹 단계의 일부 동작은 서로 중첩되어 진행됨 즉, 로딩 단계가 끝나기 전에 링킹 단계가 시작될 수 있다.

### 검증, *첫 번째 링킹 과정*
검증의 목적은 두가지
1. 클래스 파일의 바이트 스트림에 담긴 정보가 명세에서 규정한 모든 제약을 만족하는지 확인
2. 이 정보를 코드로 변환해 실행했을 때 JVM 자체의 보안을 위협하지 않는지 확인

네 가지 단계로 검증 단계를 구분한다.
1. 파일 형식 검증 : 바이트 스트림이 클래스 파일 형식에 부합하고 현재 버전의 가상 머신이 처리할 수 있는지 확인
    1. 매직 넘버인 0xCAFEBABE로 시작?
    2. 메이저 버전과 마이너 버전 번호가 현재 JVM이 허용하는 범위?
    3. 지원하지 않는 타입의 상수가 상수 풀에 있는지?
    4. 상수를 가리키는 다양한 인덱스 중 존재하지 않는 상수나 타입이 맞지 않는 상수를 가리키나?
    5. CONSTANT_Utf8_info 타입 상수 중 UTF-8 인코딩에 부합하지 않는 데이터는 없나?
    6. 클래스 파일 형식을 이루는 요소 중 일부 또는 파일 자체가 생략되거나 추가된 정보는?
       이 경우들은 일부로, 실제 검증은 훨씬 많다. 주된 목적은 "바이트 스트림이 바르게 해석되어 메서드 영역에 저장되는지 파일 형태가 자바 타입 정보 설명에 요구 사항을 준수하는지 확인"
2. 메타데이터 검증 : 바이트 코드로 설명된 정보의 의미를 분석하여 서술된 정보가 명세의 요구 사항을 충족하는지 확인
3. 바이트코드 검증 : 복잡함, 데이터 흐름과 제어 흐름을 분석해 프로그램의 의미가 적법하고 논리적인지 확인, 데이터 타입 검증을 마친 후 클래스의 메서드 본문을 분석, 메서드가 런타임에 가상 머신의 보안을 위협하는 동작을 하는지 확인
    - 피연산자 스택의 데이터 타입과 명령어 코드 시퀀스가 항시 어울려 동작하는지 확인
    - 점프 명령어가 메서드 본문 바깥의 바이트코드 명령어로 점프하지 않아야 함
    - 메서드 본문에서 형 변환이 항상 유효함을 보장
4. 심벌 참조 검증 : 검증 마지막 단계, 가상 머신이 심벌 참조를 직접 참조로 변환할 때 수행됨, 이 변환은 링킹의 세 번째 단계인 해석 단계에서 일어남, 심벌 참조 검증은 해당 클래스 자체를 제외한 모든 정보를 확인함
    - 심벌 참조에서 문자열로 기술된 완전한 이름에 해당하는 클래스를 찾을 수 있나?
    - 단순 이름과 필드 서술자와 일치하는 메서드나 필드가 해당 클래스에 존재하나?
    - 심벌 참조가 가리키는 클래스, 필드, 메서드나 필드가 해당 클래스에 존재하나?
    - 심벌 참조가 가리키는 클래스, 필드, 메서드의 접근 지정자가 현재 클래스의 접근을 허용하나?

### 준비, *클래스 변수를 메모리에 할당하고 초기값을 설정*
개념적으론 이 변수들이 사용하는 메모리를 메서드 영역에 할당해야 하지만, 메서드 영역 자체가 논리적 영역임
1. 인스턴스 변수가 아닌 클래스 변수만 할당, 인스턴스 변수는 객체가 인스턴스화 될 때 객체와 함께 자바 힙 저장
2. 준비 단계에서 클래스 변수에 할당하는 초깃값은 해당 데이터 타입의 제로값임

### 해석, *JVM이 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정*
- 심벌 참조란 대상을 명확하게 지칭하는 데 이용될 수 있는 모든 형태의 리터럴이 될 수 있고, 가상 머신이 구현한 메모리 레이아웃관 아무 관련 없다. 대상이 반드시 가상 머신 메모리에 로드되어 있을 필요도 없음. 메모리 레이아웃은 가상 머신 구현에 따라 달라질 수 있지만 심벌 참조는 달라지지 않는다.
- 직접 참조란 포인터, 상대적 위치(오프셋) 또는 대상의 위치를 간접적으로 가리키는 핸들임, 가상 머신에 구현된 메모리 레이아웃과 밀접하게 관련이 있어서 똑같은 심벌 참조로 변환해도 가상 머신에 따라 달라진다.

클래스 또는 인터페이스 해석
1. 배열이 아니면 완전한 이름을 클래스 로더에 전달하여 클래스를 로드, 로딩 과정에서 메타데이터 검증과 바이트코드 검증을 거치므로 구현한 인터페이스나 부모 클래스 등 관련 타입들의 로딩까지 촉발할 수 있음
2. 배열이고, 원소 타입이라면 서술자는 [Ljava/lang/Integer] 와 같은 형태
3. 위 단계에서 예외가 발생하지 않았다면 가상 머신 내에서 유효한 클래스 또는 인터페이스라는 뜻이다. 해석을 완료하려면 접근할 수 있는지 확인하는 심벌 참조 검증을 수행해야 하며 권한이 없으면 IllegalAccessError를 발생

jdk9 부터는 모듈 도입으로 public도 모두 접근이 가능한게 아니라 모듈 간 권한도 확인한다.
- 클래스가 public 으로 같은 모듈에 속함
- 클래스가 public 으로 다른 모듈이지만 접근 허용
- 클래스가 public 이 아니지만 같은 패키지


##### 필드 해석
필드의 타입으로 지정한 클래스 또는 인터페이스의 심벌 참조부터 해석해야 함. 해석하는 과정에서 예외가 발생하면 필드 심벌 참조 해석 역시 실패함
1. 단순 이름 및 필드 서술자가 대상과 일치하는 필드가 있다면 이 필드를 가리키는 직접 참조를 반환하고 검색 종료
2. 포함되지 않고 인터페이스를 구현하고 있다면 각 인터페이스와 상위 인터페이스들을 계층 구조 아래에서부터 재귀 검색, 단순 이름 및 필드 서술자가 대상과 일치하는 필드를 정의한 인터페이스를 발견하면 필드를 가리키는 직접 참조를 반환하고 검색 종료
3. 그렇지 않고 java.lang.Object도 아니라면 계층 구조 아래에서부터 상위 클래스를 재귀 검색, 단순 이름 및 필드 서술자가 대상과 일치하는 필드를 정의한 클래스를 발견하면 그 필드를 가리키는 직접 참조를 반환하고 검색 종료
4. 다 아니라면 검색 실패


##### 메서드 해석
첫 단계는 메서드 해석과 동일, 메서드 테이블의 class_index 항목이 가리키는 메서드가 속한 클래스 또는 인터페이스의 심벌 참조를 해석
1. 클래스 파일 구조에서 클래스 메서드의 상수 타입 정의와 인터페이스 메서드 심벌 참조는 구분되어있음. class_index가 가리키는 현재 클래스의 메서드 테이블안의 인터페이스라면 IncompatibleClassChangeError를 던짐
2. 첫 단계를 통과하면 대상의 이름과 서술자에 부합하는 메서드를 찾아서 직접 참조를 반환하고 검색 종료
3. 그렇지 않으면 상위 클래스를 재귀적으로 살피면서 이름 및 서술자가 대상으로 일치하는 메서드를 찾음, 그 메서드의 직접 참조를 반환하고 검색 종료
4. 그렇지 않으면 구현한 인터페이스 목록과 상위 인터페이스들을 재귀 검색해서 이름과 일치하는 메서드를 찾으면 그게 추상 클래스다.
5. 그렇지 않으면 메서드를 못찾는거임

##### 인터페이스 메서드 해석
인터페이스 메서드 테이블의 class_index 항목이 가리키는 메서드가 속한 클래스 또는 인터페이스의 심벌 참조를 해석, 해석한 인터페이스를 검색
1. 클래스 메서드 해석과 반대로 인터페이스 메서드 테이블의 class_index가 가리키는 클래스가 확인되면 바로 IncompactibleClassChangeError 던짐
2. 아니면 인터페이스와 일치하는 메서드 확인해서 직접 참조를 반환하고 검색 종료
3. 아니면 java.lang.Object 클래스를 만날때까지 상위 인터페이스들을 재귀 검사하여 일치하는 메서드 검색
4. 자바는 인터페이스 중 다중 상속을 허용하므로 3단계에서 일치하는 메서드를 여러개 찾음. 그중 하나 반환하고 검색 종료
5. 아니면 메서드를 못찾은거임

##### 초기화
클래스 로딩의 마지막 단계로 사용자 정의 클래스 로더를 이용할 수 있지만 대부분 JVM이 통제함
초기화 단계에는 JVM이 드디어 사용자 클래스에 작성된 자바 프로그램 코드를 실행함, 모든 변수에 초기값 0 할당하고 초기화 단예에서 클래스 변수와 기타 자원을 개발자의 코드대로 초기화를 한다. -> clinit()
- clinit() 모든 클래스 변수 할당과 정적 문장 블록의 내용을 취합하여 컴파일러가 자동 생성, 수집하는 순서는 문장이 소스 파일에 등장하는 순서에 영향 받음, 정적 문장 블록에선 정적 문장 블록보다 먼저 정의된 변수에만 접근가능, 나중에 정의된 변수도 정적 문장 블록 안에서 값을 할당하는건 가능
- clinit() 는 자바에서 말하는 클래스의 생성자와 다름, 부모 클래스의 생성자를 명시적 호출하지 않아도 JVM은 하위 클래스의 clinit()가 실행되기 전 부모 클래스의 clinit()부터 실행함
- 부모 클래스의 clinit()가 먼저 실행되므로 자연스레 부모 클래스에 정의된 정적 문장 블록이 자식 클래스의 변수 할당 연산자보다 먼저 실행
- clinit()가 클래스나 인터페이스에 반드시 필요한건 아님
- 인터페이스에선 정적 문장 블록을 사용할 수 없지만 변수에 초기값을 할당할 순 있다.
- JVM은 클래스의 clinit()가 멀티스레드 환경에서 적절히 동기화되도록 해야 한다. 여러 스레드가 한 클래스를 동시에 초기화하려 시도하면 그중 한 스레드만 clinit()를 실행하고 다른 스레드는 모두 대기해야 한다. 그래서 시간이 오래걸리는 작업이 있다면 여러 스레드가 블록될 가능성이 있음



## 클래스 로더
필요한 클래스를 얻는 방법을 애플리케이션이 정할 수 있게 하기 위해 클래스 로딩 중 '완전한 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림 가져오기'를 JVM 외부에서 수행하도록 했고 이를 **클래스 로더**라고 함

### 클래스와 클래스 로더
클래스 로더는 클래스를 로딩하는 일을 하지만 다른것도 함
각 클래스 로더는 독립적인 클래스 이름 공간을 지니기 때문에 클래스 로더를 빼놓고 특정 클래스가 JVM에서 유일한지 판단할 수 없음. 이를 확인하는 '동치인가'는 해당 클래스 객체의 `equals()`, `isAssignableFrom()`, `isInstance()` 메서드의 반환값 또는 `instanceof` 키워드 등이 있다.

### 부모 위임 모델
JVM 관점에서 클래스 로더의 종류는 두 가지다.
- JVM 자체의 일부인 부트스트랩 클래스 로더 : 핫스팟 가상 머신에서는 C++로 구현됨
- 그외 다른 클래스 로더 : 추상 클래스인 java.lang.ClassLoader 를 상속하여 자바로 구현하고 외부에서 독립적으로 존재

자바 개발자 관점에선 클래스 로더를 더 나눌 수 있음
일단 JDK8까지 유지된 3계층 클래스 로더
- 부트스트랩 클래스 로더 : JAVA_HOME/lib 디렉터리나 -Xbootclasspath 매개 변수로 지정한 경로에 위치한 파일들과 JVM이 클래스 라이브러리로 인식하는 파일들을 로드하는 일을 책임짐, 부트스트랩 클래스 로더는 자바에선 직접 참조할 수 없다.
- 확장 클래스 로더 : sun.misc.Launcher$ExtClassLoader를 말하며 자바로 구현됨, 환경 변수로 지정한 경로의 클래스 라이브러리들을 로드하는 역할, '확장' 클래스 로더라는 이름처럼 자바의 클래스 라이브러리를 확장하는 메커니즘임, 자바로 구현되어 있어 개발자가 직접 사용 가능
- 애플리케이션 클래스 로더 : sun.misc.Launcher$AppClassLoader 를 의미, ClassLoader 클래스의 getSystemClassLoader() 메서드가 반환하는 클래스 로더라는 의미에서 시스템 클래스 로더라고도 함, 클래스 패스 상의 클래스 라이브러리들을 로드하는 역할로 개발자가 자바 코드로 사용 가능,  클래스 로더를 커스텀하지 않으면 이 로더가 기본 클래스 로더다
  ![mingi-7.2.png](/image/mingi-7.2.png)

위처럼 클래스 로더간 협력하여 로딩을 책임지며, 클래스 로더 간 계층 관계를 클래스로더 들의 **부모 위임 모델**이다.

클래스 로딩을 요청받은 클래스 로더는 처음부터 로드하지 않고 상위 클래스 로더로 요청을 위임하고 모든 로드 요청은 우선 최상위 부트스트랩 클래스 로더로 넘겨진다. 상위 로더가 처리할 요청이 검색 범위 밖이라면 하위 로더가 시도한다.
클래스 로더를 부모 위임 모델로 구성하면 자바 클래스들이 자연스레 클래스 로더의 계층 구조를 따르게 된다는 이점이 있다. java.lang.Object 클래스의 로딩은 어떤 클래스 로더에 요청해도 최상위인 부트스트랩 클래스 로더가 처리함, Object 클래스는 모두 동일한 클래스임이 보장


## 자바 모듈 시스템
직소 프로젝트로 JDK9에 도입된 모듈 시스템 (JPMS)는 '자유롭게 설정 가능한 캡슐화 격리 메커니즘'을 위해 클래스 로딩 아키텍처를 변형했음. 모듈은 JAR 패키지 같은 단순 코드 컨테이너가 아님
- requires : 다른 모듈에 대한 의존성 목록
- exports : 다른 모듈에서 사용할 수 있는 패키지 목록
- open : 다른 모듈에서 리플렉션 API로 접근 가능한 패키지
- uses : 현재 모듈이 사용할 서비스 목록
- provides : 다른 모듈에 제공하는 서비스 목록

클래스패스에 기초하던 JDK8까지의 관리 방식은 안정성에 문제가 있고 이를 개선하는게 모듈 시스템이다.
기존에는 필요한 타입이 클래스패스에 없으면 런타임에 사용할 때 발견이 되지만, 모듈 시스템은 의존하는 모듈들을 명시할 수 있어서 컴파일 단계에서 파악이 가능함.
그리고 접근자가 public이면 어디서든 접근 가능하던 문제를 모듈에선 접근 가능한 타입을 명시하게 해서 권한 세분화가 가능하다

####  모듈 호환성
기존 클래스패스와 호환하기 위해 모듈패스 개념을 도입함, 클래스 라이브러리의 위치에 따라 모듈인지 전통적인 JAR 패키지인지 결정된다. 즉, JAR 파일을 클래스패스에 배치하면 모듈 정보(module-info.class)가 있어도 JAR패키지로 취급한다. 반대로 모듈패스에 있으면 JMOD 접미사도 사용하지 않고 모듈로 취급한다.

하위 호환성을 위해 규칙들을 세웠다.
- 클래스패스상 JAR 파일용 접근 규칙 : 클래스패스에 있는 모든 JAR파일과 기타 리소스 파일은 자동으로 익명 모듈로 패키징한걸로 간주함. (익명 모듈은 격리 효과가 없어서 모든 패키지에서 사용 가능)
- 모듈패스상 모듈용 접근 규칙 : 모듈패스에 존재하는 명명된 모듈은 자신의 의존성에서 명시한 모듈과 패키지만 접근 가능, 익명 모듈의 내용은 명명된 모듈에서 볼 수 없다.
- 모듈패스상 JAR 파일용 접근 규칙 : 모듈 정의가 포함되지 않은 기존 JAR파일을 모듈패스에 넣으면 자동으로 모듈이 됨, module-info.class 파일이 없는 모듈은 기본적으로 자신의 패키지 모두를 export 하며 다른 모든 모듈에 의존한다.


#### 모듈화 시대의 클래스 로더
하위 호환을 위해 3계층 클래스 로더 아키텍처와 부모 위임 모델의 근간을 흔들진 않음. 다만 모듈 시스템을 위해 몇가지 변화가 있음
1. 확장 클래스 로더가 플랫폼 클래스 로더로 대체
2. 플랫폼 클래스 로더와 애플리케이션 클래스 로더가 더는 java.net.URLClassLoader 로부터 파생되지 않음
3. 3계층 클래스 로더와 부모 위임 모델을 유지하지만 클래스 로딩의 위임 관계에는 변화를 줌
   ![mingi-7.3.png](/image/mingi-7.3.png)



