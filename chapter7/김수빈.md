# 7.1 들어가며

- 클래스 로딩 메커니즘
    - JVM은 클래스를 설명하는 데이터를 클래스 파일로부터 메모리로 읽어들이고,
    - 그 데이터를 검증, 변환, 초기화 하고 나서,
    - 최종적으로 JVM이 곧바로 사용할 수 있는 자바 타입을 생성한다.
- 자바에서는 클래스 로딩, 링킹, 초기화가 모두 런타임에 이루어짐
    - 장점 : 높은 확장성과 유연성
    - 단점 : AOT 컴파일에 제약이 생기고, 클래스 로딩을 거치느라 성능이 약간 떨어짐
        - AOT(Ahead-Of-Time) 컴파일은 컴파일 시점에 모든 클래스와 의존성을 알아야 하는데, 동적 로딩에서는 런타임에 어떤 클래스가 필요할지 미리 알 수 없는 경우가 많음

# 7.2 클래스 로딩 시점

- 타입의 생애 주기

  ![1000022723.jpg](../image/sb_7_1.jpg)

- 로딩의 시작 시점 : <JVM 명세>에서 명시하지 않음
- 초기화의 시작 시점
    1. `new`, `getstatic`, `putstatic`, `invokestsatic` 을 만났을 때, 해당 타입이 아직 초기화되어 있지 않은 경우
        - 각각 인스턴스 생성, 타입의 정적 필드를 읽거나 쓰기, 타입의 정적 메서드 호출
    2. Class 클래스나 리플렉션 메서드를 사용할 때, 해당 타입이 아직 초기화되어 있지 않은 경우
    3. 클래스를 초기화할 때, 상위 클래스가 초기화되어 있지 않은 경우 (그 상위 클래스의 초기화)
    4. JVM 구동 직후 메인 타입의 초기화
    5. `REF_getStatic`, `REF_putStatic`, `REF_invokeStatic`, `REF_newInvokeSpecial` 타입 메서드 핸들을 해석해서 얻은 `java.lang.invoke.MethodHandle` 인스턴스를 호출할 때, 해당 클래스가 초기화되어 있지 않은 경우
    6. 인터페이스에 디폴트 메서드(JDK 8+)를 정의했다면, 이를 직간접적으로 구현한 클래스가 초기화될 때, 인터페이스부터 초기화
- <JVM 명세>는 타입 초기화를 시작하는 상황은 이 6가지 뿐이라고 명시함
    - 위 시나리오들이 설명하는 동작 = 타입에 대한 능동 참조 (active reference)
    - 그 외의 모든 참조 = 수동 참조 (passive reference)
    - → 이렇게 능동 참조와 수동 참조를 구분함으로써, 필요한 타입만 초기화하여 시작 시간과 메모리를 효율화함
- 수동 참조 예시
    - 예시 1

      ![1000022724.jpg](../image/sb_7_2.jpg)

        - 정적 필드를 참조할 때는, 필드를 직접 정의한 클래스만 초기화됨
    - 예시 2

      ![1000022725.jpg](../image/sb_7_3.jpg)

        - 배열 생성은 능동 참조로 간주되지 않음
        - 배열 생성은 해당 타입의 배열 객체를 만드는 것이지, 배열 요소들의 인스턴스를 생성하는 것이 아님
            - 즉, `anewarray` 바이트코드 명령어를 통해, `[Lorg/fenixsoft/jvm/chatpter7/SuperClass;` 클래스가 초기화됨
            - 배열 객체만 생성되고, 그 안에는 null 참조만 들어있으므로, SuperClass의 인스턴스는 하나도 생성되지 않았음
            - 이 클래스는 ‘원소 타입이 SuperClass인 일차원 배열’임
                - 자바 소스 코드에서 배열이 제공하는 속성과 메서드를 구현한 실체
                - length 속성, clone() 메서드만 public으로 설정되어 있어 사용자 코드에서 사용 가능함
                - 자바 배열이 C/C++보다 안전한 이유는, 배열 원소로 직접 접근을 못하도록(`ArrayIndexOutOfBoundsException`) 이 클래스가 감싸고 있기 때문
    - 예시 3

      ![1000022726.jpg](../image/sb_7_4.jpg)

        - 상수 전파 최적화 (constant propagation optimization)
            1. 컴파일러가 상수를 식별해냄
            2. 식별된 상수 값을 해당 변수가 사용되는 모든 위치에 직접 대입 (다른 클래스의 상수를 참조하고 있었다면, 그 값이 자신의 클래스 상수 풀에 저장됨)
            3. 불필요해진 변수나 연산을 제거
            - → 상수의 값 “hello world”는 클래스의 상수 풀에 저장됨
        - ConstClass.HELLO_WORLD를 참조하는 코드는, 상수 풀을 참조하도록 변경됨
        - 따라서 NotInitialization_3의 클래스 파일에는 ConstClass 클래스의 내용을 가리키는 심벌 참조가 만들어지지 않고, 클래스의 초기화를 촉발하지 않음

# 7.3 클래스 로딩 처리 과정

## 7.3.1 로딩 (Loading)

- 로딩 단계에서 3가지 작업을 수행
    1. 완전한 이름을 보고, 해당 클래스를 정의하는 binary byte stream을 가져옴
    2. byte stream으로 표현된 정적인 저장 구조를, 메서드 영역에서 사용하는 런타임 데이터 구조로 변환
    3. 로딩 대상 클래스를 표현하는 `java.lang.Class` 객체를 힙 메모리에 생성
        - 이 Class 객체는 애플리케이션이 메서드 영역에 저장된 타입 데이터를 쓸 수 있게 하는 통로가 됨
- 타입별 로딩 단계 차이
    - 배열 외 타입의 로딩
        - 로딩(단계 중 클래스의 binary byte stream을 얻는 동작)은 개발자가 제어하기 쉬움
        - JVM의 내장 부트스트랩 클래스 로더를 쓰거나, 커스텀 클래스 로더를 써서 로딩할 수 있음
    - 배열 클래스의 로딩
        - 클래스 로더가 생성하지 않고, JVM이 직접 메모리에 동적으로 생성함
        - 그러나 배열 클래스의 원소 타입은 클래스 로더를 통해 로드함
        - 배열 클래스(say, C) 로딩 과정
            1. 배열의 컴포넌트 타입이 참조 타입인 경우
                - (컴포넌트 타입 = 배열에서 첫 번째 차원이 제거된 타입)
                - 로딩 과정을 재귀적으로 수행하여 컴포넌트 타입을 로딩함
                - 배열 C는 컴포넌트 타입을 로드하는 클래스 로더의 namespace에 자리하게 됨
                    - 타입은 클래스 로더에서 유일해야 함
            2. 배열의 컴포넌트 타입이 참조 타입이 아닌 경우 (e.g., int[])
                - 배열 C를 부트스트랩 클래스 로더가 로딩함
        - 배열 클래스의 접근성은 해당 컴포넌트 타입과 같음
            - 컴포넌트 타입이 참조 타입이 아닌 배열 클래스라면, 기본적으로 public이기 때문에 모든 클래스/인터페이스에서 접근 가능함
- 로딩 단계가 끝나고 나면, binary byte stream은 JVM이 정의한 형식에 맞게 메서드 영역에 저장됨
- 그 다음, 해당 `java.lang.Class` 객체를 자바 힙에 초기화 함
- 로딩 단계와 링킹 단계의 순서
    - 시작 시간 기준으로는 로딩 단계가 링킹 단계보다 항상 먼저 시작함
    - 로딩 단계과 링킹 단계의 일부 동작(예 : 바이트코드 파일 형식 검증 동작의 일부)은 중첩되어 진행됨

## 7.3.2 검증 (Verification)

- 검증의 목표 2가지
    - 클래스 파일의 바이트 스트림에 담긴 정보가 <JVM 명세>의 모든 제약을 만족하는지 확인
    - 이 정보를 코드로 변환해서 실행했을 때, JVM 자체의 보안을 위협하지 않는지 확인
        - 자바는 비교적 안전한 언어임
            - 배열 경계를 넘어서 엉뚱한 데이터에 접근하거나, 객체가 상속하지 않은 타입으로 변환하거나, 존재하지 않는 코드 라인으로 점프하는 동작 등은 불가능함
            - 그러나, 바이트코드 수준에서는 가능할 수 있음.
            - 이를 검증하지 않으면, 악의적으로 작성된 바이트코드 스트림이 로드될 수 있으므로, 검증 단계가 필요

### 검증의 구체적 4단계

1. 파일 형식 검증
    - 바이트 스트림이 클래스 파일 형식에 부합한지, 현재 버전의 JVM에서 처리할 수 있는지 확인
    - 예시
        - 매직 넘버 `0xCAFEBABE` 로 시작하는지
        - 메이저 버전, 마이너 버전이 현재 JVM이 허용하는 범위인지
        - 상수 풀에 지원하지 않는 타입(tag 플래그)의 상수가 있는지
        - 상수를 가리키는 인덱스 중 존재하지 않는 상수나 타입에 맞지 않는 상수를 가리키는 것이 있는지
        - `CONSTANT_Utf8_info` 타입 상수 중 UTF-8 인코딩에 어긋나는 데이터가 있는지
    - 이 단계를 통과하면, 바이트 스트림이 메서드 영역에 저장됨
        - 아래 3개 단계는 메서드 영역에 저장된 구조를 대상으로 검증을 진행 (즉, 바이트 스트림에 접근하지 않음)
2. 메타 데이터 검증
    - 바이트 코드로 설명된 정보의 의미를 분석하여, <JVM 명세>의 요구사항을 충족하는지 확인
        - = 클래스의 메타데이터 정보에 대한 의미론적 검증
    - 예시
        - 상위 클래스가 있는지
        - 상위 클래스가 상속을 허용하는지 (상위 클래스가 `final` 이 아니어야 함)
        - 상위 클래스/인터페이스에서 정의한 필수 메서드를 모두 구현했는지
        - 필드와 메서드가 상위 클래스와 충돌하는지
            - 상위 클래스의 `final` 필드를 구현하는지
            - 오버로딩 규칙을 준수하지 않는 메서드가 있는지
3. 바이트코드 검증
    - 데이터 흐름과 제어 흐름을 분석하여, 프로그램의 의미가 적법하고 논리적인지 확인
    - 클래스의 메서드 본문(클래스 파일의 `Code` 속성)을 분석
        - → 메서드가 런타임에 JVM의 보안을 위협하는 동작을 하는지 확인
    - 검증 단계 중 가장 복잡한 단계
    - 예시
        - 피연산자 스택의 데이터 타입과 코드 시퀀스가 모순이 없는지
            - 예 : 피연산자 스택에는 int 타입을 넣고, 실행 시에는 지역 변수 테이블에 long 타입으로 읽는 경우
        - 점프 명령어가 본문 바깥의 바이트코드 명령어로 점프하지 않아야 함
        - 메서드 본문에서 형 변환이 항상 유효함을 보장
    - 바이트코드 검증을 통과했다고 해서 100% 안전하다는 보장은 없음
        - ‘정지 문제(halting problem)’ - 버그가 있는지를 와녁하게 검증하는 프로그램을 작성하는 것은 불가능하다
    - 바이트코드 검증 단계가 지나치게 길어지는 것을 막기 위해, 유효성 검사를 가능한한 javac 컴파일러로 옮김
        - `Code` 속성의 속성 테이블에 `StackMapTable` 속성을 추가
            - 타입 추론을 타입 검사로 대체해서, 검증 시간을 상당히 단축했다
                - 타입 추론 : JVM이 모든 경로를 분석해서, 타입을 추론해야 했음
                - 타입 검사 : 컴파일러가 계산한 타입 정보를 `StackMapTable` 에 저장해두면, JVM은 이 테이블만 검사하면 됨
            - JDK 6 이상으로 빌드한 클래스 파일에서는, 타입 검사기가 항상 사용된다
4. 심벌 참조 검증
    - JVM이 심벌 참조를 직접 참조로 변환할 때 수행됨
        - 이 변환은 링킹의 3번째 단계인 해석 단계에서 일어남
    - 현재 클래스가 참조하는 외부 클래스, 메서드, 필드, 그 외 자원에 접근할 권한이 있는지를 확인
        - 심벌 참조에서 문자열로 기술된 완전한 이름에 해당하는 클래스를 찾을 수 있는지?
        - 단순 이름과 필드 서술자와 일치하는 메서드/필드가 해당 클래스에 존재하는지?
        - 심벌 참조가 가리키는 클래스, 필드, 메서드의 접근 지정자가 현재 클래스의 접근을 허용하는지?

- 검증 단계는 필수는 아님
    - 모든 코드를 신뢰할 수 있다면, 프로덕션 환경에서 실행할 때는 검증을 건너뛰기도 함 (`-Xverify:none`)
    - 검증 단계를 생략하면 클래스 로딩 시간이 상당히 단축됨

## 7.3.3 준비 (Preparation)

- 클래스 변수를 메모리에 할당하고 초깃값을 설정하는 단계
    - 인스턴수 변수가 아닌 클래스 변수만 할당
        - 인스턴스 변수는 객체가 인스턴스화될 때, 객체와 함께 자바 힙에 할당
    - 준비 단계에서 클래스 변수에 할당하는 초깃값은 해당 데이터 타입의 제로값(zero value)
        - 0, 0L, ‘\u0000’, 0.0f, 0.0d, false, null 등
        - 단, 필드 속성 테이블에 (`final` 키워드를 사용하여) `ConstantValue` 속성이 존재한다면, 이 값을 할당함
- 개념적으로는 메서드 영역에 할당해야 하지만, 메서드 영역 자체가 논리적 영역이다
    - JDK 7까지 HotSpot에서는 메서드 영역을 영구 세대에 구현하여, 논리적인 개념과 일치했음
    - JDK 8부터는 클래스 변수를 클래스 객체와 함께 자바 힙에 저장함
        - → “클래스 변수는 메서드 영역에 존재한다”라는 말은 논리적으로만 그렇고, 물리적인 구현은 자바 힙에 함

## 7.3.4 해석 (Resolution)

- 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정
- 심벌 참조 (symbolic reference)
    - `CONSTANT_Class_info`, `CONSTANT_Utf8_info` 등
    - 심벌 참조에 쓰일 수 있는 리터럴 형태는 <JVM 명세>의 클래스 파일 구조에 명시되어 있어서, JVM 구현이 바뀌어도 심벌 참조는 달라지지 않음
    - 참조 대상이 JVM 메모리에 로드되어 있을 필요도 없음
- 직접 참조 (direct reference)
    - “포인터” or “오프셋” or “대상의 위치를 간접적으로 가리키는 핸들”
        - 포인터
            - 메모리의 절대적인 주소 (e.g., 0x7FFF1234)
            - 빠르지만, GC 등으로 객체 이동 시 모든 참조를 업데이트 해야 함 (객체 A를 참조하는 변수가 100개이면, 100개의 참조를 모두 업데이트)
        - 오프셋 : (e.g., 클래스의 메서드 테이블의 3번째 항목)
        - 핸들
            - 실제 객체나 메서드의 위치가 아닌, 이들에 대한 정보를 담고 있는 중간 테이블을 참조
            - 약간의 오버헤드가 있지만, 객체가 메모리에서 이동할 때 유용 (객체 A에 대한 핸들 테이블의 항목 하나만 업데이트하면 충분함)
    - JVM에 구현된 메모리 레이아웃과 밀접하게 관련됨. 즉, 똑같은 심벌 참조로부터 변환했더라도, JVM에 따라 달라짐
    - 참조 대상이 JVM 메모리에 이미 존재해야 함
- 해석 결과 캐싱
    - 동일한 심벌 참조에 대해서 해석 요청이 여러 번 이루어지더라도, 항상 동일한 결과를 내려줘야 함
        - 따라서 첫번째 해석 결과를 캐싱하는 경우가 많음
    - 단, `invokedynamic` 명령어는 제외 (← 동적 언어 지원을 위한 명령어)
- (구체적인 해석 단계 정리는 생략했습니다)

## 7.3.5 초기화

- 클래스 변수와 기타 자원을 개발자가 코드에 기술한 대로 초기화함
    - 클래스 생성자 `<clinit>()` 메서드를 실행하는 단계
    - `<clinit>()`는 컴파일러가 자동으로 생성하는 메서드라서, 개발자가 코드로 만들 수는 없음
- `<clinit>()`의 생성
    - 컴파일러가 클래스 변수 할당, 정적 문장 블록(`static {}`)을 취합해서 자동으로 생성함
    - 정적 문장 블록에서는 정적 문장 블록보다 먼저 정의된 변수에만 ‘접근’할 수 있음
        - 다만, 나중에 정의된 변수라도 정적 문장 블록 안에서 값을 ‘할당’하는 것은 가능
- `<clinit>()` 필수 여부
    - 정적 변수에 값을 할당하지 않고, 정적 문장 블록이 없다면, 컴파일러가 생성하지 않음
- 클래스 생성자 `<init>()` 와는 다른 개념
- 부모 클래스의 생성자를 명시적으로 호출하지 않아도, 부모 클래스의 `<clinit>()` 을 먼저 실행함
    - → JVM에서 실행되는 첫번째 `<clinit>()` 은 java.lang.Object의 `<clinit>()` 임
    - 정적 문장 블록 역시, 부모 클래스의 것이 자식 클래스의 것보다 먼저 실행됨
- 인터페이스의 `<clinit>()`
    - 인터페이스에서는 정적 문장 블록은 사용할 수 없지만, 변수에 초깃값을 할당할 수는 있으므로, `<clinit>()` 메서드가 생성될 수 있음
    - 단, 인터페이스의 경우 부모 인터페이스의 `<clinit>()` 을 먼저 실행할 필요는 없음
    - 클래스를 초기화 할 때도 부모 인터페이스의 `<clinit>()` 을 실행하지 않음
- `<clinit>()` 과 동기화
    - 여러 스레드가 한 클래스를 동시에 초기화하려고 하면, 한 스레드만 `<clinit>()` 을 실행하고, 다른 스레드는 대기시켜야 함
    - → 장시간 블로킹의 원인이 되기도 함

# 7.4 클래스 로더

- 로딩 단계 중 첫 번째 스텝인 ‘완전한 이름으로부터 클래스의 바이너리 바이트 스트림을 가져오는’ 단계를, 클래스 로더가 수행함
- 계층 분할, OSGi, 프로그램 핫 배포, 코드 암호화 등 분야에서 중요할 역할

## 7.4.1 클래스와 클래스 로더

- 각 클래스 로더는 독립적인 네임스페이스를 갖고 있기 때문에, 서로 다른 클래스 로더로 읽어들인 클래스는, 동일한 클래스 파일로부터 로딩했을지라도, 다른 클래스로 인식됨
    - 즉, 클래스의 동일성은 클래스 이름 + 클래스 로더를 기준으로 판단
- equals(), isAssignableFrom(), isInstance(), instanceof 등의 결과에 영향

## 7.4.2 부모 위임 모델

- JVM의 입장에서 클래스 로더의 종류
    - 부트스트랩 클래스 로더
        - JVM의 일부
        - HotSpot에서는 C++로 구현됨
    - 그 외의 모든 클래스 로더
        - JVM 외부에 있음
        - java.lang.ClassLoader를 상속
        - Java로 구현됨
- 3계층 클래스 로더와 부모 위임 모델
    - 부트스트랩
    - 확장
    - 애플리케이션
    - ❓️클래스 로딩 시, 같은 클래스가 이미 로드되어있는지 확인을 생략하고, 중복 로드했을 경우에 어떤 문제가 발생할까?
        - p.382 7-8


## 7.4.3 부모 위임 모델에 대한 도전

### (1) 클래스 로더를 이미 확장해서 사용하는 개발자들 고려

### (2) 부모 위임 모델의 결함 - 기본 타입이 사용자 코드를 호출해야 하는 경우

- JNDI
    - 부트스트랩 클래스 로더가 로드함
    - 자원을 찾고 관리하는 역할을 수행하기 위해, JNDI SPI 코드를 호출해야 함
- 스레드별 컨텍스트 클래스 로더 도임

### (3) 코드 핫 스와프, 모듈 핫 배포 등 동적인 기능

- OSGi 모델

# 7.5 자바 모듈 시스템 (JPMS)

- JDK 9에 도입 (← 직소 프로젝트)
- 안정성 개선
    - JDK 8까지는 클래스패스에 기반해 의존성 관리를 했음
        - 필요한 타입이 클래스패스에 없더라도, 해당 클래스를 사용할 시점에야 예외가 발생
        - (jar 지옥)
    - JDK 9부터는 모듈이 의존하는 다른 모듈을 명시할 수 있음
        - 필요한 의존성이 모두 있는지 개발 단계에서 알 수 있음 (의존성 누락 시 애플리케이션 시작조차 불가)
    - public 타입의 접근 권한

## 7.5.1 모듈 호환성

- 모듈패스 도입
- 모듈인지 jar 패키지인지 구분 기준
    - 클래스 라이브러리의 위치
- 클래스패스 방식과의 호환성을 위한 규칙들
    - 클래스패스상의 jar 파일용 접근 규칙
    - 모듈패스상의 모듈용 접근 규칙
    - 모듈패스상의 jar 파일용 접근 규칙
- 모듈 버전
    - 런타임에 모듈 버전을 동적으로 교체하는 것은 거의 불가능
    - 런타임 타입 교체를 지원하기 위한 DCEVM 프로젝트가 있으나 JDK 11 까지만 지원

## 7.5.2 모듈화 시대의 클래스 로더

- 모듈 시스템(JPMS) 하에서 클래스 로더의 변화
    - 확장 클래스 로더 → 플랫폼 클래스 로더로 대체
    - 플랫폼 클래스 로더, 애플리케이션 클래스 로더가 java.net.URLClassLoader로부터 파생되지 않음
    - 3계층 클래스 로더와 부모 위임 모델은 유지하되, 클래스 로딩의 위임 관계는 변경함