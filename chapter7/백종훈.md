JVM은 컴파일된 클래스 파일을 메모리로 읽어 들이고, 그 데이터를 검증/변환/초기화하고 나서 최종적으로 VM이 곧바로 사용할 수 있는 자바 타입을 생성한다.
이를 클래스 로딩 메커니즘이라고 한다.

6장에 잠깐 나왔듯 자바는 컴파일 타임에 링킹이 일어나지 않는다. 자바에서 클래스 로딩, 링킹, 초기화는 모두 프로그램 실행 중에 일어난다.
그렇기에 AOT 컴파일에 제약이 생기고 실행 성능이 떨어질 수 밖에 없다. 반대로 높은 확장성, 유연성이라는 장점이 존재한다.

# 1. 클래스 로딩 시점
![[JVM 7장 - 클래스 로딩 메커니즘.png|700]]
로딩 → 검증 → 준비 → 초기화 → 언로딩은 반드시 순서대로 진행되어야 하지만 해석은 그렇지 않다.
해석은 초기화 이후에도 시작할 수 있는데, 동적 바인딩을 지원하기 위함이다.
여기서 각 단계 진행 순서의 기준은 '시작'시점이다. 즉, 각 단계의 종료 시점은 앞서 말한 순서와 다를 수 있다.

>[!NOTE]
>**정적 바인딩 vs 동적 바인딩**
>정적 바인딩은 컴파일 타임에 메서드 호출이 결정된다. 오버로딩,  static 메서드, private 메서드에서 발생한다.
>동적 바인딩은 런타임에 메서드 호출이 결정된다. 오버라이딩 메서드에서 발생한다.(다형성)

## 초기화 단계 촉발
자바 가상 머신 명세에 따르면 초기화가 즉시 일어나야 하는 6가지 상황을 엄격하게 규정하며, 이러한 경우들을 **능동 참조**라고 한다.
- new, getstatic, putstatic, invokestatic과 같은 명령어를 만났을 때 해당 타입이 초기화 되지 않은 경우
    - new 키워드로 인스턴스 생성
    - 타입의 정적 필드를 읽거나 설정(final까지 붙은 경우 컴파일 타임에 설정됨)
    - 타입의 정적 메서드 호출
- 리플렉션 메서드를 사용할 때 해당 타입이 초기화 되지 않은 경우
- 클래스 초기화 시 상위 클래스가 초기화 되어 있지 않은 경우
- VM 구동 직후 main() 메서드가 존재하는 타입의 초기화
- java.lang.invokeMethodHandler 인스턴스를 호출할 때 해당 하는 클래스가 초기화 되어 있지 않은 경우
- 인터페이스에 default 메서드가 정의되었고, 해당 인터페이스를 구현하는 클래스를 초기화할 때 인터페이스부터 초기화

### 수동 참조 vs 능동 참조
능동 참조와 수동 참조의 주요한 차이는 참조하는 클래스의 초기화 여부에 달렸다. 능동 참조가 일어나는 경우 참조하는 타입에 대한 초기화가 먼저 일어나지만 수동 참조는 그렇지 않다.
수동 참조가 일어나는 상황은 다음과 같다.
- 정적 필드를 참조할 때 발생하며, 필드를 직접 정의한 클래스만 초기화 된다.
- 배열 정의에서 클래스를 참조하는 경우 -> SuperClass[] sca = new SuperClass[10];
    - 이 경우 JVM이 Object로부터 곧바로 상속하여 자동으로 하위 클래스를 생성하므로 실제 타입은 '원소 타입이 SuperClass인 일차원 배열'이다.
- 상수를 참조하는 경우(상수 전파 최적화)
    - 상수는 **컴파일 과정에서 호출하는 클래스의 상수 풀에 저장되므로 상수를 정의한 클래스로의 직접적인 참조가 없어지게** 된다.
    - 즉, 컴파일 후에 상수를 호출하는 클래스와 정의하는 클래스의 연결점은 없다.

# 2. 클래스 로딩 처리 과정

## 로딩
JVM은 로딩 단계에서 다음 세 가지 작업을 수행한다.
- 완전한 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림 읽기
- 바이트 스트림으로 표현된 정적인 저장 구조를 메서드 영역에서 사용하는 런타임 데이터 구조로 변환
- 로딩 대상 클래스를 표현하는 java.lang.Class 객체를 힙 메모리에 생성
    - Class 객체는 애플리케이션에서 메서드 영역에 저장된 타입 데이터를 활용할 수 있는 통로가 됨

자바 가상 머신 명세에서 로딩에 대한 요구 사항을 세세하게 정의하지 않아 다음과 같은 장점을 얻을 수 있게 됐다.
- ZIP 압축 파일로부터 로딩 - JAR, WAR, EAR의 기초가 됨
- 네트워크로부터 로딩 - 웹 애플릿
- 런타임에 동적으로 생성 - JDK 동적 프록시
- 다른 파일로부터 생성 - JSP
- DB로부터 로딩 - SAP 넷위버
- 암호화된 파일로부터 로딩 - 보안

클래스 로딩은  JVM에 내장된 부트스트랩 클래스 로더 또는 사용자 정의 클래스 로더를 사용해 수행할 수 있다.
하지만 배열 클래스는 클래스 로더가 생성하지 않고 JVM이 직접 메모리에 동적으로 생성한다.
-> 하지만 배열의 원소 타입은 여전히 클래스 로더를 통해 로드 된다.

배열 클래스 생성 과정은 다음 규칙을 따른다.
- 배열의 컴포넌트 타입이 참조 타입이면 로딩 과정을 재귀적으로 수행하여 컴포넌트 타입을 로딩
- 배열 클래스는 컴포넌트 타입을 로드하는 클래스 로더의 namespace에 저장됨
- 컴포넌트 타입이 참조 타입이 아니면 배열 클래스를 부트스트랩 클래스 로더에게 위임
- 배열 클래스의 접근성은 해당 컴포넌트 타입과 같음

>[!NOTE]
>**배열의 컴포넌트 타입**
>배열에서 첫 번째 차원이 제거된 타입을 의미하며, int\[]\[]와 같은 경우엔 int\[] 1차원 배열이 컴포넌트 타입이 된다.

## 검증
검증은 링킹 과정 중 첫 번째 단계이며, 두 가지 목적을 가진다.
- 클래스 파일의 구조가 자바 가상 머신 명세에서 규정한 모든 제약 조건을 만족하는지 검증
- 코드로 변환해 실행했을 때 JVM 자체의 보안을 위협하는지 검증

검증 단계가 필요한 이유는 클래스 파일이 반드시 자바 소스 코드로부터 만들어지는 것이 아니기 때문이다.
그러므로 JVM은 자신을 보호하기 위해 검증 단계를 반드시 수행해야 한다.
이러한 이유에 따라 만약 모든 코드를 신뢰할 수 있다면 생략할 수 있는 선택 단계가 되기도 한다.

현재 검증 단계는 굉장히 많은 양의 검증을 수행하며, 다음과 같이 4가지 유형으로 분류할 수 있다.
- 파일 형식 검증
- 메타데이터 검증
- 바이트 코드 검증
- 심볼 참조 검증

### 파일 형식 검증
바이트 스트림이 클래스 파일 형식에 부합하고, 현재 버전의 VM에서 처리될 수 있는지 검증한다.
주된 목적은 입력 바이트 스트림이 올바르게 해석되어 메서드 영역에 저장되었는지, 파일 형태가 자바 타입 정보 설명에 대한 요구 사항을 준수하는지 확인하는 것이다.
즉, **이 유형의 검증은 다른 유형의 검증과 달리 바이트 스트림을 대상으로 한다.**

### 메타데이터 검증
바이트 코드로 설명된 정보의 의미를 분석해  서술된 정보가 요구사항을 준수하는지 검증한다.
주된 목적은 클래스의 메타데이터 정보에 대한 의미론적 검증을 수행하는 것이다.

### 바이트 코드 검증
가장 복잡한 단계이며, 시간이 오래 걸린다.
주된 목적은 데이터 흐름과 제어 흐름을 분석해 프로그램의 의미가 적법하고 논리적인지를 검증하는 것이다.
이 검증을 통과했다고 해서 100% 안전하다고 보장할 수는 없다. 즉, 로직에 버그가 존재하는지 완벽하게 검증할 수는 없다.

수행 시간이 복잡하고 긴 문제를 해결하기 위해 메서드 본문 Code 속성의 속성 테이블에 StackMapTable이라는 속성을 추가했다.
덕분에 바이트 코드 검증 단계에서 지역 변수 테이블과 피연산자 스택의 상태를 추론할 필요가 없어졌다.

### 심볼 참조 검증
해당 검증은 VM이 심벌 참조를 직접 참조로 변환할 때 수행된다. 이 변환은 해석 단계에서 이뤄진다.
주된 목적은 상수 풀의 다양한 심벌 참조 같은 클래스 자체를 제외한 모든 정보를 확인하는 것이다.
즉, **현재 클래스가 참조하는 외부 클래스, 메서드, 필드 등의 자원들에 접근할 권한이 있는지 확인**한다.

## 준비
준비는 클래스 변수를 메모리에 할당하고 초깃값을 설정하는 단계다.
JDK 7까지는 클래스 변수가 메서드 영역에 할당된다고 말하는 것이 타당했다 그 때는 영구 세대에 메서드 영역을 구현했기 때문이다.
하지만 JDK8부터 메서드 영역은 메타 스페이스로 이동했기에 현재는 타당하지 않다.
즉, 현재 클래스 변수는 클래스 객체와 함께 힙 영역에 저장된다. 그러므로 클래스 변수는 메서드 영역에 존재한다라는 말은 논리적으로만 그렇다는 이야기다.

준비 단계에서 초깃값이 설정되는 변수는 인스턴스 변수가 아닌 클래스 변수만 해당된다.
준비 단계에서 클래스 변수에 초깃갓은 해당 데이터 타입의 제로 값으로 설정된다.
하지만 static final같이 final이 붙은 경우엔 ConstantValue에 지정한 값을 할당한다.

## 해석
해석은 JVM이 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정이다.

### 심벌 참조 vs 직접 참조
먼저, 심벌 참조와 직접 참조가 의미하는 바에 대해 알아보자.
- **심벌 참조**
    - 몇 가지 심벌로 참조 대상을 설명하며, 대상을 명확하게 가리키는데 이용될 수 있는 모든 형태의 리터럴이 될 수 있다.
    - VM의 메모리 레이아웃과는 무관하며, 참조 대상이 반드시 VM의 메모리에 로드되어 있을 필요도 없다.
- **직접 참조**
    - 포인터, 상대적 위치(오프셋) 또는 대상의 위치를 간접적으로 가리키는 핸들이다.
    - VM의 메모리 레이아웃과 유관하며, 같은 심벌 참조를 변환하더라도 직접 참조는 VM에 따라 달라질 수 있다.
    - 또한 참조 대상이 VM의 메모리에 존재해야 한다.

JVM 명세에서 해석 단계를 수행하는 시간을 특정하지 않고, 심벌 참조를 다루는 바이트 코드 명령어들에 대해 실행하도록 규정한다.
**즉, 특정 시점이 아닌 특정 명령어를 기준으로 해석하기에 동적 바인딩이 가능해진다.**

해석 단계에선 또한 메서드나 필드에 접근 권한이 있는지 확인한다.(private, protected 등)
동일한 심벌 참조에 대해 여러 번 해석 요청이 이뤄지므로 첫 번째 결과를 캐시하는 것이 일반적이며, 해석의 결과는 멱등하다.

단, invokedynamic의 명령어 해석 결과는 캐시하지 않으며, 멱등하지 않다.
그 이유는 invokedynamic이 사용하는 참조가 '동적으로 계산된 호출 사이트 지정자'이기 때문이다.
즉, invokedynamic 명령어를 실행하여 얻을 수 있는 정보는 컴파일 타임이 아닌 런타임이다.

>[!NOTE]
>**동적으로 계산된 호출 사이트 지정자란?**
>동적으로 계산됐다는 **컴파일 시점까지는 그 메서드가 무엇인지 모르고 런타임에 알 수 있다는 뜻**이다.
>호출 사이트 지정자란 현재 어떤 문맥에서 invokedynamic이 실행되는지에 대한 메타데이터다.
>여기서 호출 사이트란 실제 메서드가 호출되는 위치를 의미하며,  지정자란 호출 사이트에 필요한 정볼르 JVM에게 설명해주는 메타데이터다.

### 7가지 타입의 심벌 참조
해석은 주로 7가지 타입의 심벌 참조에 대해 수행한다.
- 클래스, 인터페이스(CONSTANT_Class_info)
- 필드(CONSTANT_Fieldref_info)
- 클래스 메서드(CONSTANT_Methodref_info)
- 인터페이스 메서드(CONSTANT_InterfaceMethodref_info)
- 메서드 타입(CONSTANT_MethodType_info)
- 메서드 핸들(CONSTANT_MethodHandle_info)
- 호출 사이트 지정자(CONSTANT_Dynamic_info, CONSTANT_InvokeDynamic_info)

이 중 클래스 또는 인터페이스, 필드 해석에 대한 내용만 알아보자.
#### 클래스 또는 인터페이스 해석
```java
public Class D {
	// C는 클래스 또는 인터페이스라고 가정
	C c = new C(); // 컴팡리 후 심벌 참조 N으로 저장된다고 가정
}
```
위 코드를 바이트 코드로 컴파일하면 C라는 참조는 심볼 참조 형태로 저장되게 된다.
앞서 배웠듯 C라는 심벌 참조를 직접 참조로 해석하게 된다. 그 과정은 다음과 같다.
- C가 배열이 아니면 VM은 N이 가리키는 완전한 이름을 D의 클래스 로더에게 전달해 클래스 C를 로드
- 로딩 과정에서 여러 검증을 거치며 C가 구현한 인터페이스나 부모 클래스 등 관련 타입의 로딩까지 촉발할 수 있음
- C가 배열이고 원소 타입 객체라면 N의 서술자는 '\[Ljava/lang/Integer'와 같은 형태일 수 있다.
- 이 경우 첫 번째 규칙에 따라 로드한다.
- 앞의 단계들에서 예외가 발생하지 않았다면 C는 유효한 클래스 또는 인터페이스라는 뜻이다. 이후 D가 C에 접근할 수 있는지 심벌 참조 검증을 수행한다.

#### 필드 해석
필드 심벌참조를 해석하려면 필드의 타입으로 지정한 클래스 또는 인터페이스의 심벌 참조 해석이 먼저 진행되어야 한다.
해당 타입(클래스 또는 인터페이스)을 C라고 가정하며, 필드 해석 과정은 다음과 같다.
- 단순 이름 및  필드 서술자가 일치하는 필드가 C에 존재한다면 이 필드를 가리키는 직접 참조를 반환하고 검색을 종료
- C가 인터페이스를 구현한다면, 각 인터페이스와 그 상위 인터페이스 모두를 계층 구조 아래에서부터 재귀적으로 검색한다.
    - 단순 이름, 필드 서술자가 일치하는 필드를 정의한 인터페이스를 발견하면 검색을 종료
- 그렇지 않고 C가 java.lang.Object도 아니라면, 계층 구조 아래에서부터 상위 클래스를 재귀적으로 검색한다. 발견하지 못하면 NoSuchFieldError를 던진다.
- 검색이 성공하면 필드 접근 권한을 확인한다.

**여기서 이해가지 않았던 부분을 예시와 함께 다시 이해해보자.**
>아직 해석되지 않은 필드 심벌 참조를 해석하려면 필드 테이블의 class_index 항목이 가리키는 CONSTANT_Class_info 심벌 참조가 먼저 해석되어야 한다.
>클래스 또는 인터페이스를 C라 하고 C의 해석을 무사히 마쳤다고 한다면, 자바 가상 머신 명세는 C의 필드를 검색하는 단계를 다음과 같이 정의한다.

이 부분에서 필드 테이블의 class_index 항목이 무엇인지 오해하며 이해가 되지 않았다.
책에선 필드 테이블의 구조를 아래와 같이 설명했다.
```text
field_info {
    u2             access_flags;
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```
여기서 볼 때, class_index는 전혀 찾아 볼 수 없었다. 하지만 자바 가상 머신 명세에서 class_index를 검색해 해당 값이 CONSTANT_Fieldref_Info의 속성임을 알게 됐다.
```text
CONSTANT_Fieldref_info {
    u1 tag;
    u2 class_index;
    u2 name_and_type_index;
}
```
정리하자면 class_index가 가리키는 의미는 현재 필드가 정의되어 있는 클래스를 의미하며, 저자가 말한 필드 테이블은 실제 필드 테이블이 아니라 CONSTANT_Fieldref_info다.
GPT에 따르면 필드 테이블은 자기 클래스의 필드를 의미하며, CONSTANT_Fieldref_info는 외부 클래스의 필드를 의미한다고 한다. (사실 확인은 안됨)

## 초기화
초기화는 클래스 로딩의 마지막 단계다.
초기화 단계에서 JVM은 사용자 클래스에 작성된 자바 프로그램 코드를 실행한다.
-> \<clinit>() 메서드를 실행하는 단계

### \<clinit>()의 동작
\<clinit>()는 모든 클래스 변수 할당과 정적 문장 블록의 내용을 취합하여 컴파일러가 자동으로 생성한다.
정적 문장 블록에서는 정적 문장 블록보다 먼저 정의된 변수에만 접근할 수 있다. 하지만 할당하는 것은 가능하다. 아래 예시를 보자.
```java
public class Test {
	static {
		i = 0; // 나중에 정의한 변수에 값을 할당할 수 있음
		System.out.println(i); // 하지만 정의되기 전의 필드에 접근할 수 없음
	}

	static int i = 1;
}
```
>[!NOTE]
>**static 변수 vs static 블록**
>static 변수는 준비 단계에서 타입별 제로 값으로 초기화 되고, 초기화 단계에서 실제 값이 할당된다.
>static 블록은 초기화 단계에서 static 변수 초기화 이후 실행된다.

\<clinit>()은 \<init>()과 다르다. 즉, Java 언어 레벨에서의 생성자와 다르다.
부모 클래스의 생성자를 명시적으로 호출하지 않아도 JVM은 하위 클래스의 \<clinit>()가 실행되기 전에 부모 클래스의 \<clinit>()부터 실행한다.
그러므로 부모 클래스에 정의된 정적 문장 블록이 자식 클래스의 변수 할당 연산자보다 먼저 실행된다.

\<clinit>()가 클래스나 인터페이스에 반드시 필요하진 않다. 정적 문장 블록이 없고 정적 변수에 값을 할당하지 않는 클래스라면 없을 수도 있다.
인터페이스에서 정적 문장 블록을 사용할 수는 없지만 변수에 초깃값을 할당할 수는 있다. 즉, 인터페이스도 \<clinit>()을 가질 수 있다.
하지만 클래스와 달리 부모 인터페이스의 \<clinit>()를 먼저 실행하진 않는다.

JVM은 클래스의 \<clinit>()가 멀티 스레드 환경에서 적절히 동기화 되도록 해야 한다.
그래서 \<clinit>()에 오랜 시간이 소요되는 작업이 존재한다면 다른 스레드들이 계속 블록 상태가 될 수 있다.

# 3. 클래스 로더
클래스 로더는 독립적인 name space를 지니기 때문에 클래스 로더를 빼놓고는 특정 클래스가 JVM에서 유일한지 판단할 수 없다.
**즉, 두 클래스의 동치 여부는 두 클래스가 같은 클래스 로더를 통해 로드된 경우에만 유효하다.**

## 부모 위임 모델
JVM 관점에서 클래스 로더의 종류는 두 가지로 나눌 수 있다.
- JVM의 일부인 부트 스트랩 클래스 로더
- 그 외 모든 클래스 로더

하지만 개발자 관점에선 좀 더 여러 개로 나눌 수 있다.(JDK8 까지의 부모 위임 모델 기준)
- **부트스트랩 클래스 로더**
    - 프로그램에서 직접 참조할 수 없으며, 커스텀 클래스 로더 작성시 부트스트랩 클래스 로더로 로딩을 위임하려면 null을 사용해야 한다.
- **확장 클래스 로더**
    - sun.misc.Launcher$ExtClassLoader를 말하며 Java로 구현되어 있다.
    - 자바 시스템의 클래스 라이브러리를 확장하는 메커니즘으로 작동한다.
- **애플리케이션 클래스 로더**
    - sun.misc.Launcher$AppClassLoader를 가리킨다. 시스템 클래스 로더라고도 불린다.
    - 클래스 패스상의 클래스 라이브러리들을 로드하는 역할을 하며 개발자가 직접 사용할 수 있다.
    - 애플리케이션에서 별도로 클래스 로더를 만들지 않으면 이 로더가 기본 로더가 된다.
- **사용자 정의 클래스 로더**
    - 주로 로컬 디스크 외에 클래스 파일을 얻을 수 있는 위치를 추가하거나 클래스 격리 등의 기능을 구현하는데 이용

![[JVM 7장 - 클래스 로더 부모 위임 모델.png|300]]
부모 위임 모델이란 이름과는 다르게 실제는 부모-자식 관계보다 주로 컴포지션 관계로 구현하여  부모 로더의 코드를 재사용한다.

부모 위임 모델은 아래와 같이 동작한다.
- 모든 로드 요청은 우선 최상위인 부트스트랩 클래스 로더로 위임
- 요청 받은 클래스가 자신의 검색 범위에 없다면 비로소 하위 로더가 시도
  이와 같은 작동 방식 덕분에 아무리 많은 클래스 로더를 활용하더라도 Object 클래스가 모두 동일한 클래스임을 보장할 수 있다.
  부모 위임 모델은 아주 쉽게 구현할 수 있다. 아래의 예시를 보자.
```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
	syncronized (getClassLoadingLock(name)) {
		// 요청받은 클래스가 이미 로드되어 있는지 확인한다.
		Class<?> c = findLoadedClass(name);
		if (c == null) {
			try {
				if (parent != null) {
					c = parent.loadClass(name, false);
				} else {
					c = findBootstrapClassOrNull(name);
				}
			} catch (ClassNotFoundException e) {
				// 부모 클래스 로더가 해당 예외를 던지면 요청을 처리할 수 없다는 뜻이다.
			}

			if (c == null) {
				// 부모 클래스 로더가 실패하면 자신의 메서드를 호출해 직접 시도
				c = findClass(name);
			}
		}

		if (resolve) {
			resolveClass(c);
		}

		return c;
	}
}
```

### 부모 위임 모델의 위기
부모 위임 모델은 권장되는 모델이지만 절대적이진 않다.

먼저 부모 위임 모델 자체의 결함이 존재한다.
예를 들어,  JDK 내부 클래스가 사용자 정의 클래스를 호출 해야 하는 상황이 그러하다.
즉, 부모 위임 모델에선 부트스트래 클래스 로더는 사용자 정의 클래스를 알 수 없다.

다음은 사용자들이 프로그램에 핫스왑, 모듈 핫 배포와 같은 동적 능력에 대한 요구였다.

# 4. 자바 모듈 시스템
JDK 9에서 모듈 시스템이 추가되며  안정성이 떨어지던 기존의 클래스 패스에 기초하던 방식을 개선했다.
-> 필요한 의존성을 개발 단계에서 파악해 많은 런타임 예외를 피할 수 있게됨

## 모듈 호환성
기존 클래스패스 방식과 호환되도록 하기 위해 JDK 9에선 모듈 패스 개념을 도입했다.
클래스 라이브러리 위치에 따라 모듈인지 전통적인 JAR 패키지인지 결정한다.

## 모듈화 시대의 클래스 로더
![[JVM 7장 - JDK9 이후 클래스 로더 위임 방식.jpg| 400]]
모듈 시스템이 추가되며 클래스 로더의 모델이 조금 변했다.
- 확장 클래스 로더 -> 플랫폼 클래스 로더
- 플랫폼 클래스 로더와 애플리케이션 클래스 로더가 더는 java.net.URLClassLoader로부터 파생되지 않는다.
    - 대신 jdk.internal.loader.BuiltinClassLoader에서 파생된다.
- 부모 위임 모델의 전체적인 아키텍처는 유지하지만 클래스 로딩의 위임 관계에 변화를 줬다.
    - 로딩 요청을 받은 플랫폼, 애플리케이션 클래스 로더는 부모 로더에게 위임하기 전에 해당 클래스가 특정 시스템 모듈에 속하는지 확인
    - 특정 시스템 모듈에 속한다면 해당 모듈을 담당하는 로더에게 위임